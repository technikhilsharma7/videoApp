function applyPolyfills() {
  var promises = [];
  if (typeof window !== 'undefined') {
    var win = window;
 
    if (!win.customElements ||
      (win.Element && (!win.Element.prototype.closest || !win.Element.prototype.matches || !win.Element.prototype.remove || !win.Element.prototype.getRootNode))) {
      promises.push(import(/* webpackChunkName: "polyfills-dom" */ './dom.js'));
    }

    var checkIfURLIsSupported = function() {
      try {
        var u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        return (u.href === 'http://a/c%20d') && u.searchParams;
      } catch (e) {
        return false;
      }
    };

    if (
      'function' !== typeof Object.assign || !Object.entries ||
      !Array.prototype.find || !Array.prototype.includes ||
      !String.prototype.startsWith || !String.prototype.endsWith ||
      (win.NodeList && !win.NodeList.prototype.forEach) ||
      !win.fetch ||
      !checkIfURLIsSupported() ||
      typeof WeakMap == 'undefined'
    ) {
      promises.push(import(/* webpackChunkName: "polyfills-core-js" */ './core-js.js'));
    }
  }
  return Promise.all(promises);
}


const NAMESPACE = 'dyte-ui-kit';

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
let scopeId;
let contentRef;
let hostTagName;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queuePending = false;
const createTime = (fnName, tagName = '') => {
    {
        return () => {
            return;
        };
    }
};
const uniqueTime = (key, measureText) => {
    {
        return () => {
            return;
        };
    }
};
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
const XLINK_NS = 'http://www.w3.org/1999/xlink';
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
const isDef = (v) => v != null;
const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        // normalize class / classname attributes
        if (vnodeData.key) {
            key = vnodeData.key;
        }
        if (vnodeData.name) {
            slotName = vnodeData.name;
        }
        {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    {
        vnode.$key$ = key;
    }
    {
        vnode.$name$ = slotName;
    }
    return vnode;
};
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    {
        vnode.$attrs$ = null;
    }
    {
        vnode.$key$ = null;
    }
    {
        vnode.$name$ = null;
    }
    return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
};
const convertToPublic = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
const convertToPrivate = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
        if (propType & 4 /* MEMBER_FLAGS.Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
        }
        if (propType & 2 /* MEMBER_FLAGS.Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (propType & 1 /* MEMBER_FLAGS.String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
        }
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getElement = (ref) => (getHostRef(ref).$hostElement$ );
const createEvent = (ref, name, flags) => {
    const elm = getElement(ref);
    return {
        emit: (detail) => {
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
                detail,
            });
        },
    };
};
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const rootAppliedStyles = /*@__PURE__*/ new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructableStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        if (typeof style === 'string') {
            style = cssText;
        }
        else {
            style.replaceSync(cssText);
        }
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    let scopeId = getScopeId(cmpMeta);
    const style = styles.get(scopeId);
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                {
                    {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
    if (flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (cmp.$tagName$);
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        }
        else if (memberName === 'style') {
            // update style attribute, css properties and values
            {
                for (const prop in oldValue) {
                    if (!newValue || newValue[prop] == null) {
                        if (prop.includes('-')) {
                            elm.style.removeProperty(prop);
                        }
                        else {
                            elm.style[prop] = '';
                        }
                    }
                }
            }
            for (const prop in newValue) {
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (prop.includes('-')) {
                        elm.style.setProperty(prop, newValue[prop]);
                    }
                    else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        }
        else if (memberName === 'key')
            ;
        else if (memberName === 'ref') {
            // minifier will clean this up
            if (newValue) {
                newValue(elm);
            }
        }
        else if ((!isProp ) &&
            memberName[0] === 'o' &&
            memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        const n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */
            let xlink = false;
            {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    if (xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    }
                    else {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                if (xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                }
                else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
        ? newVnode.$elm$.host
        : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
/**
 * Create a DOM Node corresponding to one of the children of a given VNode.
 *
 * @param oldParentVNode the parent VNode from the previous render
 * @param newParentVNode the parent VNode from the current render
 * @param childIndex the index of the VNode, in the _new_ parent node's
 * children, for which we will create a new DOM node
 * @param parentElm the parent DOM node which our new node will be a child of
 * @returns the newly created node
 */
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    const newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (!useNativeShadowDom) {
        // remember for later we need to check to relocate nodes
        checkSlotRelocate = true;
        if (newVNode.$tag$ === 'slot') {
            if (scopeId) {
                // scoped css needs to add its scoped id to the parent element
                parentElm.classList.add(scopeId + '-s');
            }
            newVNode.$flags$ |= newVNode.$children$
                ? // slot element has fallback content
                    2 /* VNODE_FLAGS.isSlotFallback */
                : // slot element does not have fallback content
                    1 /* VNODE_FLAGS.isSlotReference */;
        }
    }
    if (newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else if (newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {
        // create a slot reference node
        elm = newVNode.$elm$ =
            doc.createTextNode('');
    }
    else {
        // create element
        elm = newVNode.$elm$ = (doc.createElement(newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */
                ? 'slot-fb'
                : newVNode.$tag$));
        // add css classes, attrs, props, listeners, etc.
        {
            updateElement(null, newVNode, isSvgMode);
        }
        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i, elm);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
    }
    {
        elm['s-hn'] = hostTagName;
        if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {
            // remember the content reference comment
            elm['s-sr'] = true;
            // remember the content reference comment
            elm['s-cr'] = contentRef;
            // remember the slot name, or empty string for default slot
            elm['s-sn'] = newVNode.$name$ || '';
            // check if we've got an old vnode for this slot
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
                // we've got an old slot vnode and the wrapper is being replaced
                // so let's move the old slot content back to it's original location
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
    plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    const oldSlotChildNodes = parentElm.childNodes;
    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
        const childNode = oldSlotChildNodes[i];
        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
            // // this child node in the old element is from another component
            // // remove this node from the old slot's parent
            // childNode.remove();
            // and relocate it back to it's original location
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            // remove the old original location comment entirely
            // later on the patch function will know what to do
            // and move this to the correct spot in need be
            childNode['s-ol'].remove();
            childNode['s-ol'] = undefined;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = ((parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);
    let childNode;
    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, referenceNode(before) );
            }
        }
    }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            {
                // we're removing this element
                // so it's possible we need to show slot fallback content now
                checkSlotFallbackVisibility = true;
                if (elm['s-ol']) {
                    // remove the original location comment
                    elm['s-ol'].remove();
                }
                else {
                    // it's possible that child nodes of the node
                    // that's being removed are slot nodes
                    putBackInOriginalLocation(elm, true);
                }
            }
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
/**
 * Reconcile the children of a new VNode with the children of an old VNode by
 * traversing the two collections of children, identifying nodes that are
 * conserved or changed, calling out to `patch` to make any necessary
 * updates to the DOM, and rearranging DOM nodes as needed.
 *
 * The algorithm for reconciling children works by analyzing two 'windows' onto
 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
 * 'windows' by storing start and end indices and references to the
 * corresponding array entries. Initially the two 'windows' are basically equal
 * to the entire array, but we progressively narrow the windows until there are
 * no children left to update by doing the following:
 *
 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
 *    that if we have an initial array like the following we'll end up dealing
 *    only with a window bounded by the highlighted elements:
 *
 *    [null, null, VNode1 , ... , VNode2, null, null]
 *                 ^^^^^^         ^^^^^^
 *
 * 2. Check to see if the elements at the head and tail positions are equal
 *    across the windows. This will basically detect elements which haven't
 *    been added, removed, or changed position, i.e. if you had the following
 *    VNode elements (represented as HTML):
 *
 *    oldVNode: `<div><p><span>HEY</span></p></div>`
 *    newVNode: `<div><p><span>THERE</span></p></div>`
 *
 *    Then when comparing the children of the `<div>` tag we check the equality
 *    of the VNodes corresponding to the `<p>` tags and, since they are the
 *    same tag in the same position, we'd be able to avoid completely
 *    re-rendering the subtree under them with a new DOM element and would just
 *    call out to `patch` to handle reconciling their children and so on.
 *
 * 3. Check, for both windows, to see if the element at the beginning of the
 *    window corresponds to the element at the end of the other window. This is
 *    a heuristic which will let us identify _some_ situations in which
 *    elements have changed position, for instance it _should_ detect that the
 *    children nodes themselves have not changed but merely moved in the
 *    following example:
 *
 *    oldVNode: `<div><element-one /><element-two /></div>`
 *    newVNode: `<div><element-two /><element-one /></div>`
 *
 *    If we find cases like this then we also need to move the concrete DOM
 *    elements corresponding to the moved children to write the re-order to the
 *    DOM.
 *
 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
 *    nodes in the old children which have the same key as the first element in
 *    our window on the new children. If we find such a node we handle calling
 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
 *    what we find.
 *
 * Finally, once we've narrowed our 'windows' to the point that either of them
 * collapse (i.e. they have length 0) we then handle any remaining VNode
 * insertion or deletion that needs to happen to get a DOM state that correctly
 * reflects the new child VNodes. If, for instance, after our window on the old
 * children has collapsed we still have more nodes on the new children that
 * we haven't dealt with yet then we need to add them, or if the new children
 * collapse but we still have unhandled _old_ children then we need to make
 * sure the corresponding DOM nodes are removed.
 *
 * @param parentElm the node into which the parent VNode is rendered
 * @param oldCh the old children of the parent node
 * @param newVNode the new VNode which will replace the parent
 * @param newCh the new children of the parent node
 */
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // VNode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            // if the start nodes are the same then we should patch the new VNode
            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
            // indices to reflect that. We don't need to move any DOM Nodes around
            // since things are matched up in order.
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            // likewise, if the end nodes are the same we patch new onto old and
            // decrement our end indices, and also likewise in this case we don't
            // need to move any DOM Nodes.
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            // case: "Vnode moved right"
            //
            // We've found that the last node in our window on the new children is
            // the same VNode as the _first_ node in our window on the old children
            // we're dealing with now. Visually, this is the layout of these two
            // nodes:
            //
            // newCh: [..., newStartVnode , ... , newEndVnode , ...]
            //                                    ^^^^^^^^^^^
            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
            //              ^^^^^^^^^^^^^
            //
            // In this situation we need to patch `newEndVnode` onto `oldStartVnode`
            // and move the DOM element for `oldStartVnode`.
            if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            // We need to move the element for `oldStartVnode` into a position which
            // will be appropriate for `newEndVnode`. For this we can use
            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
            //
            // <old-start-node />
            // <some-intervening-node />
            // <old-end-node />
            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
            // <next-sibling />
            //
            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
            // the node for `oldStartVnode` at the end of the children of
            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
            // aren't any siblings, and passing `null` to `Node.insertBefore` will
            // append it to the children of the parent element.
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            // case: "Vnode moved left"
            //
            // We've found that the first node in our window on the new children is
            // the same VNode as the _last_ node in our window on the old children.
            // Visually, this is the layout of these two nodes:
            //
            // newCh: [..., newStartVnode , ... , newEndVnode , ...]
            //              ^^^^^^^^^^^^^
            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
            //                                    ^^^^^^^^^^^
            //
            // In this situation we need to patch `newStartVnode` onto `oldEndVnode`
            // (which will handle updating any changed attributes, reconciling their
            // children etc) but we also need to move the DOM node to which
            // `oldEndVnode` corresponds.
            if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            // We've already checked above if `oldStartVnode` and `newStartVnode` are
            // the same node, so since we're here we know that they are not. Thus we
            // can move the element for `oldEndVnode` _before_ the element for
            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
            // future.
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            // Here we do some checks to match up old and new nodes based on the
            // `$key$` attribute, which is set by putting a `key="my-key"` attribute
            // in the JSX for a DOM element in the implementation of a Stencil
            // component.
            //
            // First we check to see if there are any nodes in the array of old
            // children which have the same key as the first node in the new
            // children.
            idxInOld = -1;
            {
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                        idxInOld = i;
                        break;
                    }
                }
            }
            if (idxInOld >= 0) {
                // We found a node in the old children which matches up with the first
                // node in the new children! So let's deal with that
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    // the tag doesn't match so we'll need a new DOM element
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
                }
                else {
                    patch(elmToMove, newStartVnode);
                    // invalidate the matching old node so that we won't try to update it
                    // again later on
                    oldCh[idxInOld] = undefined;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // We either didn't find an element in the old children that matches
                // the key of the first new child OR the build is not using `key`
                // attributes at all. In either case we need to create a new element
                // for the new node.
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                // if we created a new node then handle inserting it to the DOM
                {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        // we have some more new nodes to add which don't match up with old nodes
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (newStartIdx > newEndIdx) {
        // there are nodes in the `oldCh` array which no longer correspond to nodes
        // in the new array, so lets remove them (which entails cleaning up the
        // relevant DOM nodes)
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
/**
 * Compare two VNodes to determine if they are the same
 *
 * **NB**: This function is an equality _heuristic_ based on the available
 * information set on the two VNodes and can be misleading under certain
 * circumstances. In particular, if the two nodes do not have `key` attrs
 * (available under `$key$` on VNodes) then the function falls back on merely
 * checking that they have the same tag.
 *
 * So, in other words, if `key` attrs are not set on VNodes which may be
 * changing order within a `children` array or something along those lines then
 * we could obtain a false positive and then have to do needless re-rendering.
 *
 * @param leftVNode the first VNode to check
 * @param rightVNode the second VNode to check
 * @returns whether they're equal or not
 */
const isSameVnode = (leftVNode, rightVNode) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (leftVNode.$tag$ === 'slot') {
            return leftVNode.$name$ === rightVNode.$name$;
        }
        // this will be set if components in the build have `key` attrs set on them
        {
            return leftVNode.$key$ === rightVNode.$key$;
        }
    }
    return false;
};
const referenceNode = (node) => {
    // this node was relocated to a new location in the dom
    // because of some other component's slot
    // but we still have an html comment in place of where
    // it's original location was according to it's original vdom
    return (node && node['s-ol']) || node;
};
const parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;
/**
 * Handle reconciling an outdated VNode with a new one which corresponds to
 * it. This function handles flushing updates to the DOM and reconciling the
 * children of the two nodes (if any).
 *
 * @param oldVNode an old VNode whose DOM element and children we want to update
 * @param newVNode a new VNode representing an updated version of the old one
 */
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const tag = newVNode.$tag$;
    const text = newVNode.$text$;
    let defaultHolder;
    if (text === null) {
        {
            if (tag === 'slot')
                ;
            else {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            // so we need to call `updateChildren` to reconcile them
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
    }
    else if ((defaultHolder = elm['s-cr'])) {
        // this element has slotted content
        defaultHolder.parentNode.textContent = text;
    }
    else if (oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const updateFallbackSlotVisibility = (elm) => {
    // tslint:disable-next-line: prefer-const
    const childNodes = elm.childNodes;
    let childNode;
    let i;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for (i = 0, ilen = childNodes.length; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            if (childNode['s-sr']) {
                // this is a slot fallback node
                // get the slot name for this slot reference node
                slotNameAttr = childNode['s-sn'];
                // by default always show a fallback slot node
                // then hide it if there are other slots in the light dom
                childNode.hidden = false;
                for (j = 0; j < ilen; j++) {
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {
                        // this sibling node is from a different component OR is a named fallback slot node
                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                    else {
                        // this is a default fallback slot node
                        // any element or text node (with content)
                        // should hide the default fallback slot node
                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ ||
                            (nodeType === 3 /* NODE_TYPE.TextNode */ && childNodes[j].textContent.trim() !== '')) {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            // keep drilling down
            updateFallbackSlotVisibility(childNode);
        }
    }
};
const relocateNodes = [];
const relocateSlotContent = (elm) => {
    // tslint:disable-next-line: prefer-const
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i = 0;
    const childNodes = elm.childNodes;
    const ilen = childNodes.length;
    for (; i < ilen; i++) {
        childNode = childNodes[i];
        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
            // first got the content reference comment node
            // then we got it's parent, which is where all the host content is in now
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode['s-sn'];
            for (j = hostContentNodes.length - 1; j >= 0; j--) {
                node = hostContentNodes[j];
                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
                    // let's do some relocating to its new home
                    // but never relocate a content reference node
                    // that is suppose to always represent the original content location
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        // it's possible we've already decided to relocate this node
                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                        // made some changes to slots
                        // let's make sure we also double check
                        // fallbacks are correctly hidden or shown
                        checkSlotFallbackVisibility = true;
                        node['s-sn'] = node['s-sn'] || slotNameAttr;
                        if (relocateNodeData) {
                            // previously we never found a slot home for this node
                            // but turns out we did, so let's remember it now
                            relocateNodeData.$slotRefNode$ = childNode;
                        }
                        else {
                            // add to our list of nodes to relocate
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node,
                            });
                        }
                        if (node['s-sr']) {
                            relocateNodes.map((relocateNode) => {
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    }
                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
                        // so far this element does not have a slot home, not setting slotRefNode on purpose
                        // if we never find a home for this element then we'll need to hide it
                        relocateNodes.push({
                            $nodeToRelocate$: node,
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            relocateSlotContent(childNode);
        }
    }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {
            return true;
        }
        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate['s-sn'] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === '';
};
const callNodeRefs = (vNode) => {
    {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    if (cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
    {
        scopeId = hostElm['s-sc'];
    }
    {
        contentRef = hostElm['s-cr'];
        useNativeShadowDom = (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
        // always reset
        checkSlotFallbackVisibility = false;
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
    {
        // while we're moving nodes around existing nodes, temporarily disable
        // the disconnectCallback from working
        plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i = 0;
            for (; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate['s-ol']) {
                    // add a reference node marking this node's original location
                    // keep a reference to this node for later lookups
                    orgLocationNode =
                        doc.createTextNode('');
                    orgLocationNode['s-nr'] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);
                }
            }
            for (i = 0; i < relocateNodes.length; i++) {
                relocateData = relocateNodes[i];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    // by default we're just going to insert it directly
                    // after the slot reference node
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate['s-ol'];
                    while ((orgLocationNode = orgLocationNode.previousSibling)) {
                        refNode = orgLocationNode['s-nr'];
                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode['s-nr']) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||
                        nodeToRelocate.nextSibling !== insertBeforeNode) {
                        // we've checked that it's worth while to relocate
                        // since that the node to relocate
                        // has a different next sibling or parent relocated
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                                // probably a component in the index.html that doesn't have it's hostname set
                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
                            }
                            // add it back to the dom but in its new home
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                }
                else {
                    // this node doesn't have a slot home to go to, so let's hide it
                    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        // done moving nodes around
        // allow the disconnect callback to work again
        plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
        // always reset
        relocateNodes.length = 0;
    }
};
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    {
        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
    }
    if (hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return writeTask(dispatch) ;
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = hostRef.$lazyInstance$ ;
    let promise;
    if (isInitialLoad) {
        {
            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
                hostRef.$queuedListeners$ = null;
            }
        }
        {
            promise = safeCall(instance, 'componentWillLoad');
        }
    }
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    {
        callRender(hostRef, instance);
    }
    if (rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map((cb) => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
};
const callRender = (hostRef, instance, elm) => {
    try {
        renderingRef = instance;
        instance = instance.render() ;
        {
            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
        }
        {
            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
        }
        {
            {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                {
                    renderVdom(hostRef, instance);
                }
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
const getRenderingRef = () => renderingRef;
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const instance = hostRef.$lazyInstance$ ;
    const ancestorComponent = hostRef.$ancestorComponent$;
    {
        safeCall(instance, 'componentDidRender');
    }
    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
        {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        {
            safeCall(instance, 'componentDidLoad');
        }
        endPostUpdate();
        {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad();
            }
        }
    }
    else {
        endPostUpdate();
    }
    {
        hostRef.$onInstanceResolve$(elm);
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
    }
    // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
};
const forceUpdate = (ref) => {
    {
        const hostRef = getHostRef(ref);
        const isConnected = hostRef.$hostElement$.isConnected;
        if (isConnected &&
            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
            scheduleUpdate(hostRef, false);
        }
        // Returns "true" when the forced update was successfully scheduled
        return isConnected;
    }
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    {
        addHydratedFlag(doc.documentElement);
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
};
const safeCall = (instance, method, arg) => {
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        }
        catch (e) {
            consoleError(e);
        }
    }
    return undefined;
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const addHydratedFlag = (elm) => elm.classList.add('hydrated')
    ;
const getValue$1 = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const elm = hostRef.$hostElement$ ;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = hostRef.$lazyInstance$ ;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
            // get an array of method names of watch functions to call
            if (cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    // this instance is watching for when this property changed
                    watchMethods.map((watchMethodName) => {
                        try {
                            // fire off each of the watch methods that are watching this property
                            instance[watchMethodName](newVal, oldVal, propName);
                        }
                        catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if ((flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
/**
 * Attach a series of runtime constructs to a compiled Stencil component
 * constructor, including getters and setters for the `@Prop` and `@State`
 * decorators, callbacks for when attributes change, and so on.
 *
 * @param Cstr the constructor for a component that we need to process
 * @param cmpMeta metadata collected previously about the component
 * @param flags a number used to store a series of bit flags
 * @returns a reference to the same constructor passed in (but now mutated)
 */
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (cmpMeta.$members$) {
        if (Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
                    ((flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue$1(this, memberName);
                    },
                    set(newValue) {
                        // proxyComponent, set value
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
            else if (flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
                memberFlags & 64 /* MEMBER_FLAGS.Method */) {
                // proxyComponent - method
                Object.defineProperty(prototype, memberName, {
                    value(...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
                    },
                });
            }
        });
        if ((flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
            const attrNameToPropName = new Map();
            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                plt.jmp(() => {
                    const propName = attrNameToPropName.get(attrName);
                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
                    //  in the case where an attribute was set inline.
                    //  ```html
                    //    <my-component some-attribute="some-value"></my-component>
                    //  ```
                    //
                    //  There is an edge case where a developer sets the attribute inline on a custom element and then
                    //  programmatically changes it before it has been upgraded as shown below:
                    //
                    //  ```html
                    //    <!-- this component has _not_ been upgraded yet -->
                    //    <my-component id="test" some-attribute="some-value"></my-component>
                    //    <script>
                    //      // grab non-upgraded component
                    //      el = document.querySelector("#test");
                    //      el.someAttribute = "another-value";
                    //      // upgrade component
                    //      customElements.define('my-component', MyComponent);
                    //    </script>
                    //  ```
                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
                    //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
                    //  to the value that was set inline i.e. "some-value" from above example. When
                    //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
                    //
                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
                    //  by connectedCallback as this attributeChangedCallback will not fire.
                    //
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
                    //
                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
                    //  properties here given that this goes against best practices outlined here
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    }
                    else if (prototype.hasOwnProperty(propName) &&
                        typeof this[propName] === 'number' &&
                        this[propName] == newValue) {
                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                });
            };
            // create an array of attributes to observe
            // and also create a map of html attribute name to js property name
            Cstr.observedAttributes = members
                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes
                .map(([propName, m]) => {
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
                    cmpMeta.$attrsToReflect$.push([propName, attrName]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
        {
            // we haven't initialized this element yet
            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
            // lazy loaded components
            // request the component's implementation to be
            // wired up with the host element
            Cstr = loadModule(cmpMeta);
            if (Cstr.then) {
                // Await creates a micro-task avoid if possible
                const endLoad = uniqueTime();
                Cstr = await Cstr;
                endLoad();
            }
            if (!Cstr.isProxied) {
                // we've never proxied this Constructor before
                // let's add the getters/setters to its prototype before
                // the first time we create an instance of the implementation
                {
                    cmpMeta.$watchers$ = Cstr.watchers;
                }
                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
                Cstr.isProxied = true;
            }
            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
            // ok, time to construct the instance
            // but let's keep track of when we start and stop
            // so that the getters/setters don't incorrectly step on data
            {
                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
            }
            // construct the lazy-loaded component implementation
            // passing the hostRef is very important during
            // construction in order to directly wire together the
            // host element and the lazy-loaded instance
            try {
                new Cstr(hostRef);
            }
            catch (e) {
                consoleError(e);
            }
            {
                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
            }
            {
                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
            }
            endNewInstance();
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        if (Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            const scopeId = getScopeId(cmpMeta);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (ancestorComponent && ancestorComponent['s-rc']) {
        // this is the initial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const fireConnectedCallback = (instance) => {
    {
        safeCall(instance, 'connectedCallback');
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
            {
                // initUpdate
                // if the slot polyfill is required we'll need to put some nodes
                // in here to act as original content anchors as we move nodes around
                // host element has been connected to the DOM
                if ((cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */))) {
                    setContentReference(elm);
                }
            }
            {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if (ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        else {
            // not the first time this has connected
            // reattach any event listeners to the host
            // since they would have been removed when disconnected
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
            // fire off connectedCallback() on component instance
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
const setContentReference = (elm) => {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    const contentRefElm = (elm['s-cr'] = doc.createComment(''));
    contentRefElm['s-cn'] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const instance = hostRef.$lazyInstance$ ;
        {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener) => rmListener());
                hostRef.$rmListeners$ = undefined;
            }
        }
        {
            safeCall(instance, 'disconnectedCallback');
        }
    }
};
const bootstrapLazy = (lazyBundles, options = {}) => {
    const endBootstrap = createTime();
    const cmpTags = [];
    const exclude = options.exclude || [];
    const customElements = win.customElements;
    const head = doc.head;
    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');
    const deferredConnectedCallbacks = [];
    let appLoadFallback;
    let isBootstrapping = true;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
            const cmpMeta = {
                $flags$: compactMeta[0],
                $tagName$: compactMeta[1],
                $members$: compactMeta[2],
                $listeners$: compactMeta[3],
            };
            {
                cmpMeta.$members$ = compactMeta[2];
            }
            {
                cmpMeta.$listeners$ = compactMeta[3];
            }
            {
                cmpMeta.$attrsToReflect$ = [];
            }
            {
                cmpMeta.$watchers$ = {};
            }
            const tagName = cmpMeta.$tagName$;
            const HostElement = class extends HTMLElement {
                // StencilLazyHost
                constructor(self) {
                    // @ts-ignore
                    super(self);
                    self = this;
                    registerHost(self, cmpMeta);
                    if (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                        // this component is using shadow dom
                        // and this browser supports shadow dom
                        // add the read-only property "shadowRoot" to the host element
                        // adding the shadow root build conditionals to minimize runtime
                        {
                            {
                                self.attachShadow({ mode: 'open' });
                            }
                        }
                    }
                }
                connectedCallback() {
                    if (appLoadFallback) {
                        clearTimeout(appLoadFallback);
                        appLoadFallback = null;
                    }
                    if (isBootstrapping) {
                        // connectedCallback will be processed once all components have been registered
                        deferredConnectedCallbacks.push(this);
                    }
                    else {
                        plt.jmp(() => connectedCallback(this));
                    }
                }
                disconnectedCallback() {
                    plt.jmp(() => disconnectedCallback(this));
                }
                componentOnReady() {
                    return getHostRef(this).$onReadyPromise$;
                }
            };
            cmpMeta.$lazyBundleId$ = lazyBundle[0];
            if (!exclude.includes(tagName) && !customElements.get(tagName)) {
                cmpTags.push(tagName);
                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
            }
        });
    });
    {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute('data-styles', '');
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
    // Process deferred connectedCallbacks now all components have been registered
    isBootstrapping = false;
    if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
    }
    else {
        {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
        }
    }
    // Fallback appLoad event
    endBootstrap();
};
const Fragment = (_, children) => children;
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
    if (listeners) {
        listeners.map(([flags, name, method]) => {
            const target = getHostListenerTarget(elm, flags) ;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
        });
    }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
    try {
        {
            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
                // instance is ready, let's call it's member method for this event
                hostRef.$lazyInstance$[methodName](ev);
            }
            else {
                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
            }
        }
    }
    catch (e) {
        consoleError(e);
    }
};
const getHostListenerTarget = (elm, flags) => {
    if (flags & 8 /* LISTENER_FLAGS.TargetWindow */)
        return win;
    return elm;
};
// prettier-ignore
const hostListenerOpts = (flags) => (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
const hostRefs = /*@__PURE__*/ new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    {
        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
    }
    {
        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (0, console.error)(e, el);
const cmpModules = /*@__PURE__*/ new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
    // loadModuleImport
    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    const bundleId = cmpMeta.$lazyBundleId$;
    const module = cmpModules.get(bundleId) ;
    if (module) {
        return module[exportName];
    }
    
    if (!hmrVersionId || !BUILD.hotModuleReplacement) {
      const processMod = importedModule => {
        cmpModules.set(bundleId, importedModule);
        return importedModule[exportName];
      };
      switch(bundleId) {
        
        case 'dyte-meeting':
          return Promise.resolve().then(function () { return dyteMeeting_entry; }).then(processMod, consoleError);
        case 'dyte-ai':
          return Promise.resolve().then(function () { return dyteAi_entry; }).then(processMod, consoleError);
        case 'dyte-ai-chat':
          return Promise.resolve().then(function () { return dyteAiChat_entry; }).then(processMod, consoleError);
        case 'dyte-ai-home':
          return Promise.resolve().then(function () { return dyteAiHome_entry; }).then(processMod, consoleError);
        case 'dyte-ai-toggle':
          return Promise.resolve().then(function () { return dyteAiToggle_entry; }).then(processMod, consoleError);
        case 'dyte-ai-transcriptions':
          return Promise.resolve().then(function () { return dyteAiTranscriptions_entry; }).then(processMod, consoleError);
        case 'dyte-breakout-rooms-manager':
          return Promise.resolve().then(function () { return dyteBreakoutRoomsManager_entry; }).then(processMod, consoleError);
        case 'dyte-breakout-rooms-toggle':
          return Promise.resolve().then(function () { return dyteBreakoutRoomsToggle_entry; }).then(processMod, consoleError);
        case 'dyte-broadcast-message-modal':
          return Promise.resolve().then(function () { return dyteBroadcastMessageModal_entry; }).then(processMod, consoleError);
        case 'dyte-camera-toggle':
          return Promise.resolve().then(function () { return dyteCameraToggle_entry; }).then(processMod, consoleError);
        case 'dyte-channel-creator':
          return Promise.resolve().then(function () { return dyteChannelCreator_entry; }).then(processMod, consoleError);
        case 'dyte-chat-toggle':
          return Promise.resolve().then(function () { return dyteChatToggle_entry; }).then(processMod, consoleError);
        case 'dyte-clock':
          return Promise.resolve().then(function () { return dyteClock_entry; }).then(processMod, consoleError);
        case 'dyte-confirmation-modal':
          return Promise.resolve().then(function () { return dyteConfirmationModal_entry; }).then(processMod, consoleError);
        case 'dyte-controlbar':
          return Promise.resolve().then(function () { return dyteControlbar_entry; }).then(processMod, consoleError);
        case 'dyte-debugger':
          return Promise.resolve().then(function () { return dyteDebugger_entry; }).then(processMod, consoleError);
        case 'dyte-debugger-network':
          return Promise.resolve().then(function () { return dyteDebuggerNetwork_entry; }).then(processMod, consoleError);
        case 'dyte-debugger-toggle':
          return Promise.resolve().then(function () { return dyteDebuggerToggle_entry; }).then(processMod, consoleError);
        case 'dyte-ended-screen':
          return Promise.resolve().then(function () { return dyteEndedScreen_entry; }).then(processMod, consoleError);
        case 'dyte-fullscreen-toggle':
          return Promise.resolve().then(function () { return dyteFullscreenToggle_entry; }).then(processMod, consoleError);
        case 'dyte-grid':
          return Promise.resolve().then(function () { return dyteGrid_entry; }).then(processMod, consoleError);
        case 'dyte-grid-pagination':
          return Promise.resolve().then(function () { return dyteGridPagination_entry; }).then(processMod, consoleError);
        case 'dyte-header':
          return Promise.resolve().then(function () { return dyteHeader_entry; }).then(processMod, consoleError);
        case 'dyte-idle-screen':
          return Promise.resolve().then(function () { return dyteIdleScreen_entry; }).then(processMod, consoleError);
        case 'dyte-image-viewer':
          return Promise.resolve().then(function () { return dyteImageViewer_entry; }).then(processMod, consoleError);
        case 'dyte-leave-button':
          return Promise.resolve().then(function () { return dyteLeaveButton_entry; }).then(processMod, consoleError);
        case 'dyte-leave-meeting':
          return Promise.resolve().then(function () { return dyteLeaveMeeting_entry; }).then(processMod, consoleError);
        case 'dyte-livestream-toggle':
          return Promise.resolve().then(function () { return dyteLivestreamToggle_entry; }).then(processMod, consoleError);
        case 'dyte-meeting-title':
          return Promise.resolve().then(function () { return dyteMeetingTitle_entry; }).then(processMod, consoleError);
        case 'dyte-mic-toggle':
          return Promise.resolve().then(function () { return dyteMicToggle_entry; }).then(processMod, consoleError);
        case 'dyte-mixed-grid':
          return Promise.resolve().then(function () { return dyteMixedGrid_entry; }).then(processMod, consoleError);
        case 'dyte-more-toggle':
          return Promise.resolve().then(function () { return dyteMoreToggle_entry; }).then(processMod, consoleError);
        case 'dyte-mute-all-button':
          return Promise.resolve().then(function () { return dyteMuteAllButton_entry; }).then(processMod, consoleError);
        case 'dyte-mute-all-confirmation':
          return Promise.resolve().then(function () { return dyteMuteAllConfirmation_entry; }).then(processMod, consoleError);
        case 'dyte-name-tag':
          return Promise.resolve().then(function () { return dyteNameTag_entry; }).then(processMod, consoleError);
        case 'dyte-network-indicator':
          return Promise.resolve().then(function () { return dyteNetworkIndicator_entry; }).then(processMod, consoleError);
        case 'dyte-participant-count':
          return Promise.resolve().then(function () { return dyteParticipantCount_entry; }).then(processMod, consoleError);
        case 'dyte-participant-setup':
          return Promise.resolve().then(function () { return dyteParticipantSetup_entry; }).then(processMod, consoleError);
        case 'dyte-participants-audio':
          return Promise.resolve().then(function () { return dyteParticipantsAudio_entry; }).then(processMod, consoleError);
        case 'dyte-participants-stage-list':
          return Promise.resolve().then(function () { return dyteParticipantsStageList_entry; }).then(processMod, consoleError);
        case 'dyte-participants-stage-queue':
          return Promise.resolve().then(function () { return dyteParticipantsStageQueue_entry; }).then(processMod, consoleError);
        case 'dyte-participants-toggle':
          return Promise.resolve().then(function () { return dyteParticipantsToggle_entry; }).then(processMod, consoleError);
        case 'dyte-participants-viewer-list':
          return Promise.resolve().then(function () { return dyteParticipantsViewerList_entry; }).then(processMod, consoleError);
        case 'dyte-participants-waiting-list':
          return Promise.resolve().then(function () { return dyteParticipantsWaitingList_entry; }).then(processMod, consoleError);
        case 'dyte-permissions-message':
          return Promise.resolve().then(function () { return dytePermissionsMessage_entry; }).then(processMod, consoleError);
        case 'dyte-pip-toggle':
          return Promise.resolve().then(function () { return dytePipToggle_entry; }).then(processMod, consoleError);
        case 'dyte-plugin-main':
          return Promise.resolve().then(function () { return dytePluginMain_entry; }).then(processMod, consoleError);
        case 'dyte-plugins-toggle':
          return Promise.resolve().then(function () { return dytePluginsToggle_entry; }).then(processMod, consoleError);
        case 'dyte-polls-toggle':
          return Promise.resolve().then(function () { return dytePollsToggle_entry; }).then(processMod, consoleError);
        case 'dyte-recording-indicator':
          return Promise.resolve().then(function () { return dyteRecordingIndicator_entry; }).then(processMod, consoleError);
        case 'dyte-recording-toggle':
          return Promise.resolve().then(function () { return dyteRecordingToggle_entry; }).then(processMod, consoleError);
        case 'dyte-remote-access-manager':
          return Promise.resolve().then(function () { return dyteRemoteAccessManager_entry; }).then(processMod, consoleError);
        case 'dyte-screen-share-toggle':
          return Promise.resolve().then(function () { return dyteScreenShareToggle_entry; }).then(processMod, consoleError);
        case 'dyte-screenshare-view':
          return Promise.resolve().then(function () { return dyteScreenshareView_entry; }).then(processMod, consoleError);
        case 'dyte-settings':
          return Promise.resolve().then(function () { return dyteSettings_entry; }).then(processMod, consoleError);
        case 'dyte-settings-toggle':
          return Promise.resolve().then(function () { return dyteSettingsToggle_entry; }).then(processMod, consoleError);
        case 'dyte-setup-screen':
          return Promise.resolve().then(function () { return dyteSetupScreen_entry; }).then(processMod, consoleError);
        case 'dyte-sidebar':
          return Promise.resolve().then(function () { return dyteSidebar_entry; }).then(processMod, consoleError);
        case 'dyte-simple-grid':
          return Promise.resolve().then(function () { return dyteSimpleGrid_entry; }).then(processMod, consoleError);
        case 'dyte-spotlight-grid':
          return Promise.resolve().then(function () { return dyteSpotlightGrid_entry; }).then(processMod, consoleError);
        case 'dyte-stage':
          return Promise.resolve().then(function () { return dyteStage_entry; }).then(processMod, consoleError);
        case 'dyte-stage-toggle':
          return Promise.resolve().then(function () { return dyteStageToggle_entry; }).then(processMod, consoleError);
        case 'dyte-text-field':
          return Promise.resolve().then(function () { return dyteTextField_entry; }).then(processMod, consoleError);
        case 'dyte-ui-provider':
          return Promise.resolve().then(function () { return dyteUiProvider_entry; }).then(processMod, consoleError);
        case 'dyte-waiting-screen':
          return Promise.resolve().then(function () { return dyteWaitingScreen_entry; }).then(processMod, consoleError);
        case 'dyte-webinar-stage-toggle':
          return Promise.resolve().then(function () { return dyteWebinarStageToggle_entry; }).then(processMod, consoleError);
        case 'dyte-breakout-room-manager_3':
          return Promise.resolve().then(function () { return dyteBreakoutRoomManager_3_entry; }).then(processMod, consoleError);
        case 'dyte-chat_5':
          return Promise.resolve().then(function () { return dyteChat_5_entry; }).then(processMod, consoleError);
        case 'dyte-debugger-audio_3':
          return Promise.resolve().then(function () { return dyteDebuggerAudio_3_entry; }).then(processMod, consoleError);
        case 'dyte-livestream-indicator_3':
          return Promise.resolve().then(function () { return dyteLivestreamIndicator_3_entry; }).then(processMod, consoleError);
        case 'dyte-settings-audio_2':
          return Promise.resolve().then(function () { return dyteSettingsAudio_2_entry; }).then(processMod, consoleError);
        case 'dyte-tab-bar':
          return Promise.resolve().then(function () { return dyteTabBar_entry; }).then(processMod, consoleError);
        case 'dyte-audio-visualizer_2':
          return Promise.resolve().then(function () { return dyteAudioVisualizer_2_entry; }).then(processMod, consoleError);
        case 'dyte-channel-details_14':
          return Promise.resolve().then(function () { return dyteChannelDetails_14_entry; }).then(processMod, consoleError);
        case 'dyte-participant':
          return Promise.resolve().then(function () { return dyteParticipant_entry; }).then(processMod, consoleError);
        case 'dyte-participant-tile':
          return Promise.resolve().then(function () { return dyteParticipantTile_entry; }).then(processMod, consoleError);
        case 'dyte-poll_2':
          return Promise.resolve().then(function () { return dytePoll_2_entry; }).then(processMod, consoleError);
        case 'dyte-spotlight-indicator':
          return Promise.resolve().then(function () { return dyteSpotlightIndicator_entry; }).then(processMod, consoleError);
        case 'dyte-chat-message_5':
          return Promise.resolve().then(function () { return dyteChatMessage_5_entry; }).then(processMod, consoleError);
        case 'dyte-debugger-issues-ui_3':
          return Promise.resolve().then(function () { return dyteDebuggerIssuesUi_3_entry; }).then(processMod, consoleError);
        case 'dyte-dialog':
          return Promise.resolve().then(function () { return dyteDialog_entry; }).then(processMod, consoleError);
        case 'dyte-logo':
          return Promise.resolve().then(function () { return dyteLogo_entry; }).then(processMod, consoleError);
        case 'dyte-menu_3':
          return Promise.resolve().then(function () { return dyteMenu_3_entry; }).then(processMod, consoleError);
        case 'dyte-avatar':
          return Promise.resolve().then(function () { return dyteAvatar_entry; }).then(processMod, consoleError);
        case 'dyte-controlbar-button':
          return Promise.resolve().then(function () { return dyteControlbarButton_entry; }).then(processMod, consoleError);
        case 'dyte-tooltip':
          return Promise.resolve().then(function () { return dyteTooltip_entry; }).then(processMod, consoleError);
        case 'dyte-spinner':
          return Promise.resolve().then(function () { return dyteSpinner_entry; }).then(processMod, consoleError);
        case 'dyte-button':
          return Promise.resolve().then(function () { return dyteButton_entry; }).then(processMod, consoleError);
        case 'dyte-icon':
          return Promise.resolve().then(function () { return dyteIcon_entry; }).then(processMod, consoleError);
      }
    }
    return import(
    /* @vite-ignore */
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    `./${bundleId}.entry.js${''}`).then((importedModule) => {
        {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
const styles = /*@__PURE__*/ new Map();
const win = typeof window !== 'undefined' ? window : {};
const doc = win.document || { head: {} };
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (h) => h(),
    raf: (h) => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructableStylesheets = /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replaceSync === 'function';
        }
        catch (e) { }
        return false;
    })()
    ;
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const flush = () => {
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick =  (cb) => promiseResolve().then(cb);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

/*
 Stencil Client Patch Esm v2.20.0 | MIT Licensed | https://stenciljs.com
 */
const patchEsm = () => {
    return promiseResolve();
};

const defineCustomElements = (win, options) => {
  if (typeof window === 'undefined') return Promise.resolve();
  return patchEsm().then(() => {
  return bootstrapLazy(JSON.parse("[[\"dyte-sidebar\",[[1,\"dyte-sidebar\",{\"enabledSections\":[16],\"defaultSection\":[1,\"default-section\"],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"view\":[513],\"currentTab\":[32]}]]],[\"dyte-breakout-rooms-manager\",[[1,\"dyte-breakout-rooms-manager\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"loading\":[32],\"roomConfig\":[32],\"draftState\":[32],\"assigningParticipants\":[32],\"selectedParticipants\":[32],\"ephemeralStatusText\":[32],\"isDragMode\":[32]},[[0,\"participantDelete\",\"onParticipantDelete\"],[0,\"participantsDragging\",\"toggleDragMode\"],[0,\"selectedParticipantsUpdate\",\"updateSelectedParticipants\"],[0,\"allParticipantsToggleUpdate\",\"updateAllParticipants\"]]]]],[\"dyte-debugger\",[[1,\"dyte-debugger\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"isMobileMainVisible\":[32],\"progress\":[32]},[[0,\"testProgress\",\"progressUpdate\"]]]]],[\"dyte-participants-stage-list\",[[1,\"dyte-participants-stage-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"search\":[1],\"participants\":[32],\"showStageList\":[32]}]]],[\"dyte-participants-viewer-list\",[[1,\"dyte-participants-viewer-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"search\":[1],\"t\":[16],\"stageViewers\":[32]}]]],[\"dyte-settings\",[[1,\"dyte-settings\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"isMobileMainVisible\":[32],\"networkStatus\":[32],\"canProduceVideo\":[32]}]]],[\"dyte-grid\",[[1,\"dyte-grid\",{\"layout\":[513],\"aspectRatio\":[513,\"aspect-ratio\"],\"meeting\":[16],\"gap\":[514],\"size\":[513],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16],\"overrides\":[8],\"participants\":[32],\"pinnedParticipants\":[32],\"screenShareParticipants\":[32],\"plugins\":[32],\"showWebinarStage\":[32],\"showLiveStreamPlayer\":[32],\"canCurrentPeerHost\":[32],\"connected\":[32],\"pipSupported\":[32],\"pipEnabled\":[32]}]]],[\"dyte-screenshare-view\",[[1,\"dyte-screenshare-view\",{\"hideFullScreenButton\":[4,\"hide-full-screen-button\"],\"nameTagPosition\":[513,\"name-tag-position\"],\"participant\":[16],\"meeting\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoExpanded\":[32],\"screenShareEnabled\":[32],\"isFullScreen\":[32],\"remoteControlInfo\":[32]}]]],[\"dyte-mixed-grid\",[[1,\"dyte-mixed-grid\",{\"layout\":[513],\"participants\":[16],\"pinnedParticipants\":[16],\"screenShareParticipants\":[16],\"plugins\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16],\"activeTab\":[32],\"initialised\":[32]}]]],[\"dyte-participants-stage-queue\",[[1,\"dyte-participants-stage-queue\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"stageRequestedParticipants\":[32]}]]],[\"dyte-participants-waiting-list\",[[1,\"dyte-participants-waiting-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"waitlistedParticipants\":[32]}]]],[\"dyte-camera-toggle\",[[1,\"dyte-camera-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoEnabled\":[32],\"canProduceVideo\":[32],\"cameraPermission\":[32]}]]],[\"dyte-channel-creator\",[[1,\"dyte-channel-creator\",{\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"channelName\":[32],\"searchQuery\":[32],\"step\":[32],\"loading\":[32],\"selectedMemberIds\":[32],\"focusedMemberIndex\":[32],\"showAllMembersList\":[32]}]]],[\"dyte-mic-toggle\",[[1,\"dyte-mic-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"audioEnabled\":[32],\"canProduceAudio\":[32],\"micPermission\":[32]}]]],[\"dyte-mute-all-button\",[[1,\"dyte-mute-all-button\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-remote-access-manager\",[[1,\"dyte-remote-access-manager\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"acceptedRequestId\":[32]}]]],[\"dyte-screen-share-toggle\",[[1,\"dyte-screen-share-toggle\",{\"states\":[16],\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"maxScreenShareCount\":[32],\"screenShareCount\":[32],\"screenShareEnabled\":[32],\"canScreenShare\":[32],\"shareScreenPermission\":[32],\"screenShareState\":[32]}]]],[\"dyte-stage-toggle\",[[1,\"dyte-stage-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"stageStatus\":[32],\"state\":[32]}]]],[\"dyte-webinar-stage-toggle\",[[1,\"dyte-webinar-stage-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"stageStatus\":[32],\"canPresent\":[32],\"requestProduce\":[32]}]]],[\"dyte-ai-toggle\",[[1,\"dyte-ai-toggle\",{\"variant\":[513],\"states\":[16],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"middlewares\":[16],\"aiActive\":[32]}]]],[\"dyte-breakout-rooms-toggle\",[[1,\"dyte-breakout-rooms-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-chat-toggle\",[[1,\"dyte-chat-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"unreadMessageCount\":[32],\"chatActive\":[32],\"canViewChat\":[32],\"hasNewMessages\":[32]}]]],[\"dyte-debugger-toggle\",[[1,\"dyte-debugger-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"t\":[16],\"iconPack\":[16],\"size\":[513]}]]],[\"dyte-fullscreen-toggle\",[[1,\"dyte-fullscreen-toggle\",{\"states\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"fullScreenActive\":[32],\"isFullScreenSupported\":[32]}]]],[\"dyte-grid-pagination\",[[1,\"dyte-grid-pagination\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"variant\":[513],\"iconPack\":[16],\"t\":[16],\"page\":[32],\"pageCount\":[32],\"activeCount\":[32],\"activeComputedCount\":[32],\"showPagination\":[32]}]]],[\"dyte-idle-screen\",[[1,\"dyte-idle-screen\",{\"meeting\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-leave-button\",[[1,\"dyte-leave-button\",{\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-livestream-toggle\",[[1,\"dyte-livestream-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"livestreamState\":[32]}]]],[\"dyte-more-toggle\",[[1,\"dyte-more-toggle\",{\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-participants-audio\",[[1,\"dyte-participants-audio\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"showPlayDialog\":[32]}]]],[\"dyte-participants-toggle\",[[1,\"dyte-participants-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"participantsActive\":[32],\"waitlistedParticipants\":[32],\"stageRequestedParticipants\":[32],\"canViewParticipants\":[32]}]]],[\"dyte-pip-toggle\",[[1,\"dyte-pip-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"size\":[513],\"t\":[16],\"pipEnabled\":[32],\"pipSupported\":[32]}]]],[\"dyte-plugins-toggle\",[[1,\"dyte-plugins-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"pluginsActive\":[32],\"canViewPlugins\":[32]}]]],[\"dyte-polls-toggle\",[[1,\"dyte-polls-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"pollsActive\":[32],\"unreadPollsCount\":[32],\"canViewPolls\":[32]}]]],[\"dyte-recording-toggle\",[[1,\"dyte-recording-toggle\",{\"variant\":[513],\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"size\":[513],\"disabled\":[4],\"recordingState\":[32],\"canRecord\":[32]}]]],[\"dyte-settings-toggle\",[[1,\"dyte-settings-toggle\",{\"variant\":[513],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-setup-screen\",[[1,\"dyte-setup-screen\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"displayName\":[32],\"isJoining\":[32],\"canEditName\":[32]}]]],[\"dyte-ai\",[[1,\"dyte-ai\",{\"defaultSection\":[1,\"default-section\"],\"meeting\":[16],\"middlewares\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"view\":[513],\"tab\":[32],\"newTranscriptionAvailable\":[32],\"newAiMessageAvailable\":[32]}]]],[\"dyte-ai-home\",[[1,\"dyte-ai-home\",{\"meeting\":[16],\"initialMessages\":[16],\"middlewares\":[16],\"prompt\":[32],\"messages\":[32]}]]],[\"dyte-broadcast-message-modal\",[[1,\"dyte-broadcast-message-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"messagePayload\":[32],\"successMessage\":[32]}]]],[\"dyte-ended-screen\",[[1,\"dyte-ended-screen\",{\"config\":[16],\"size\":[513],\"states\":[16],\"t\":[16],\"iconPack\":[16],\"meeting\":[16],\"icon\":[32],\"message\":[32]}]]],[\"dyte-image-viewer\",[[1,\"dyte-image-viewer\",{\"image\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16]}]]],[\"dyte-permissions-message\",[[1,\"dyte-permissions-message\",{\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"states\":[16],\"device\":[32]}]]],[\"dyte-plugin-main\",[[1,\"dyte-plugin-main\",{\"meeting\":[16],\"plugin\":[16],\"iconPack\":[16],\"t\":[16],\"canClosePlugin\":[32],\"canControl\":[32],\"viewModeEnabled\":[32]}]]],[\"dyte-clock\",[[1,\"dyte-clock\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"startedTime\":[32],\"timeDiff\":[32]}]]],[\"dyte-confirmation-modal\",[[1,\"dyte-confirmation-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-leave-meeting\",[[1,\"dyte-leave-meeting\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"canEndMeeting\":[32]}]]],[\"dyte-meeting-title\",[[1,\"dyte-meeting-title\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-mute-all-confirmation\",[[1,\"dyte-mute-all-confirmation\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"allowUnmute\":[32]}]]],[\"dyte-network-indicator\",[[1,\"dyte-network-indicator\",{\"participant\":[16],\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"isScreenShare\":[4,\"is-screen-share\"],\"score\":[32]}]]],[\"dyte-participant-count\",[[1,\"dyte-participant-count\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"participantCount\":[32],\"isViewer\":[32]}]]],[\"dyte-participant-setup\",[[1,\"dyte-participant-setup\",{\"nameTagPosition\":[513,\"name-tag-position\"],\"isPreview\":[4,\"is-preview\"],\"participant\":[16],\"states\":[16],\"config\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoState\":[32],\"isPinned\":[32]}]]],[\"dyte-recording-indicator\",[[1,\"dyte-recording-indicator\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"isRecording\":[32]}]]],[\"dyte-waiting-screen\",[[1,\"dyte-waiting-screen\",{\"meeting\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-ai-chat\",[[1,\"dyte-ai-chat\",{\"t\":[16]}]]],[\"dyte-ai-transcriptions\",[[1,\"dyte-ai-transcriptions\",{\"t\":[16],\"meeting\":[16],\"initialTranscriptions\":[16],\"middlewares\":[16],\"participantQuery\":[32],\"isProcessing\":[32],\"captionViewEnabled\":[32],\"transcriptions\":[32]}]]],[\"dyte-controlbar\",[[1,\"dyte-controlbar\",{\"variant\":[513],\"disableRender\":[4,\"disable-render\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"middlewares\":[16],\"size\":[513]}]]],[\"dyte-debugger-network\",[[1,\"dyte-debugger-network\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"issueKey\":[32]}]]],[\"dyte-header\",[[1,\"dyte-header\",{\"variant\":[513],\"disableRender\":[4,\"disable-render\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513]}]]],[\"dyte-meeting\",[[1,\"dyte-meeting\",{\"loadConfigFromPreset\":[4,\"load-config-from-preset\"],\"applyDesignSystem\":[4,\"apply-design-system\"],\"mode\":[513],\"leaveOnUnmount\":[4,\"leave-on-unmount\"],\"meeting\":[16],\"showSetupScreen\":[1028,\"show-setup-screen\"],\"t\":[16],\"config\":[1040],\"iconPackUrl\":[513,\"icon-pack-url\"],\"size\":[1537],\"gridLayout\":[1,\"grid-layout\"],\"middlewares\":[16],\"states\":[32],\"newMeeting\":[32],\"iconPack\":[32]},[[0,\"dyteStateUpdate\",\"listenState\"]]]]],[\"dyte-name-tag\",[[1,\"dyte-name-tag\",{\"participant\":[16],\"meeting\":[16],\"size\":[513],\"maxLength\":[2,\"max-length\"],\"isScreenShare\":[4,\"is-screen-share\"],\"iconPack\":[16],\"t\":[16],\"length\":[32]}]]],[\"dyte-simple-grid\",[[1,\"dyte-simple-grid\",{\"participants\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"dimensions\":[32]}]]],[\"dyte-spotlight-grid\",[[1,\"dyte-spotlight-grid\",{\"layout\":[513],\"participants\":[16],\"pinnedParticipants\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16]}]]],[\"dyte-stage\",[[1,\"dyte-stage\",{\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-text-field\",[[1,\"dyte-text-field\",{\"type\":[1],\"placeholder\":[1],\"disabled\":[4],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-ui-provider\",[[4,\"dyte-ui-provider\",{\"meeting\":[16],\"size\":[1537],\"config\":[1040],\"t\":[16],\"iconPackUrl\":[513,\"icon-pack-url\"],\"loadConfigFromPreset\":[4,\"load-config-from-preset\"],\"applyDesignSystem\":[4,\"apply-design-system\"],\"joinRoom\":[4,\"join-room\"],\"isReady\":[32],\"iconPack\":[32]}]]],[\"dyte-button\",[[1,\"dyte-button\",{\"size\":[513],\"variant\":[513],\"kind\":[513],\"reverse\":[516],\"disabled\":[516],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-icon\",[[1,\"dyte-icon\",{\"icon\":[1],\"iconPack\":[16],\"t\":[16],\"size\":[513]}]]],[\"dyte-tab-bar\",[[1,\"dyte-tab-bar\",{\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"layout\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[16],\"tabs\":[16]}]]],[\"dyte-settings-audio_2\",[[1,\"dyte-settings-audio\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"audioDevices\":[32],\"speakerDevices\":[32],\"canProduceAudio\":[32]}],[1,\"dyte-settings-video\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoDevices\":[32],\"currentDevice\":[32],\"videoEnabled\":[32]}]]],[\"dyte-participant\",[[1,\"dyte-participant\",{\"meeting\":[16],\"view\":[1],\"participant\":[16],\"iconPack\":[16],\"t\":[16],\"audioEnabled\":[32],\"videoEnabled\":[32],\"isPinned\":[32],\"isOnStage\":[32],\"canDisableParticipantAudio\":[32],\"canDisableParticipantVideo\":[32],\"canKickParticipant\":[32],\"canPinParticipant\":[32],\"canAllowParticipantOnStage\":[32]}]]],[\"dyte-spotlight-indicator\",[[1,\"dyte-spotlight-indicator\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"canSpotlight\":[32],\"isSpotlighted\":[32]}]]],[\"dyte-participant-tile\",[[1,\"dyte-participant-tile\",{\"nameTagPosition\":[513,\"name-tag-position\"],\"isPreview\":[4,\"is-preview\"],\"participant\":[16],\"meeting\":[16],\"states\":[16],\"config\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoState\":[32],\"isPinned\":[32]}]]],[\"dyte-dialog\",[[1,\"dyte-dialog\",{\"hideCloseButton\":[4,\"hide-close-button\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"open\":[1540]}]]],[\"dyte-logo\",[[1,\"dyte-logo\",{\"logoUrl\":[1025,\"logo-url\"],\"config\":[16],\"meeting\":[16],\"t\":[16]}]]],[\"dyte-debugger-issues-ui_3\",[[1,\"dyte-debugger-permissions-ui\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"mediaType\":[1,\"media-type\"],\"issueKey\":[32],\"permission\":[32],\"devices\":[32]}],[1,\"dyte-debugger-issues-ui\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"mediaType\":[1,\"media-type\"],\"issueIndex\":[32],\"reported\":[32]}],[1,\"dyte-information-tooltip\",{\"iconPack\":[16]}]]],[\"dyte-debugger-audio_3\",[[1,\"dyte-debugger-audio\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"micMetadata\":[32],\"micPreview\":[32],\"speakerPreview\":[32],\"audioTrackStats\":[32],\"activeTab\":[32],\"stage\":[32],\"mediaPermission\":[32],\"speakerDevice\":[32],\"speakerTest\":[32]}],[1,\"dyte-debugger-screenshare\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"stage\":[32],\"mediaPermission\":[32],\"screenshareEnabled\":[32],\"audioTrackMetadata\":[32],\"videoTrackMetadata\":[32],\"screenshareTest\":[32],\"audioTrackStats\":[32],\"videoTrackStats\":[32]}],[1,\"dyte-debugger-video\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"stage\":[32],\"mediaPermission\":[32],\"videoPreview\":[32],\"videoMetadata\":[32],\"videoTrackStats\":[32]}]]],[\"dyte-tooltip\",[[1,\"dyte-tooltip\",{\"label\":[1],\"variant\":[513],\"disabled\":[516],\"open\":[516],\"kind\":[513],\"size\":[513],\"placement\":[1],\"delay\":[2],\"iconPack\":[16],\"t\":[16],\"isInFocus\":[32]}]]],[\"dyte-spinner\",[[1,\"dyte-spinner\",{\"iconPack\":[16],\"size\":[513],\"t\":[16]}]]],[\"dyte-breakout-room-manager_3\",[[1,\"dyte-breakout-room-manager\",{\"meeting\":[16],\"assigningParticipants\":[4,\"assigning-participants\"],\"mode\":[1],\"states\":[16],\"allowDelete\":[4,\"allow-delete\"],\"iconPack\":[16],\"t\":[16],\"isDragMode\":[4,\"is-drag-mode\"],\"room\":[16],\"defaultExpanded\":[4,\"default-expanded\"],\"editingTitleRoomId\":[32],\"newTitle\":[32],\"showExpandedCard\":[32],\"glowingCard\":[32]}],[1,\"dyte-breakout-room-participants\",{\"meeting\":[16],\"participantIds\":[16],\"iconPack\":[16],\"t\":[16],\"selectedParticipantIds\":[16],\"search\":[32],\"participantsToShow\":[32],\"isDragging\":[32]}],[1,\"dyte-counter\",{\"size\":[513],\"value\":[2],\"minValue\":[2,\"min-value\"],\"iconPack\":[16],\"t\":[16],\"input\":[32]}]]],[\"dyte-livestream-indicator_3\",[[1,\"dyte-livestream-player\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"playbackUrl\":[32],\"isSupported\":[32],\"playerState\":[32],\"livestreamState\":[32],\"playerError\":[32],\"latency\":[32],\"audioPlaybackError\":[32]}],[1,\"dyte-livestream-indicator\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"isLivestreaming\":[32]}],[1,\"dyte-viewer-count\",{\"meeting\":[16],\"variant\":[513],\"iconPack\":[16],\"t\":[16],\"viewerCount\":[32]}]]],[\"dyte-poll_2\",[[1,\"dyte-poll-form\",{\"iconPack\":[16],\"t\":[16],\"options\":[32],\"anonymous\":[32],\"hideVotes\":[32],\"error\":[32]}],[1,\"dyte-poll\",{\"poll\":[16],\"self\":[1],\"permissions\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-avatar\",[[1,\"dyte-avatar\",{\"participant\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"imageState\":[32]}]]],[\"dyte-controlbar-button\",[[1,\"dyte-controlbar-button\",{\"variant\":[513],\"showWarning\":[4,\"show-warning\"],\"size\":[513],\"label\":[1],\"icon\":[1],\"isLoading\":[4,\"is-loading\"],\"disabled\":[516],\"iconPack\":[16],\"t\":[16],\"brandIcon\":[516,\"brand-icon\"]}]]],[\"dyte-menu_3\",[[1,\"dyte-menu\",{\"size\":[513],\"placement\":[1],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-menu-item\",{\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-menu-list\",{\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-chat_5\",[[1,\"dyte-chat\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"disablePrivateChat\":[4,\"disable-private-chat\"],\"privatePresetFilter\":[16],\"unreadCountGroups\":[32],\"chatGroups\":[32],\"selectedGroup\":[32],\"now\":[32],\"dropzoneActivated\":[32],\"showLatestMessageButton\":[32],\"canSend\":[32],\"canSendTextMessage\":[32],\"canSendFiles\":[32],\"canPrivateMessage\":[32],\"canSendPrivateTexts\":[32],\"canSendPrivateFiles\":[32],\"emojiPickerEnabled\":[32],\"chatRecipientId\":[32],\"participants\":[32],\"selectedParticipant\":[32],\"channels\":[32],\"selectedChannelId\":[32],\"editingMessage\":[32],\"replyMessage\":[32],\"searchQuery\":[32],\"creatingChannel\":[32]},[[8,\"editMessageInit\",\"onEditMessageInit\"],[0,\"switchChannel\",\"channelSwitchListener\"]]],[1,\"dyte-polls\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"create\":[32],\"polls\":[32]}],[1,\"dyte-plugins\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"plugins\":[32],\"canStartPlugins\":[32],\"canClosePlugin\":[32],\"activatedPluginsId\":[32]}],[1,\"dyte-sidebar-ui\",{\"view\":[513],\"tabs\":[16],\"currentTab\":[1,\"current-tab\"],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-participants\",{\"meeting\":[16],\"states\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"search\":[32]}]]],[\"dyte-audio-visualizer_2\",[[1,\"dyte-audio-visualizer\",{\"variant\":[513],\"participant\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isScreenShare\":[4,\"is-screen-share\"],\"audioEnabled\":[32],\"volume\":[32]}],[1,\"dyte-switch\",{\"checked\":[1028],\"readonly\":[4],\"disabled\":[516],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-chat-message_5\",[[1,\"dyte-chat-message\",{\"message\":[16],\"isContinued\":[4,\"is-continued\"],\"isUnread\":[4,\"is-unread\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isSelf\":[4,\"is-self\"],\"canEdit\":[4,\"can-edit\"],\"canDelete\":[4,\"can-delete\"],\"canReply\":[4,\"can-reply\"],\"disableControls\":[4,\"disable-controls\"],\"alignRight\":[4,\"align-right\"],\"senderDisplayPicture\":[1,\"sender-display-picture\"],\"hideAvatar\":[4,\"hide-avatar\"],\"now\":[32]}],[1,\"dyte-paginated-list\",{\"pageSize\":[2,\"page-size\"],\"pagesAllowed\":[2,\"pages-allowed\"],\"fetchData\":[16],\"createNodes\":[16],\"selectedItemId\":[1,\"selected-item-id\"],\"autoScroll\":[4,\"auto-scroll\"],\"iconPack\":[16],\"t\":[16],\"emptyListLabel\":[1,\"empty-list-label\"],\"isLoading\":[32],\"rerenderBoolean\":[32],\"shouldRenderNewNodes\":[32],\"hasNewNodesToRender\":[32],\"showEmptyListLabel\":[32],\"onNewNode\":[64],\"onNodeDelete\":[64],\"onNodeUpdate\":[64]}],[0,\"dyte-image-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"],\"status\":[32]}],[0,\"dyte-file-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"]}],[0,\"dyte-text-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"]}]]],[\"dyte-channel-details_14\",[[1,\"dyte-chat-messages-ui-paginated\",{\"meeting\":[16],\"selectedChannel\":[16],\"selectedChannelId\":[1,\"selected-channel-id\"],\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-chat-search-results\",{\"meeting\":[16],\"query\":[1],\"channelId\":[1,\"channel-id\"],\"iconPack\":[16],\"t\":[16]}],[0,\"dyte-channel-header\",{\"meeting\":[16],\"channel\":[16],\"iconPack\":[16],\"t\":[16],\"showChannelDetailsDialog\":[32],\"showSearchBar\":[32],\"members\":[32]}],[1,\"dyte-chat-composer-ui\",{\"canSendTextMessage\":[4,\"can-send-text-message\"],\"canSendFiles\":[4,\"can-send-files\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"disableEmojiPicker\":[4,\"disable-emoji-picker\"],\"prefill\":[16],\"members\":[16],\"channelId\":[1,\"channel-id\"],\"emojiPickerActive\":[32],\"mentionQuery\":[32],\"focusedMemberIndex\":[32],\"filePreview\":[32]}],[1,\"dyte-chat-messages-ui\",{\"selectedGroup\":[1,\"selected-group\"],\"messages\":[16],\"selfUserId\":[1,\"self-user-id\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"now\":[32],\"showLatestMessageButton\":[32]}],[1,\"dyte-dialog-manager\",{\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-channel-selector-ui\",{\"channels\":[16],\"selectedChannelId\":[1,\"selected-channel-id\"],\"iconPack\":[16],\"t\":[16],\"showRecentMessage\":[4,\"show-recent-message\"],\"isHidden\":[32],\"searchQuery\":[32]}],[1,\"dyte-notifications\",{\"meeting\":[16],\"states\":[16],\"config\":[16],\"t\":[16],\"size\":[513],\"iconPack\":[16],\"notifications\":[32]},[[8,\"dyteAPIError\",\"apiErrorListener\"]]],[1,\"dyte-chat-selector-ui\",{\"selfUserId\":[1,\"self-user-id\"],\"selectedGroupId\":[1,\"selected-group-id\"],\"unreadCounts\":[16],\"groups\":[16],\"iconPack\":[16],\"t\":[16],\"showParticipantsPanel\":[32],\"query\":[32]}],[1,\"dyte-channel-details\",{\"channel\":[16],\"t\":[16],\"iconPack\":[16],\"members\":[16]}],[1,\"dyte-emoji-picker\",{\"iconPack\":[16],\"t\":[16],\"emojiList\":[32],\"filterVal\":[32],\"filteredEmojis\":[32]}],[1,\"dyte-notification\",{\"notification\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"imageState\":[32]}],[1,\"dyte-join-stage\",{\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"dataConfig\":[16]}],[1,\"dyte-overlay-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16]}]]]]"), options);
  });
};

/**
 * The default UI Config
 */
const defaultConfig = {
  designTokens: {
    spacingBase: 4,
    googleFont: 'Inter',
  },
  styles: {
    // 'dyte-meeting': {
    // NOTE(vaibhavshn): required for mobile devices with static positioning
    // not required for fixed position
    // height: '-webkit-fill-available',
    // },
    'dyte-header': {
      display: 'grid',
      height: '48px',
      gridTemplateColumns: 'repeat(3, 1fr)',
      gridTemplateRows: '1fr',
      alignItems: 'center',
    },
    'dyte-header.sm': {
      display: 'grid',
      gridArea: 'header',
      gridTemplateColumns: 'repeat(2, 1fr)',
      gridTemplateRows: '1fr',
      alignItems: 'center',
    },
    'div#header-left': {
      display: 'flex',
      alignItems: 'center',
      height: '48px',
      wordBreak: 'break-all',
    },
    'dyte-logo': {
      height: '26px',
    },
    'div#header-center': {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      wordBreak: 'break-all',
    },
    'div#header-right': {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    'dyte-stage': {
      display: 'flex',
      flex: '1',
    },
    'dyte-grid': {
      flex: '1',
      height: 'auto',
    },
    'dyte-controlbar': {
      display: 'grid',
      gridTemplateColumns: 'repeat(3,1fr)',
      gridTemplateRows: '1fr',
      alignItems: 'center',
      padding: '8px',
    },
    'dyte-controlbar.sm': {
      display: 'flex',
      position: 'relative',
      backgroundColor: 'rgb(var(--dyte-colors-background-1000, 0 0 0))',
    },
    'dyte-controlbar.md': {
      display: 'flex',
      position: 'relative',
      backgroundColor: 'rgb(var(--dyte-colors-background-1000, 0 0 0))',
    },
    'div#controlbar-left': {
      display: 'flex',
      alignItems: 'center',
    },
    'div#controlbar-center': {
      display: 'flex',
      alignItems: 'center',
      position: 'relative',
      overflow: 'visible',
      justifyContent: 'center',
    },
    'div#controlbar-mobile': {
      display: 'flex',
      flex: '1',
      alignItems: 'center',
      justifyContent: 'center',
    },
    'div#controlbar-right': {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'flex-end',
    },
    'dyte-settings': {
      width: '720px',
      height: '480px',
    },
    'dyte-debugger': {
      width: '720px',
      height: '480px',
    },
    'dyte-breakout-rooms-manager': {
      minHeight: '400px',
      minWidth: '500px',
      maxWidth: '80%',
      maxHeight: '480px',
    },
    'div#setupcontrols-media': {
      position: 'absolute',
      bottom: '8px',
      right: '8px',
      display: 'flex',
    },
    'div#setupcontrols-settings': {
      position: 'absolute',
      top: '8px',
      right: '8px',
    },
    'dyte-meeting-title.sm': {
      marginLeft: '0',
    },
    'dyte-clock': {
      marginRight: '0',
    },
  },
  root: {
    'dyte-meeting': {
      // if using key value pair, provide the key in `state`
      // else provide array of states in `states`
      state: 'meeting',
      states: ['activeSidebar', 'activeAI'],
    },
    'dyte-meeting[meeting=waiting]': ['dyte-waiting-screen'],
    'dyte-meeting[meeting=idle]': ['dyte-idle-screen'],
    'dyte-meeting[meeting=setup]': ['dyte-setup-screen', 'dyte-dialog-manager'],
    'dyte-meeting[meeting=joined]': [
      'dyte-header',
      'dyte-stage',
      'dyte-controlbar',
      'dyte-participants-audio',
      'dyte-dialog-manager',
    ],
    'dyte-meeting[meeting=joined].activeSidebar.sm': {
      add: [['dyte-sidebar', { view: 'full-screen' }]],
    },
    'dyte-meeting[meeting=joined].activeSidebar.md': {
      add: [['dyte-sidebar', { view: 'full-screen' }]],
    },
    'dyte-meeting[meeting=joined].activeAI.sm': {
      add: [['dyte-ai', { view: 'full-screen' }]],
    },
    'dyte-meeting[meeting=joined].activeAI.md': {
      add: [['dyte-ai', { view: 'full-screen' }]],
    },
    'dyte-meeting[meeting=ended]': ['dyte-ended-screen'],
    'dyte-header': ['div#header-left', 'div#header-center', 'div#header-right'],
    'dyte-header.sm': { remove: ['div#header-center'] },
    'div#header-left': ['dyte-logo', 'dyte-recording-indicator', 'dyte-livestream-indicator'],
    'div#header-center': ['dyte-meeting-title'],
    'div#header-right': [
      'dyte-grid-pagination',
      'dyte-clock',
      'dyte-participant-count',
      'dyte-viewer-count',
    ],
    'div#header-left.sm': [
      'dyte-meeting-title',
      'dyte-recording-indicator',
      'dyte-livestream-indicator',
    ],
    'dyte-stage': {
      states: ['activeSidebar', 'activeAI'],
      children: ['dyte-grid', 'dyte-notifications'],
    },
    'dyte-stage.activeSidebar': {
      add: [['dyte-sidebar', { view: 'sidebar' }]],
    },
    // hide sidebar for smaller screens
    'dyte-stage.activeSidebar.sm': { remove: ['dyte-sidebar'] },
    'dyte-stage.activeAI': {
      add: [['dyte-ai', { view: 'sidebar' }]],
    },
    // hide sidebar for smaller screens
    'dyte-stage.activeAI.sm': { remove: ['dyte-ai'] },
    'dyte-grid': {
      states: ['activeScreenShare', 'activePlugin', 'activeSpotlight'],
      children: ['dyte-simple-grid'],
    },
    'dyte-grid.activeSpotlight': ['dyte-spotlight-grid'],
    'dyte-grid.activeScreenShare': ['dyte-mixed-grid'],
    'dyte-grid.activePlugin': ['dyte-mixed-grid'],
    'dyte-grid.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'],
    'dyte-grid.activePlugin.activeSpotlight': ['dyte-mixed-grid'],
    'dyte-grid.activePlugin.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'],
    'dyte-mixed-grid': {
      states: ['activeSpotlight'],
      children: ['dyte-simple-grid'],
    },
    'dyte-mixed-grid.activeSpotlight': ['dyte-spotlight-grid'],
    'dyte-participant-tile': {
      state: 'meeting',
      children: ['dyte-name-tag', 'dyte-avatar', 'dyte-network-indicator'],
    },
    'dyte-participant-setup': ['dyte-avatar', 'div#setupcontrols-media'],
    'dyte-participant-tile[meeting=setup]': [
      'dyte-avatar',
      'div#setupcontrols-settings',
      'div#setupcontrols-media',
    ],
    'div#setupcontrols-media': [
      ['dyte-mic-toggle', { size: 'sm' }],
      ['dyte-camera-toggle', { size: 'sm' }],
    ],
    'div#setupcontrols-settings': [['dyte-settings-toggle', { size: 'sm' }]],
    'dyte-screenshare-view': {
      children: ['dyte-name-tag', 'dyte-network-indicator'],
    },
    'dyte-name-tag': [['dyte-audio-visualizer', { slot: 'start' }]],
    'dyte-controlbar': {
      states: ['activeMoreMenu'],
      props: {
        variant: 'solid',
      },
      children: ['div#controlbar-left', 'div#controlbar-center', 'div#controlbar-right'],
    },
    'dyte-more-toggle': {
      states: ['activeMoreMenu'],
      children: [],
    },
    'dyte-controlbar.sm': ['div#controlbar-mobile'],
    'dyte-controlbar.md': ['div#controlbar-mobile'],
    'dyte-more-toggle.activeMoreMenu': [
      ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-recording-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-debugger-toggle', { variant: 'horizontal' }],
    ],
    'dyte-more-toggle.activeMoreMenu.sm': [
      ['dyte-chat-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-participants-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-polls-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-plugins-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-screen-share-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-settings-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-ai-toggle', { variant: 'horizontal' }],
      ['dyte-debugger-toggle', { variant: 'horizontal' }],
    ],
    'dyte-more-toggle.activeMoreMenu.md': [
      ['dyte-chat-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-participants-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-polls-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-plugins-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-screen-share-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-settings-toggle', { variant: 'horizontal', slot: 'more-elements' }],
      ['dyte-ai-toggle', { variant: 'horizontal' }],
      ['dyte-debugger-toggle', { variant: 'horizontal' }],
    ],
    'div#controlbar-mobile': [
      'dyte-mic-toggle',
      'dyte-camera-toggle',
      'dyte-webinar-stage-toggle',
      'dyte-stage-toggle',
      'dyte-leave-button',
      'dyte-more-toggle',
    ],
    'div#controlbar-left': [
      'dyte-settings-toggle',
      'dyte-screen-share-toggle',
      'dyte-livestream-toggle',
    ],
    'div#controlbar-center': [
      'dyte-mic-toggle',
      'dyte-camera-toggle',
      'dyte-webinar-stage-toggle',
      'dyte-stage-toggle',
      'dyte-more-toggle',
      'dyte-leave-button',
    ],
    'div#controlbar-right': [
      'dyte-chat-toggle',
      'dyte-polls-toggle',
      'dyte-participants-toggle',
      'dyte-plugins-toggle',
      'dyte-ai-toggle',
    ],
  },
  config: {
    notification_sounds: {
      participant_left: false,
    },
    participant_joined_sound_notification_limit: 10,
    participant_chat_message_sound_notification_limit: 10,
    videoFit: 'cover',
  },
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used for built-in method references. */
var objectProto$1$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$1$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$9.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

const PIP_CANVAS_HEIGHT = 720;
const PIP_CANVAS_WIDTH = 1280;
const PIP_CANVAS_FILL = '#000000';
const calcGridElemSize = (gridSize) => {
  switch (gridSize) {
    case 0:
    case 1:
      return [PIP_CANVAS_WIDTH, PIP_CANVAS_HEIGHT];
    case 2:
      return [Math.floor(PIP_CANVAS_WIDTH / 2), PIP_CANVAS_HEIGHT];
    case 3:
    case 4:
      return [Math.floor(PIP_CANVAS_WIDTH / 2), Math.floor(PIP_CANVAS_HEIGHT / 2)];
    case 5:
    case 6:
      return [Math.floor(PIP_CANVAS_WIDTH / 3), Math.floor(PIP_CANVAS_HEIGHT / 2)];
    default:
      return [Math.floor(PIP_CANVAS_WIDTH / 3), Math.floor(PIP_CANVAS_HEIGHT / 2)];
  }
};
const calcImageCrop = (x, y, w, h, videoW, videoH) => {
  // default offset is center
  let offsetX = 0.5;
  let offsetY = 0.5;
  const iw = videoW;
  const ih = videoH;
  const r = Math.min(w / iw, h / ih);
  let nw = iw * r; // new prop. width
  let nh = ih * r; // new prop. height
  let cx;
  let cy;
  let cw;
  let ch;
  let ar = 1;
  // decide which gap to fill
  if (nw < w)
    ar = w / nw;
  if (Math.abs(ar - 1) < 1e-14 && nh < h)
    ar = h / nh; // updated
  nw *= ar;
  nh *= ar;
  // calc source rectangle
  cw = iw / (nw / w);
  ch = ih / (nh / h);
  cx = (iw - cw) * offsetX;
  cy = (ih - ch) * offsetY;
  // make sure source rectangle is valid
  if (cx < 0)
    cx = 0;
  if (cy < 0)
    cy = 0;
  if (cw > iw)
    cw = iw;
  if (ch > ih)
    ch = ih;
  // fill image in dest. rectangle
  return [cx, cy, cw, ch, x, y, w, h];
};
var PiPEvents;
(function (PiPEvents) {
  PiPEvents["CAMERA"] = "CAMERA";
  PiPEvents["MIC"] = "MIC";
  PiPEvents["END"] = "END";
})(PiPEvents || (PiPEvents = {}));
class PipStore {
  constructor() {
    this.tracks = [];
    this.sources = [];
    this.enabled = false;
  }
  isSupported() {
    return !!window.chrome && document.pictureInPictureEnabled;
  }
  cleanup() {
    if (this.isSupported() &&
      document.exitPictureInPicture !== undefined &&
      document.pictureInPictureElement !== null) {
      document.exitPictureInPicture();
    }
    this.canvas = undefined;
    this.video = undefined;
    this.tracks = [];
    this.request = undefined;
  }
  createCanvas() {
    const c = document.createElement('canvas');
    c.height = PIP_CANVAS_HEIGHT;
    c.width = PIP_CANVAS_WIDTH;
    this.canvas = c;
  }
  setupEvents(onEvent) {
    if (navigator.mediaSession === undefined ||
      navigator.mediaSession.setCameraActive === undefined) {
      return;
    }
    navigator.mediaSession.setActionHandler('hangup', () => {
      onEvent(PiPEvents.END);
    });
  }
  mountAudioEvents(onEvent) {
    if (navigator.mediaSession === undefined ||
      navigator.mediaSession.setCameraActive === undefined) {
      return;
    }
    navigator.mediaSession.setActionHandler('togglemicrophone', () => {
      onEvent(PiPEvents.MIC);
    });
  }
  mountVideoEvents(onEvent) {
    if (navigator.mediaSession === undefined ||
      navigator.mediaSession.setCameraActive === undefined) {
      return;
    }
    navigator.mediaSession.setActionHandler('togglecamera', () => {
      onEvent(PiPEvents.CAMERA);
    });
  }
  unmountAudioEvents() {
    if (navigator.mediaSession === undefined ||
      navigator.mediaSession.setCameraActive === undefined) {
      return;
    }
    navigator.mediaSession.setActionHandler('togglemicrophone', undefined);
  }
  unmountVideoEvents() {
    if (navigator.mediaSession === undefined ||
      navigator.mediaSession.setCameraActive === undefined) {
      return;
    }
    navigator.mediaSession.setActionHandler('togglecamera', undefined);
  }
  drawGrid(gridW, gridH, gridSize) {
    if (this.canvas === undefined)
      return;
    const ctx = this.canvas.getContext('2d');
    // Reset the canvas
    ctx.fillStyle = PIP_CANVAS_FILL;
    ctx.fillRect(0, 0, PIP_CANVAS_WIDTH, PIP_CANVAS_HEIGHT);
    let pointerY = 0;
    let i = 0;
    while (pointerY < PIP_CANVAS_HEIGHT - 5) {
      let pointerX = 0;
      while (pointerX < PIP_CANVAS_WIDTH - 5 && i < gridSize) {
        const videoElem = this.tracks[i];
        const [cx, cy, cw, ch, x, y, w, h] = calcImageCrop(pointerX, pointerY, gridW, gridH, videoElem.videoWidth, videoElem.videoHeight);
        ctx.drawImage(videoElem, cx, cy, cw, ch, x, y, w, h);
        i += 1;
        pointerX += gridW;
      }
      pointerY += gridH;
    }
  }
  paintCanvas() {
    const gridSize = this.tracks.length;
    const [gridW, gridH] = calcGridElemSize(gridSize);
    this.drawGrid(gridW, gridH, gridSize);
  }
  animate() {
    if (this.tracks !== undefined) {
      this.paintCanvas();
    }
    if (this.request !== undefined) {
      this.request = requestAnimationFrame(() => this.animate());
    }
  }
  /**
   * Create a PiP store and prepare sources
   * @param onReady method to trigger when video stream is ready
   * @param onStop method to trigger when PiP is stopped
   * @param onEvent method to trigger on PiP media session
   */
  create(onReady, onStop, onEvent) {
    this.cleanup();
    this.createCanvas();
    this.setupEvents(onEvent);
    const target = document.createElement('video');
    target.height = PIP_CANVAS_HEIGHT;
    target.width = PIP_CANVAS_WIDTH;
    target.autoplay = true;
    target.srcObject = this.canvas.captureStream(24);
    this.video = target;
    this.video.onloadedmetadata = () => {
      try {
        onReady();
        this.video.onleavepictureinpicture = () => {
          onStop();
        };
      }
      catch (err) {
        onStop(err.getMessage());
      }
    };
    this.paintCanvas();
  }
  updateMediaSession(event, state) {
    if (navigator.mediaSession === undefined)
      return;
    if (event === PiPEvents.CAMERA &&
      navigator.mediaSession.setCameraActive !== undefined) {
      navigator.mediaSession.setCameraActive(state);
    }
    if (event === PiPEvents.MIC &&
      navigator.mediaSession.setMicrophoneActive !== undefined) {
      navigator.mediaSession.setMicrophoneActive(state);
    }
  }
  /**
   * Update the active streams to show on grid
   * @param sources list of participants to show on grid
   */
  updateVideoSources() {
    const enabledSources = Object.values(this.sources).filter((t) => t.enabled);
    const tracks = [];
    enabledSources.map((sou) => {
      tracks.push(sou.element);
    });
    this.tracks = tracks;
  }
  enableSource(source) {
    if (this.sources[source] !== undefined) {
      this.sources[source].enabled = true;
    }
    this.updateVideoSources();
  }
  disableSource(source) {
    if (this.sources[source] !== undefined) {
      this.sources[source].enabled = false;
    }
    this.updateVideoSources();
  }
  /**
   * Add a video source from the participant grid
   * @param id participant id to store the video against
   * @param element HTMLVideoElement for the video source
   */
  addSource(id, element, enabled) {
    this.sources[id] = { element, enabled };
  }
  /**
   * Remove the video source for the participant
   * @param id participant id
   */
  removeSource(id) {
    delete this.sources[id];
  }
  /**
   * Remove all sources
   */
  removeAllSource() {
    this.sources = [];
  }
  /**
   * Enable PiP
   */
  enable() {
    this.enabled = true;
    // Repaint canvas in loop
    this.request = requestAnimationFrame(() => this.animate());
    this.video.requestPictureInPicture();
  }
  /**
   * Enable PiP
   */
  disable() {
    this.enabled = false;
    cancelAnimationFrame(this.request);
    this.request = undefined;
    document.exitPictureInPicture();
  }
}
const store = new PipStore();

/**
 * Can view the livestream
 */
const isLiveStreamViewer = (meeting) => {
  if (!showLivestream(meeting))
    return false;
  return meeting.meta.viewType === 'LIVESTREAM' && meeting.stage.status !== 'ON_STAGE';
};
/**
 * Can start/stop the livestream
 */
const isLiveStreamHost = (meeting) => {
  var _a;
  if (!showLivestream(meeting))
    return false;
  return meeting.meta.viewType === 'LIVESTREAM' && ((_a = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _a === void 0 ? void 0 : _a.permissions.canLivestream);
};
const showLivestream = (meeting) => {
  var _a;
  return ((_a = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _a === void 0 ? void 0 : _a.permissions.isV2) && (meeting === null || meeting === void 0 ? void 0 : meeting.livestream);
};
var PlayerState;
(function (PlayerState) {
  PlayerState["BUFFERING"] = "Buffering";
  PlayerState["ENDED"] = "Ended";
  PlayerState["IDLE"] = "Idle";
  PlayerState["PLAYING"] = "Playing";
  PlayerState["READY"] = "Ready";
})(PlayerState || (PlayerState = {}));
var PlayerEventType;
(function (PlayerEventType) {
  PlayerEventType["INITIALIZED"] = "PlayerInitialized";
  PlayerEventType["QUALITY_CHANGED"] = "PlayerQualityChanged";
  PlayerEventType["DURATION_CHANGED"] = "PlayerDurationChanged";
  PlayerEventType["VOLUME_CHANGED"] = "PlayerVolumeChanged";
  PlayerEventType["MUTED_CHANGED"] = "PlayerMutedChanged";
  PlayerEventType["PLAYBACK_RATE_CHANGED"] = "PlayerPlaybackRateChanged";
  PlayerEventType["REBUFFERING"] = "PlayerRebuffering";
  PlayerEventType["AUDIO_BLOCKED"] = "PlayerAudioBlocked";
  PlayerEventType["PLAYBACK_BLOCKED"] = "PlayerPlaybackBlocked";
  PlayerEventType["ERROR"] = "PlayerError";
  PlayerEventType["RECOVERABLE_ERROR"] = "PlayerRecoverableError";
  PlayerEventType["ANALYTICS_EVENT"] = "PlayerAnalyticsEvent";
  PlayerEventType["TIME_UPDATE"] = "PlayerTimeUpdate";
  PlayerEventType["BUFFER_UPDATE"] = "PlayerBufferUpdate";
  PlayerEventType["SEEK_COMPLETED"] = "PlayerSeekCompleted";
  PlayerEventType["SESSION_DATA"] = "PlayerSessionData";
  PlayerEventType["STATE_CHANGED"] = "PlayerStateChanged";
  PlayerEventType["WORKER_ERROR"] = "PlayerWorkerError";
  PlayerEventType["METADATA"] = "PlayerMetadata";
  PlayerEventType["TEXT_CUE"] = "PlayerTextCue";
  PlayerEventType["TEXT_METADATA_CUE"] = "PlayerTextMetadataCue";
  PlayerEventType["AD_CUE"] = "PlayerAdCue";
  PlayerEventType["STREAM_SOURCE_CUE"] = "PlayerStreamSourceCue";
  PlayerEventType["NETWORK_UNAVAILABLE"] = "PlayerNetworkUnavailable";
  PlayerEventType["SEGMENT_DISCONTINUITY"] = "PlayerSegmentDiscontinuity";
  PlayerEventType["SEGMENT_METADATA"] = "PlayerSegmentMetadata";
  PlayerEventType["PLAYER_METADATA"] = "PlayerMetadata";
})(PlayerEventType || (PlayerEventType = {}));
/**
 * NOTE(callmetarush): For some reason PlayerMetadata is not in type but spams events like crazy
 */
const awsIvsPlayerEventsToIgnore = [
  PlayerEventType.TIME_UPDATE,
  PlayerEventType.BUFFER_UPDATE,
  PlayerEventType.TEXT_METADATA_CUE,
  PlayerEventType.PLAYER_METADATA,
];
const isIvsPlayerCallStatsEvent = [
  // CallStats Major Events
  PlayerEventType.REBUFFERING,
  PlayerEventType.AUDIO_BLOCKED,
  PlayerEventType.PLAYBACK_BLOCKED,
  PlayerEventType.ERROR,
  PlayerEventType.RECOVERABLE_ERROR,
  PlayerEventType.WORKER_ERROR,
  // According to docs it says:
  // "Indicates that a playback unavailable event occurred."
  //
  // So I am taking a guess this can occcur
  // even when a viewer is online
  PlayerEventType.NETWORK_UNAVAILABLE,
  // CallStats Minor Events
  PlayerEventType.ANALYTICS_EVENT,
  PlayerEventType.PLAYBACK_RATE_CHANGED,
  PlayerEventType.QUALITY_CHANGED,
  PlayerEventType.INITIALIZED, // no payload
];
// TODO: (ishita1805): Move to stage.ts helpers when webinar is moved to `meeting.stage`
const canJoinStage = (meeting) => {
  var _a, _b, _c, _d, _e, _f;
  if (!showLivestream(meeting))
    return false;
  return (((_b = (_a = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.canProduceAudio) === 'ALLOWED' ||
    ((_d = (_c = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _c === void 0 ? void 0 : _c.permissions) === null || _d === void 0 ? void 0 : _d.canProduceScreenshare) === 'ALLOWED' ||
    ((_f = (_e = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _e === void 0 ? void 0 : _e.permissions) === null || _f === void 0 ? void 0 : _f.canProduceVideo) === 'ALLOWED');
};
const canRequestToJoinStage = (meeting) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (!showLivestream(meeting))
    return false;
  return (((_b = (_a = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.canProduceAudio) !== 'NOT_ALLOWED' ||
    ((_d = (_c = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _c === void 0 ? void 0 : _c.permissions) === null || _d === void 0 ? void 0 : _d.canProduceScreenshare) !== 'NOT_ALLOWED' ||
    ((_f = (_e = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _e === void 0 ? void 0 : _e.permissions) === null || _f === void 0 ? void 0 : _f.canProduceVideo) !== 'NOT_ALLOWED' ||
    ((_h = (_g = meeting === null || meeting === void 0 ? void 0 : meeting.self) === null || _g === void 0 ? void 0 : _g.permissions) === null || _h === void 0 ? void 0 : _h.canLivestream));
};

const FlagsmithFeatureFlags = {
  PLAY_PARTICIPANT_TILE_VIDEO_ON_PAUSE: 'play_participant_tile_video_on_pause',
  DISABLE_EMOJI_PICKER: 'disable_emoji_picker',
  FEAT_PAGINATED_CHAT: 'feat_paginated_chat',
  LOG_PLAYING_FAILURES: 'log_playing_failures',
  FEAT_CHANNEL_CHAT: 'feat_channel_chat',
};
const isBreakoutRoomsEnabled = (meeting) => meeting.connectedMeetings.supportsConnectedMeetings;
const usePaginatedChat = (meeting) => {
  var _a;
  return (meeting === null || meeting === void 0 ? void 0 : meeting.meta.viewType) === 'CHAT' ||
    showLivestream(meeting) ||
    ((_a = meeting === null || meeting === void 0 ? void 0 : meeting.__internals__) === null || _a === void 0 ? void 0 : _a.features.hasFeature('feat_paginated_chat'));
};

let roomCount = 0;
function getNextRoomNumber() {
  return ++roomCount;
}
function resetRoomCount() {
  roomCount = 0;
}
const TEMP_ROOM_PREFIX = 'temp-';
function createDraftRoom() {
  return {
    id: `${TEMP_ROOM_PREFIX}${Math.random().toString(36)}`,
    title: `Room ${getNextRoomNumber()}`,
    participants: [],
  };
}
function isDraftRoom(roomId) {
  return roomId.includes(TEMP_ROOM_PREFIX);
}
function splitCollection(collection, parts) {
  const length = collection.length;
  const size = Math.ceil(length / parts);
  const result = new Array(parts);
  let start = 0;
  for (let i = 0; i < parts; i++) {
    result[i] = collection.slice(start, start + size);
    start += size;
  }
  return result.filter((res) => res.length);
}
function participantIdentifier(participant) {
  var _a;
  return (_a = participant.customParticipantId) !== null && _a !== void 0 ? _a : participant.clientSpecificId;
}
function getAllConnectedParticipants(meeting) {
  // TODO: remove this once we start getting display pics from socket
  const map = new Map();
  [meeting.self, ...meeting.participants.joined.toArray()].map((participant) => {
    map.set(participantIdentifier(participant), participant.picture);
  });
  return [meeting.connectedMeetings.parentMeeting, ...meeting.connectedMeetings.meetings]
    .flatMap((meeting) => meeting.participants)
    .map((connectedPeer) => {
    return {
      id: connectedPeer.id,
      customParticipantId: participantIdentifier(connectedPeer),
      displayName: connectedPeer.displayName,
      displayPictureUrl: connectedPeer.displayPictureUrl !== ''
        ? connectedPeer.displayPictureUrl
        : map.get(participantIdentifier(connectedPeer)),
    };
  });
}
const canToggleBreakout = (meeting) => {
  const permissions = meeting.self.permissions.connectedMeetings;
  if (!permissions.canAlterConnectedMeetings && !meeting.connectedMeetings.isActive)
    return false;
  if (!permissions.canSwitchConnectedMeetings && !permissions.canSwitchToParentMeeting)
    return false;
  if (!isBreakoutRoomsEnabled(meeting))
    return false;
  return true;
};

const spacingScale = [
  0,
  0.5,
  1,
  1.5,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  52,
  56,
  60,
  64,
  72,
  80,
  96
];

const THEMES = {
  darkest: {
    background: {
      1000: '#080808',
      900: '#1A1A1A',
      800: '#1E1E1E',
      700: '#2C2C2C',
      600: '#393939',
    },
    text: '#FFFFFF',
  },
  dark: {
    background: {
      1000: '#252525',
      900: '#2F2F2F',
      800: '#323232',
      700: '#3E3E3E',
      600: '#4A4A4A',
    },
    text: '#F5F5F5',
    'video-bg': '#1C1C1C',
  },
  light: {
    background: {
      1000: '#FFFFFF',
      900: '#F5F5F5',
      800: '#EBEBEB',
      700: '#E0E0E0',
      600: '#D6D6D6',
    },
    text: '#111111',
    'text-on-brand': '#ffffff',
    'video-bg': '#DADADA',
  },
};

const BORDER_WIDTHS = {
  none: {
    none: 0,
    sm: 0,
    md: 0,
    lg: 0,
  },
  thin: {
    none: 0,
    sm: 1,
    md: 2,
    lg: 4,
  },
  fat: {
    none: 0,
    sm: 2,
    md: 4,
    lg: 8,
  },
};
const BORDER_RADII = {
  sharp: {
    none: 0,
    sm: 0,
    md: 0,
    lg: 0,
  },
  rounded: {
    none: 0,
    sm: 4,
    md: 8,
    lg: 12,
  },
  'extra-rounded': {
    none: 0,
    sm: 8,
    md: 16,
    lg: 24,
  },
  circular: {
    none: 9999,
    sm: 9999,
    md: 9999,
    lg: 9999,
  },
};

const BRAND_SHADE_REDUCER = [-2, -1, 0, 1, 2];
function hexToRGB(h) {
  h = h.trim();
  let r = '0', g = '0', b = '0';
  if (h.length == 4) {
    r = '0x' + h[1] + h[1];
    g = '0x' + h[2] + h[2];
    b = '0x' + h[3] + h[3];
  }
  else if (h.length > 6) {
    r = '0x' + h[1] + h[2];
    g = '0x' + h[3] + h[4];
    b = '0x' + h[5] + h[6];
  }
  return [+r, +g, +b];
}
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   {number}  h       The hue
 * @param   {number}  s       The saturation
 * @param   {number}  l       The lightness
 * @returns {Array}           The RGB representation
 */
const hslToRgb = (h, s, l) => {
  let r, g, b;
  if (s == 0) {
    r = g = b = l; // achromatic
  }
  else {
    const hue2rgb = (p, q, t) => {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @returns {Array}           The HSL representation
 */
const rgbToHsl = (r, g, b) => {
  (r /= 255), (g /= 255), (b /= 255);
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  }
  else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
};
const rgbToHex = (r, g, b) => {
  const hex = (n) => n.toString(16).padStart(2, '0');
  return `#${hex(r)}${hex(g)}${hex(b)}`;
};
/**
 * Generate shades from a single base hex color code.
 *
 * `weight` is contained in the set [0, 1].
 *
 * @param   {string} baseHexCode The base hex code to use to generate the other shades
 * @param   {number} weight The weight applied when calculating each shade.
 * @param   {number[]} reducer The reducer array which tells how to calculate the shades
 * @returns {string[]} The generated hex shades
 */
const generateShades = (baseHexCode, reducer = BRAND_SHADE_REDUCER, weight = 0.4) => {
  const shades = [];
  const [r, g, b] = hexToRGB(baseHexCode);
  const [h, s, l] = rgbToHsl(r, g, b);
  const lightness = Math.round(l * 100);
  if (lightness > 70) {
    // increase quotient for light base shade
    weight = 0.8;
  }
  else if (lightness > 60) {
    weight = 0.9;
  }
  else if (lightness < 10) {
    // reduce quorient for dark base shade
    weight = 0.075;
  }
  else if (lightness < 42) {
    weight = 0.3;
  }
  const basePosition = reducer.findIndex((val) => val === 0);
  if (basePosition === -1) {
    throw new Error('Invalid reducer provided, it must contain atleast one zero');
  }
  const lightShades = 5 - basePosition;
  const darkShades = basePosition + 1;
  const lightShadeIncrement = (100 - lightness) / lightShades;
  const darkShadeIncrement = lightness / darkShades;
  for (const val of reducer) {
    let shadeLightness;
    if (val < 0) {
      shadeLightness = lightness + val * darkShadeIncrement * weight;
    }
    else if (val > 0) {
      shadeLightness = lightness + val * lightShadeIncrement * weight;
    }
    else {
      shadeLightness = lightness;
    }
    const [r, g, b] = hslToRgb(h, s, shadeLightness / 100);
    shades.push(rgbToHex(r, g, b));
  }
  return shades;
};
const isValidHexColor = (color) => {
  return typeof color === 'string' && color.length === 7 && color.startsWith('#');
};
const getBrandColors = (shade) => {
  const [s300, s400, s500, s600, s700] = generateShades(shade, BRAND_SHADE_REDUCER);
  return { 300: s300, 400: s400, 500: s500, 600: s600, 700: s700 };
};
/**
 * Generates new background colors which are compatible with older preset color values
 * @param shade The hex color code
 * @returns Background color tokens
 */
const getBackgroundColorsOld = (shade) => {
  const [s1000, s900, s800, s700, s600] = generateShades(shade, BRAND_SHADE_REDUCER);
  return { 1000: s1000, 900: s900, 800: s800, 700: s700, 600: s600 };
};

const provideGoogleFont = (fontFamily) => {
  const weights = [400, 500, 700];
  const links = [];
  if (document.querySelector('link[data-dyte-font]') == null) {
    /**
     * Adds the following preconnect link tags for faster google font loading
     * <link rel="preconnect" href="https://fonts.googleapis.com">
     * <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     */
    const p1 = document.createElement('link');
    p1.rel = 'preconnect';
    p1.setAttribute('data-dyte-font', 'true');
    p1.href = 'https://fonts.googleapis.com';
    const p2 = p1.cloneNode(true);
    p2.href = 'https://fonts.gstatic.com';
    p2.crossOrigin = '';
    links.push(p1, p2);
  }
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.setAttribute('data-dyte-font', fontFamily);
  link.href = encodeURI(`https://fonts.googleapis.com/css2?family=${fontFamily}:wght@${weights.join(';')}&display=swap`);
  links.push(link);
  document.head.append(...links);
};
const provideSpacing = (el, spacingBase) => {
  spacingScale.forEach((space) => {
    el.style.setProperty(`--dyte-space-${space}`, `${space * spacingBase}px`);
  });
};
const provideBorderWidth = (el, borderWidth) => {
  if (borderWidth in BORDER_WIDTHS) {
    const widths = BORDER_WIDTHS[borderWidth];
    Object.keys(widths).forEach((type) => {
      el.style.setProperty(`--dyte-border-width-${type}`, `${widths[type]}px`);
    });
  }
};
const provideBorderRadius = (el, borderRadius) => {
  if (borderRadius in BORDER_RADII) {
    const radii = BORDER_RADII[borderRadius];
    Object.keys(radii).forEach((type) => {
      el.style.setProperty(`--dyte-border-radius-${type}`, `${radii[type]}px`);
    });
  }
};
const provideColors = (el, colors) => {
  Object.keys(colors).forEach((color) => {
    const colorValue = colors[color];
    if (typeof colorValue === 'string') {
      if (color === 'text' || color === 'text-on-brand') {
        const rgb = hexToRGB(colorValue).join(' ');
        el.style.setProperty(`--dyte-colors-${color}-1000`, `${rgb}`);
        el.style.setProperty(`--dyte-colors-${color}-900`, `${rgb} / 0.88`);
        el.style.setProperty(`--dyte-colors-${color}-800`, `${rgb} / 0.76`);
        el.style.setProperty(`--dyte-colors-${color}-700`, `${rgb} / 0.64`);
        el.style.setProperty(`--dyte-colors-${color}-600`, `${rgb} / 0.52`);
      }
      else {
        const rgb = hexToRGB(colorValue).join(' ');
        el.style.setProperty(`--dyte-colors-${color}`, rgb);
      }
    }
    else if (typeof colorValue === 'object') {
      Object.keys(colorValue).forEach((shade) => {
        const shadeValue = colorValue[shade];
        const rgb = hexToRGB(shadeValue).join(' ');
        el.style.setProperty(`--dyte-colors-${color}-${shade}`, rgb);
      });
    }
  });
};
/**
 * Provides the design system new tokens to consume values from for styling the Dyte UI Kit's UI.
 * @param el The element/node you want to _provide_ Dyte's design system.
 * @param tokens The design tokens you want to updated.
 */
const provideDyteDesignSystem = (el, { spacingBase, borderRadius, borderWidth, colors, fontFamily, googleFont, theme, }) => {
  if (typeof el !== 'object') {
    throw new Error('[dyte-ui-kit] (provideDyteDesignSystem): Passed element is not a valid HTML Element');
  }
  if (typeof googleFont === 'string') {
    provideGoogleFont(googleFont);
    el.style.setProperty('--dyte-font-family', googleFont);
  }
  if (typeof fontFamily === 'string') {
    el.style.setProperty('--dyte-font-family', fontFamily);
  }
  if (typeof spacingBase === 'number') {
    provideSpacing(el, spacingBase);
  }
  if (typeof borderWidth === 'string') {
    provideBorderWidth(el, borderWidth);
  }
  if (typeof borderRadius === 'string') {
    provideBorderRadius(el, borderRadius);
  }
  if (typeof theme === 'string') {
    const colors = THEMES[theme];
    if (colors != null)
      provideColors(el, colors);
  }
  if (typeof colors === 'object') {
    provideColors(el, colors);
  }
};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$8 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer = moduleExports$1 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Extend the default UI Config with your own
 * @param config Your extended UI Config
 * @returns New extended UI Config object
 */
const extendConfig = (config, baseConfig = defaultConfig) => {
  let newConfig = Object.assign({}, baseConfig);
  merge(newConfig, config);
  return newConfig;
};
/**
 * Generates a config with older theme value.
 * @param oldConfig Theme object
 * @param toExtend UI Config object to extend the generated config
 * @param options Options for toggling components
 * @returns
 */
const generateConfig = (oldConfig, meeting, toExtend = {}, options = { grid_pagination: true, settings_toggle: true }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
  const data = { showSetupScreen: true };
  let logo;
  let meetingElements = ['dyte-stage'];
  let headerChildren = {}, controlBarChildren = {};
  const showSettingsToggle = (options === null || options === void 0 ? void 0 : options.settings_toggle) !== false;
  const showGridPagination = (options === null || options === void 0 ? void 0 : options.grid_pagination) !== false;
  if ((_a = oldConfig.controlBar) === null || _a === void 0 ? void 0 : _a.isEnabled) {
    meetingElements.push('dyte-controlbar');
    const { elements } = oldConfig.controlBar;
    const leftElements = [
      ...(elements.fullscreen ? ['dyte-fullscreen-toggle'] : []),
      ...(showSettingsToggle ? ['dyte-settings-toggle'] : []),
    ];
    const rightElements = [];
    const moreElements = [];
    if (meeting.troubleshoot !== undefined) {
      moreElements.push('dyte-debugger-toggle');
    }
    if (store.isSupported() &&
      ((_c = (_b = meeting.self) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.pipMode) &&
      ((_d = meeting.self.config) === null || _d === void 0 ? void 0 : _d.viewType) !== 'LIVESTREAM') {
      moreElements.push('dyte-pip-toggle');
    }
    if (meeting === null || meeting === void 0 ? void 0 : meeting.self.permissions.canAllowParticipantAudio) {
      moreElements.push('dyte-mute-all-button');
    }
    if (canToggleBreakout(meeting)) {
      moreElements.push('dyte-breakout-rooms-toggle');
    }
    if ((_e = meeting.self) === null || _e === void 0 ? void 0 : _e.permissions.canRecord) {
      moreElements.push('dyte-recording-toggle');
    }
    if (isLiveStreamHost(meeting)) {
      leftElements.push('dyte-livestream-toggle');
    }
    if (elements.screenshare) {
      leftElements.push('dyte-screen-share-toggle');
    }
    if (elements.chat) {
      rightElements.push('dyte-chat-toggle');
    }
    if (elements.polls) {
      rightElements.push('dyte-polls-toggle');
    }
    if (elements.participants) {
      rightElements.push('dyte-participants-toggle');
    }
    if (elements.plugins) {
      rightElements.push('dyte-plugins-toggle');
    }
    rightElements.push('dyte-ai-toggle');
    // NOTE(ishita1805): No condition as permission check happens within component
    const centerElements = [
      'dyte-mic-toggle',
      'dyte-camera-toggle',
      'dyte-webinar-stage-toggle',
      'dyte-stage-toggle',
      'dyte-leave-button',
    ];
    if (moreElements.length > 0)
      centerElements.push('dyte-more-toggle');
    const allSideElements = leftElements.concat(rightElements).concat(moreElements);
    let hasMobileDrawer = false;
    if (allSideElements.length > 0) {
      hasMobileDrawer = true;
    }
    controlBarChildren = {
      'dyte-controlbar': {
        states: ['activeMoreMenu'],
        children: ['div#controlbar-left', 'div#controlbar-center', 'div#controlbar-right'],
      },
      'div#controlbar-left': leftElements,
      'div#controlbar-center': centerElements,
      'div#controlbar-right': rightElements,
      'dyte-more-toggle': {
        states: ['activeMoreMenu'],
        children: [],
      },
      'dyte-more-toggle.activeMoreMenu': moreElements.map((el) => [
        el,
        { variant: 'horizontal', slot: 'more-elements' },
      ]),
      'dyte-controlbar.sm': ['div#controlbar-mobile'],
      'dyte-controlbar.md': ['div#controlbar-mobile'],
      'dyte-more-toggle.activeMoreMenu.md': allSideElements.map((el) => [
        el,
        { variant: 'horizontal', slot: 'more-elements' },
      ]),
      'dyte-more-toggle.activeMoreMenu.sm': allSideElements.map((el) => [
        el,
        { variant: 'horizontal', slot: 'more-elements' },
      ]),
      'div#controlbar-mobile': [
        'dyte-mic-toggle',
        'dyte-camera-toggle',
        'dyte-webinar-stage-toggle',
        'dyte-stage-toggle',
        ...[hasMobileDrawer && 'dyte-more-toggle'],
        'dyte-leave-button',
      ],
    };
  }
  if ((_f = oldConfig.header) === null || _f === void 0 ? void 0 : _f.isEnabled) {
    meetingElements.unshift('dyte-header');
    const { elements } = oldConfig.header;
    let leftElements = ['dyte-recording-indicator', 'dyte-livestream-indicator'], centerElements = [], rightElements = [];
    if (showGridPagination) {
      rightElements.push('dyte-grid-pagination');
    }
    if (elements.title) {
      centerElements.push('dyte-meeting-title');
    }
    if (typeof elements.logo === 'string' && elements.logo.length > 0) {
      logo = elements.logo;
      leftElements.unshift('dyte-logo');
    }
    if (elements.participantCount) {
      rightElements.push('dyte-participant-count', 'dyte-viewer-count');
    }
    if (elements.timer) {
      rightElements.push('dyte-clock');
    }
    headerChildren = {
      'dyte-header': ['div#header-left', 'div#header-center', 'div#header-right'],
      'dyte-header.sm': { remove: ['div#header-center'] },
      'div#header-left': leftElements,
      'div#header-center': centerElements,
      'div#header-right': rightElements,
      'div#header-left.sm': {
        remove: ['dyte-logo'],
        prepend: ['dyte-meeting-title'],
      },
    };
  }
  meetingElements.push('dyte-participants-audio', 'dyte-dialog-manager');
  let designTokens = {
    logo,
  };
  if (oldConfig.isV2 === true) {
    designTokens = oldConfig.designTokens;
    if (isValidHexColor((_h = (_g = oldConfig === null || oldConfig === void 0 ? void 0 : oldConfig.designTokens) === null || _g === void 0 ? void 0 : _g.colors) === null || _h === void 0 ? void 0 : _h.textOnBrand)) {
      designTokens.colors['text-on-brand'] = (_k = (_j = oldConfig === null || oldConfig === void 0 ? void 0 : oldConfig.designTokens) === null || _j === void 0 ? void 0 : _j.colors) === null || _k === void 0 ? void 0 : _k.textOnBrand;
    }
    if (isValidHexColor((_m = (_l = oldConfig === null || oldConfig === void 0 ? void 0 : oldConfig.designTokens) === null || _l === void 0 ? void 0 : _l.colors) === null || _m === void 0 ? void 0 : _m.videoBg)) {
      designTokens.colors['video-bg'] = (_p = (_o = oldConfig === null || oldConfig === void 0 ? void 0 : oldConfig.designTokens) === null || _o === void 0 ? void 0 : _o.colors) === null || _p === void 0 ? void 0 : _p.videoBg;
    }
  }
  else if (oldConfig.colors != null) {
    designTokens['colors'] = {};
    if (isValidHexColor(oldConfig.colors.primary)) {
      designTokens['colors']['brand'] = getBrandColors(oldConfig.colors.primary);
    }
    else if (typeof oldConfig.colors.primary === 'object') {
      designTokens['colors']['brand'] = oldConfig.colors.primary;
    }
    if (isValidHexColor(oldConfig.colors.secondary)) {
      designTokens['colors']['background'] = getBackgroundColorsOld(oldConfig.colors.secondary);
    }
    else if (typeof oldConfig.colors.secondary === 'object') {
      designTokens['colors']['background'] = oldConfig.colors.secondary;
    }
    if (isValidHexColor(oldConfig.colors.text)) {
      designTokens['colors']['text'] = oldConfig.colors.text;
    }
    if (isValidHexColor(oldConfig.colors.textPrimary)) {
      designTokens['colors']['text-on-brand'] = oldConfig.colors.textPrimary;
    }
    if (isValidHexColor(oldConfig.colors.videoBackground)) {
      designTokens['colors']['video-bg'] = oldConfig.colors.videoBackground;
    }
  }
  let config = {
    designTokens,
    styles: {
      'dyte-header': {
        display: 'grid',
        height: '48px',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
      },
      'dyte-header.sm': {
        display: 'grid',
        gridArea: 'header',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
      },
      'div#header-left': {
        display: 'flex',
        alignItems: 'center',
        height: '48px',
        wordBreak: 'break-all',
      },
      'dyte-logo': {
        height: '26px',
      },
      'div#header-center': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        wordBreak: 'break-all',
      },
      'div#header-right': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-end',
      },
      'dyte-stage': {
        display: 'flex',
        flex: '1',
      },
      'dyte-grid': {
        flex: '1',
        height: 'auto',
      },
      'dyte-controlbar': {
        display: 'grid',
        gridTemplateColumns: 'repeat(3,1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
        padding: '8px',
      },
      'dyte-controlbar.sm': {
        display: 'flex',
        position: 'relative',
        backgroundColor: 'var(--dyte-colors-background-1000, #000)',
      },
      'dyte-controlbar.md': {
        display: 'flex',
        position: 'relative',
        backgroundColor: 'var(--dyte-colors-background-1000, #000)',
      },
      'div#controlbar-left': {
        display: 'flex',
        alignItems: 'center',
      },
      'div#controlbar-center': {
        display: 'flex',
        alignItems: 'center',
        position: 'relative',
        overflow: 'visible',
        justifyContent: 'center',
      },
      'div#controlbar-mobile': {
        display: 'flex',
        flex: '1',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: '10000',
      },
      'div#controlbar-right': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-end',
      },
      'dyte-settings': {
        width: '720px',
        height: '480px',
      },
      'dyte-debugger': {
        width: '720px',
        height: '480px',
      },
      'div#setupcontrols-media': {
        position: 'absolute',
        bottom: '8px',
        right: '8px',
        display: 'flex',
      },
      'div#setupcontrols-settings': {
        position: 'absolute',
        top: '8px',
        right: '8px',
      },
      'dyte-meeting-title.sm': {
        marginLeft: '0',
      },
      'dyte-clock': {
        marginRight: '0',
      },
    },
    root: Object.assign(Object.assign(Object.assign({ 'dyte-meeting': {
        // if using key value pair, provide the key in `state`
        // else provide array of states in `states`
        state: 'meeting',
        states: ['activeSidebar', 'activeAI'],
      }, 'dyte-meeting[meeting=idle]': ['dyte-idle-screen'], 'dyte-meeting[meeting=waiting]': ['dyte-waiting-screen'], 'dyte-meeting[meeting=setup]': ['dyte-setup-screen', 'dyte-dialog-manager'], 'dyte-meeting[meeting=joined]': meetingElements, 'dyte-meeting[meeting=joined].activeSidebar.sm': {
        add: [['dyte-sidebar', { view: 'full-screen' }]],
      }, 'dyte-meeting[meeting=joined].activeSidebar.md': {
        add: [['dyte-sidebar', { view: 'full-screen' }]],
      }, 'dyte-meeting[meeting=joined].activeAI.sm': {
        add: [['dyte-ai', { view: 'full-screen' }]],
      }, 'dyte-meeting[meeting=joined].activeAI.md': {
        add: [['dyte-ai', { view: 'full-screen' }]],
      }, 'dyte-meeting[meeting=ended]': ['dyte-ended-screen'] }, headerChildren), controlBarChildren), { 'dyte-stage': {
        states: ['activeSidebar', 'activeAI'],
        children: ['dyte-grid', 'dyte-notifications'],
      }, 'dyte-stage.activeSidebar': {
        add: [['dyte-sidebar', { view: 'sidebar' }]],
      }, 
      // hide sidebar for smaller screens
      'dyte-stage.activeSidebar.sm': { remove: ['dyte-sidebar'] }, 'dyte-stage.activeAI': {
        add: [['dyte-ai', { view: 'sidebar' }]],
      }, 
      // hide sidebar for smaller screens
      'dyte-stage.activeAI.sm': { remove: ['dyte-ai'] }, 'dyte-grid': {
        states: ['activeScreenShare', 'activePlugin', 'activeSpotlight'],
        children: ['dyte-simple-grid'],
      }, 'dyte-grid.activeSpotlight': ['dyte-spotlight-grid'], 'dyte-grid.activeScreenShare': ['dyte-mixed-grid'], 'dyte-grid.activePlugin': ['dyte-mixed-grid'], 'dyte-grid.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid.activePlugin.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid.activePlugin.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'], 'dyte-mixed-grid': {
        states: ['activeSpotlight'],
        children: ['dyte-simple-grid'],
      }, 'dyte-mixed-grid.activeSpotlight': ['dyte-spotlight-grid'], 'dyte-participant-tile': {
        state: 'meeting',
        children: ['dyte-name-tag', 'dyte-avatar', 'dyte-network-indicator'],
      }, 'dyte-participant-setup': ['dyte-avatar', 'div#setupcontrols-media'], 'dyte-participant-tile[meeting=setup]': [
        'dyte-avatar',
        'div#setupcontrols-media',
        ...(showSettingsToggle ? ['div#setupcontrols-settings'] : []),
      ], 'div#setupcontrols-media': [
        ['dyte-mic-toggle', { size: 'sm' }],
        ['dyte-camera-toggle', { size: 'sm' }],
      ], 'div#setupcontrols-settings': [
        ['dyte-settings-toggle', { size: 'sm' }],
        ['dyte-debugger-toggle', { size: 'sm' }],
      ], 'dyte-screenshare-view': ['dyte-name-tag', 'dyte-network-indicator'], 'dyte-name-tag': [['dyte-audio-visualizer', { slot: 'start' }]] }),
    config: {
      notification_sounds: {
        participant_left: false,
      },
      participant_joined_sound_notification_limit: 3,
      participant_chat_message_sound_notification_limit: 10,
      videoFit: 'cover',
    },
  };
  config = extendConfig(toExtend, config);
  data.showSetupScreen = (_r = (_q = oldConfig.setupScreen) === null || _q === void 0 ? void 0 : _q.isEnabled) !== null && _r !== void 0 ? _r : true;
  return { config, data };
};

/**
 * Default Icon Pack for UI Kit
 */
const defaultIconPack = {
  people: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 13.999 13 14a2 2 0 0 1 1.995 1.85L15 16v1.5C14.999 21 11.284 22 8.5 22c-2.722 0-6.335-.956-6.495-4.27L2 17.5v-1.501c0-1.054.816-1.918 1.85-1.995L4 14ZM15.22 14H20c1.054 0 1.918.816 1.994 1.85L22 16v1c-.001 3.062-2.858 4-5 4a7.16 7.16 0 0 1-2.14-.322c.336-.386.607-.827.802-1.327A6.19 6.19 0 0 0 17 19.5l.267-.006c.985-.043 3.086-.363 3.226-2.289L20.5 17v-1a.501.501 0 0 0-.41-.492L20 15.5h-4.051a2.957 2.957 0 0 0-.595-1.34L15.22 14H20h-4.78ZM4 15.499l-.1.01a.51.51 0 0 0-.254.136.506.506 0 0 0-.136.253l-.01.101V17.5c0 1.009.45 1.722 1.417 2.242.826.445 2.003.714 3.266.753l.317.005.317-.005c1.263-.039 2.439-.308 3.266-.753.906-.488 1.359-1.145 1.412-2.057l.005-.186V16a.501.501 0 0 0-.41-.492L13 15.5l-9-.001ZM8.5 3a4.5 4.5 0 1 1 0 9 4.5 4.5 0 0 1 0-9Zm9 2a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7Zm-9-.5c-1.654 0-3 1.346-3 3s1.346 3 3 3 3-1.346 3-3-1.346-3-3-3Zm9 2c-1.103 0-2 .897-2 2s.897 2 2 2 2-.897 2-2-.897-2-2-2Z" fill="currentColor"/></svg>',
  people_checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29 29"><path fill="currentColor" d="M14.58 15.333H2.833a2.667 2.667 0 0 0-2.666 2.666v2l.006.307c.214 4.419 5.031 5.693 8.66 5.693 1.374 0 2.92-.182 4.32-.649a8.53 8.53 0 0 1-.717-1.87c-.93.298-2.027.478-3.18.513l-.423.006-.422-.006c-1.684-.052-3.254-.411-4.355-1.004-1.29-.694-1.89-1.644-1.89-2.99v-2.001l.014-.135a.675.675 0 0 1 .181-.337.68.68 0 0 1 .338-.181l.134-.014h10.31a8.71 8.71 0 0 1 1.436-1.998h.001Zm.253-8.667a6 6 0 1 0-12 0 6 6 0 0 0 12 0Zm-10 0c0-2.205 1.795-4 4-4 2.206 0 4 1.795 4 4s-1.794 4-4 4c-2.205 0-4-1.795-4-4ZM25.5 7.999a4.667 4.667 0 1 0-9.333 0A4.667 4.667 0 0 0 25.5 8Zm-7.333 0a2.67 2.67 0 0 1 2.666-2.666A2.67 2.67 0 0 1 23.5 7.999a2.67 2.67 0 0 1-2.667 2.667 2.67 2.67 0 0 1-2.666-2.667Zm10 13.334a7.333 7.333 0 1 1-14.667 0 7.333 7.333 0 0 1 14.667 0Zm-2.862-3.139a.666.666 0 0 0-.944 0l-4.86 4.863-2.196-2.196a.667.667 0 1 0-.944.944l2.667 2.666a.666.666 0 0 0 .944 0l5.333-5.333a.666.666 0 0 0 0-.944Z"/></svg>',
  chat: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10a9.96 9.96 0 0 1-4.587-1.112l-3.826 1.067a1.25 1.25 0 0 1-1.54-1.54l1.068-3.823A9.96 9.96 0 0 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5A8.5 8.5 0 0 0 3.5 12c0 1.47.373 2.883 1.073 4.137l.15.27-1.112 3.984 3.987-1.112.27.15A8.5 8.5 0 1 0 12 3.5ZM8.75 13h4.498a.75.75 0 0 1 .102 1.493l-.102.007H8.75a.75.75 0 0 1-.102-1.493L8.75 13h4.498H8.75Zm0-3.5h6.505a.75.75 0 0 1 .101 1.493l-.101.007H8.75a.75.75 0 0 1-.102-1.493L8.75 9.5h6.505H8.75Z" fill="currentColor"/></svg>',
  poll: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.752 2a2.752 2.752 0 0 1 2.752 2.751V19.25a2.752 2.752 0 1 1-5.504 0V4.75A2.752 2.752 0 0 1 11.752 2Zm7 5a2.752 2.752 0 0 1 2.752 2.751v9.499a2.752 2.752 0 1 1-5.504 0V9.75A2.752 2.752 0 0 1 18.752 7Zm-14 5a2.752 2.752 0 0 1 2.752 2.751v4.499a2.752 2.752 0 0 1-5.504 0V14.75A2.752 2.752 0 0 1 4.752 12Zm7-8.5c-.692 0-1.252.56-1.252 1.251V19.25a1.252 1.252 0 0 0 2.504 0V4.75c0-.691-.56-1.251-1.252-1.251Zm7 5c-.691 0-1.252.56-1.252 1.251v9.499a1.252 1.252 0 0 0 2.504 0V9.75c0-.691-.56-1.251-1.252-1.251Zm-14 5c-.692 0-1.252.56-1.252 1.251v4.499a1.252 1.252 0 1 0 2.504 0V14.75c0-.691-.56-1.252-1.252-1.252Z" fill="currentColor"/></svg>',
  participants: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.754 10c.966 0 1.75.784 1.75 1.75v4.749a4.501 4.501 0 0 1-9.002 0V11.75c0-.966.783-1.75 1.75-1.75h5.502Zm0 1.5H9.252a.25.25 0 0 0-.25.25v4.749a3.001 3.001 0 0 0 6.002 0V11.75a.25.25 0 0 0-.25-.25ZM3.75 10h3.381a2.738 2.738 0 0 0-.618 1.5H3.75a.25.25 0 0 0-.25.25v3.249a2.501 2.501 0 0 0 3.082 2.433c.085.504.24.985.453 1.432A4.001 4.001 0 0 1 2 14.999V11.75c0-.966.784-1.75 1.75-1.75Zm13.125 0h3.375c.966 0 1.75.784 1.75 1.75V15a4 4 0 0 1-5.03 3.866c.214-.448.369-.929.455-1.433A2.5 2.5 0 0 0 20.5 15v-3.25a.25.25 0 0 0-.25-.25h-2.757a2.738 2.738 0 0 0-.618-1.5ZM12 3a3 3 0 1 1 0 6 3 3 0 0 1 0-6Zm6.5 1a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Zm-13 0a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Zm6.5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm6.5 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-13 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z" fill="currentColor"/></svg>',
  rocket: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path d="M9.35 20.45 14.65 22.7Q15.55 20.9 16.575 19.15Q17.6 17.4 18.75 15.8L14.8 15Q14.8 15 14.8 15Q14.8 15 14.8 15ZM17.05 24.5 23.7 31.15Q26.55 29.85 29.05 28.2Q31.55 26.55 33.1 25Q37.15 20.95 39.05 16.7Q40.95 12.45 41.1 7.1Q35.75 7.25 31.5 9.15Q27.25 11.05 23.2 15.1Q21.65 16.65 20 19.15Q18.35 21.65 17.05 24.5ZM28.5 19.7Q27.5 18.7 27.5 17.225Q27.5 15.75 28.5 14.75Q29.5 13.75 30.975 13.75Q32.45 13.75 33.45 14.75Q34.45 15.75 34.45 17.225Q34.45 18.7 33.45 19.7Q32.45 20.7 30.975 20.7Q29.5 20.7 28.5 19.7ZM27.75 38.85 33.2 33.4Q33.2 33.4 33.2 33.4Q33.2 33.4 33.2 33.4L32.4 29.45Q30.8 30.6 29.05 31.625Q27.3 32.65 25.5 33.55ZM44.05 4.15Q44.5 10.95 42.35 16.55Q40.2 22.15 35.25 27.1Q35.2 27.15 35.15 27.2Q35.1 27.25 35.05 27.3L36.15 32.8Q36.3 33.55 36.075 34.25Q35.85 34.95 35.3 35.5L26.75 44.1L22.5 34.2L14 25.7L4.1 21.45L12.7 12.9Q13.25 12.35 13.95 12.125Q14.65 11.9 15.4 12.05L20.9 13.15Q20.95 13.1 21 13.075Q21.05 13.05 21.1 13Q26.05 8.05 31.65 5.875Q37.25 3.7 44.05 4.15ZM7.45 31.75Q9.2 30 11.725 29.975Q14.25 29.95 16 31.7Q17.75 33.45 17.725 35.975Q17.7 38.5 15.95 40.25Q14.65 41.55 11.925 42.4Q9.2 43.25 3.75 44Q4.5 38.55 5.325 35.8Q6.15 33.05 7.45 31.75ZM9.55 33.9Q8.85 34.65 8.3 36.25Q7.75 37.85 7.35 40.35Q9.85 39.95 11.45 39.4Q13.05 38.85 13.8 38.15Q14.75 37.3 14.775 36.025Q14.8 34.75 13.9 33.8Q12.95 32.9 11.675 32.925Q10.4 32.95 9.55 33.9Z" fill="currentColor" /></svg>',
  call_end: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.903 13.202-.191.816a2.75 2.75 0 0 1-2.955 2.107l-1.755-.178A2.75 2.75 0 0 1 14.6 13.83l-.389-1.686a.25.25 0 0 0-.113-.157c-.321-.197-1.034-.32-2.098-.32-.786 0-1.386.067-1.786.189-.14.043-.238.085-.301.116l-.09.048-.015.04-.409 1.77A2.75 2.75 0 0 1 7 15.948l-1.746.177A2.75 2.75 0 0 1 2.3 14.03l-.196-.817a3.75 3.75 0 0 1 1.13-3.651C5.134 7.839 8.064 7 12 7c3.943 0 6.875.842 8.776 2.57a3.75 3.75 0 0 1 1.172 3.41l-.045.222Zm-1.426-.514a2.25 2.25 0 0 0-.71-2.009C18.184 9.241 15.602 8.5 12 8.5c-3.598 0-6.177.739-7.76 2.172a2.25 2.25 0 0 0-.677 2.19l.196.818a1.25 1.25 0 0 0 1.342.953l1.746-.178a1.25 1.25 0 0 0 1.09-.962l.423-1.82.043-.136c.376-.998 1.591-1.37 3.597-1.37 1.318 0 2.265.164 2.88.54.401.245.687.642.793 1.1l.389 1.685c.12.522.56.909 1.092.963l1.754.178a1.25 1.25 0 0 0 1.343-.958l.192-.816.034-.171Z" fill="currentColor"/></svg>',
  share: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 2.498a3.502 3.502 0 1 1-2.597 5.851l-4.558 2.604a3.5 3.5 0 0 1 0 2.093l4.557 2.606a3.502 3.502 0 1 1-.745 1.302L9.1 14.347a3.502 3.502 0 1 1 0-4.698l4.557-2.604A3.502 3.502 0 0 1 17 2.498Zm0 13.5a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Zm-10.498-6a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Zm10.498-6a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Z" fill="currentColor"/></svg>',
  mic_on: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.25 11a.75.75 0 0 1 .743.648l.007.102v.5a6.75 6.75 0 0 1-6.249 6.732l-.001 2.268a.75.75 0 0 1-1.493.102l-.007-.102v-2.268a6.75 6.75 0 0 1-6.246-6.496L5 12.25v-.5a.75.75 0 0 1 1.493-.102l.007.102v.5a5.25 5.25 0 0 0 5.034 5.246l.216.004h.5a5.25 5.25 0 0 0 5.246-5.034l.004-.216v-.5a.75.75 0 0 1 .75-.75ZM12 2a4 4 0 0 1 4 4v6a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4Zm0 1.5A2.5 2.5 0 0 0 9.5 6v6a2.5 2.5 0 0 0 5 0V6A2.5 2.5 0 0 0 12 3.5Z" fill="currentColor"/></svg>',
  mic_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06L8 9.06V12a4 4 0 0 0 6.248 3.309l1.146 1.146A5.227 5.227 0 0 1 12.25 17.5h-.5l-.216-.004A5.25 5.25 0 0 1 6.5 12.25v-.5l-.007-.102A.75.75 0 0 0 5 11.75v.5l.004.236a6.75 6.75 0 0 0 6.246 6.496v2.268l.007.102a.75.75 0 0 0 1.493-.102l.001-2.268a6.718 6.718 0 0 0 3.712-1.458l4.256 4.256a.75.75 0 0 0 1.061-1.06L3.28 2.22Zm9.876 11.997A2.5 2.5 0 0 1 9.5 12v-1.44l3.656 3.657ZM14.5 6v5.318l1.43 1.43c.046-.242.07-.492.07-.748V6a4 4 0 0 0-7.862-1.044L9.5 6.318V6a2.5 2.5 0 0 1 5 0ZM17.196 14.014l1.146 1.146A6.725 6.725 0 0 0 19 12.25v-.5l-.007-.102a.75.75 0 0 0-1.493.102v.5l-.004.216a5.233 5.233 0 0 1-.3 1.548Z" fill="currentColor"/></svg>',
  video_on: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13.75 4.5A3.25 3.25 0 0 1 17 7.75v.173l3.864-2.318A.75.75 0 0 1 22 6.248V17.75a.75.75 0 0 1-1.136.643L17 16.075v.175a3.25 3.25 0 0 1-3.25 3.25h-8.5A3.25 3.25 0 0 1 2 16.25v-8.5A3.25 3.25 0 0 1 5.25 4.5h8.5Zm0 1.5h-8.5A1.75 1.75 0 0 0 3.5 7.75v8.5c0 .966.784 1.75 1.75 1.75h8.5a1.75 1.75 0 0 0 1.75-1.75v-8.5A1.75 1.75 0 0 0 13.75 6Zm6.75 1.573L17 9.674v4.651l3.5 2.1V7.573Z" fill="currentColor"/></svg>',
  video_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06l1.567 1.567A3.25 3.25 0 0 0 2 7.75v8.5a3.25 3.25 0 0 0 3.25 3.25h8.5a3.25 3.25 0 0 0 2.903-1.786l4.066 4.067a.75.75 0 0 0 1.061-1.061L3.28 2.22Zm12.196 14.317A1.75 1.75 0 0 1 13.75 18h-8.5a1.75 1.75 0 0 1-1.75-1.75v-8.5c0-.869.633-1.59 1.463-1.727l10.514 10.514ZM15.5 12.318V7.75A1.75 1.75 0 0 0 13.75 6H9.182l-1.5-1.5h6.068A3.25 3.25 0 0 1 17 7.75v.173l3.864-2.318A.75.75 0 0 1 22 6.248V17.75c0 .301-.17.543-.403.665L20.5 17.318V7.573L17 9.674v4.144l-1.5-1.5Z" fill="currentColor"/></svg>',
  share_screen_start: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 6.25A2.25 2.25 0 0 1 4.25 4h15.5A2.25 2.25 0 0 1 22 6.25v11.5A2.25 2.25 0 0 1 19.75 20H4.25A2.25 2.25 0 0 1 2 17.75V6.25Zm2.25-.75a.75.75 0 0 0-.75.75v11.5c0 .414.336.75.75.75h15.5a.75.75 0 0 0 .75-.75V6.25a.75.75 0 0 0-.75-.75H4.25Z"/><path d="M12 7.245a.75.75 0 0 1 .53.22l3.255 3.255a.75.75 0 1 1-1.06 1.06L12.75 9.806v6.447a.75.75 0 0 1-1.5 0V9.808L9.28 11.78a.75.75 0 1 1-1.06-1.06l3.25-3.254a.75.75 0 0 1 .53-.22Z"/></svg>',
  share_screen_stop: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 6.25A2.25 2.25 0 0 1 4.25 4h15.5A2.25 2.25 0 0 1 22 6.25v11.5A2.25 2.25 0 0 1 19.75 20H4.25A2.25 2.25 0 0 1 2 17.75V6.25Zm2.25-.75a.75.75 0 0 0-.75.75v11.5c0 .414.336.75.75.75h15.5a.75.75 0 0 0 .75-.75V6.25a.75.75 0 0 0-.75-.75H4.25Z"/><path d="M8.22 8.215a.75.75 0 0 1 1.06 0l2.72 2.72 2.725-2.716a.75.75 0 0 1 1.06 1.062l-2.724 2.715 2.724 2.724a.75.75 0 1 1-1.06 1.06L12 13.057 9.28 15.78a.75.75 0 0 1-1.06-1.06l2.72-2.724-2.72-2.72a.75.75 0 0 1 0-1.06Z"/></svg>',
  share_screen_person: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 7.25A3.25 3.25 0 0 1 5.25 4h13.5A3.25 3.25 0 0 1 22 7.25V13h-.258a3.74 3.74 0 0 0-1.242-2.545V7.25a1.75 1.75 0 0 0-1.75-1.75H5.25A1.75 1.75 0 0 0 3.5 7.25v9.5c0 .966.784 1.75 1.75 1.75H12v.5c0 .34.04.674.118 1H5.25A3.25 3.25 0 0 1 2 16.75v-9.5ZM21.5 17a1.5 1.5 0 0 1 1.5 1.5v.5c0 1.971-1.86 4-5 4-3.14 0-5-2.029-5-4v-.5a1.5 1.5 0 0 1 1.5-1.5h7ZM18 10.5a2.75 2.75 0 1 1 0 5.5 2.75 2.75 0 0 1 0-5.5Z" fill="currentColor"/></svg>',
  clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.478 10 10s-4.477 10-10 10S2 17.522 2 12 6.477 2 12 2Zm0 1.667c-4.595 0-8.333 3.738-8.333 8.333 0 4.595 3.738 8.333 8.333 8.333 4.595 0 8.333-3.738 8.333-8.333 0-4.595-3.738-8.333-8.333-8.333ZM11.25 6a.75.75 0 0 1 .743.648L12 6.75V12h3.25a.75.75 0 0 1 .102 1.493l-.102.007h-4a.75.75 0 0 1-.743-.648l-.007-.102v-6a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
  dismiss: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m4.397 4.554.073-.084a.75.75 0 0 1 .976-.073l.084.073L12 10.939l6.47-6.47a.75.75 0 1 1 1.06 1.061L13.061 12l6.47 6.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L12 13.061l-6.47 6.47a.75.75 0 0 1-1.06-1.061L10.939 12l-6.47-6.47a.75.75 0 0 1-.072-.976l.073-.084-.073.084Z" fill="currentColor"/></svg>',
  send: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.694 12 2.299 3.272c-.236-.607.356-1.188.942-.982l.093.04 18 9a.75.75 0 0 1 .097 1.283l-.097.058-18 9a.75.75 0 0 1-1.065-.847l.03-.096L5.694 12 2.299 3.272 5.694 12ZM4.402 4.54l2.61 6.71h6.627a.75.75 0 0 1 .743.648l.007.102a.75.75 0 0 1-.649.743l-.101.007H7.01l-2.609 6.71L19.322 12 4.401 4.54Z" fill="currentColor"/></svg>',
  search: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 2.75a7.25 7.25 0 0 1 5.63 11.819l4.9 4.9a.75.75 0 0 1-.976 1.134l-.084-.073-4.901-4.9A7.25 7.25 0 1 1 10 2.75Zm0 1.5a5.75 5.75 0 1 0 0 11.5 5.75 5.75 0 0 0 0-11.5Z" fill="currentColor"/</svg>',
  more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7.75a1.75 1.75 0 1 1 0-3.5 1.75 1.75 0 0 1 0 3.5ZM12 13.75a1.75 1.75 0 1 1 0-3.5 1.75 1.75 0 0 1 0 3.5ZM10.25 18a1.75 1.75 0 1 0 3.5 0 1.75 1.75 0 0 0-3.5 0Z" fill="currentColor"/></svg>',
  chevron_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.22 8.47a.75.75 0 0 1 1.06 0L12 15.19l6.72-6.72a.75.75 0 1 1 1.06 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L4.22 9.53a.75.75 0 0 1 0-1.06Z" fill="currentColor"/></svg>',
  chevron_up: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.22 15.53a.75.75 0 0 0 1.06 0L12 8.81l6.72 6.72a.75.75 0 1 0 1.06-1.06l-7.25-7.25a.75.75 0 0 0-1.06 0l-7.25 7.25a.75.75 0 0 0 0 1.06Z" fill="currentColor"/></svg>',
  chevron_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.53 4.22a.75.75 0 0 1 0 1.06L8.81 12l6.72 6.72a.75.75 0 1 1-1.06 1.06l-7.25-7.25a.75.75 0 0 1 0-1.06l7.25-7.25a.75.75 0 0 1 1.06 0Z" fill="currentColor"/></svg>',
  chevron_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.47 4.22a.75.75 0 0 0 0 1.06L15.19 12l-6.72 6.72a.75.75 0 1 0 1.06 1.06l7.25-7.25a.75.75 0 0 0 0-1.06L9.53 4.22a.75.75 0 0 0-1.06 0Z" fill="currentColor"/></svg>',
  settings: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.012 2.25c.734.008 1.465.093 2.182.253a.75.75 0 0 1 .582.649l.17 1.527a1.384 1.384 0 0 0 1.927 1.116l1.401-.615a.75.75 0 0 1 .85.174 9.792 9.792 0 0 1 2.204 3.792.75.75 0 0 1-.271.825l-1.242.916a1.381 1.381 0 0 0 0 2.226l1.243.915a.75.75 0 0 1 .272.826 9.797 9.797 0 0 1-2.204 3.792.75.75 0 0 1-.848.175l-1.407-.617a1.38 1.38 0 0 0-1.926 1.114l-.169 1.526a.75.75 0 0 1-.572.647 9.518 9.518 0 0 1-4.406 0 .75.75 0 0 1-.572-.647l-.168-1.524a1.382 1.382 0 0 0-1.926-1.11l-1.406.616a.75.75 0 0 1-.849-.175 9.798 9.798 0 0 1-2.204-3.796.75.75 0 0 1 .272-.826l1.243-.916a1.38 1.38 0 0 0 0-2.226l-1.243-.914a.75.75 0 0 1-.271-.826 9.793 9.793 0 0 1 2.204-3.792.75.75 0 0 1 .85-.174l1.4.615a1.387 1.387 0 0 0 1.93-1.118l.17-1.526a.75.75 0 0 1 .583-.65c.717-.159 1.45-.243 2.201-.252Zm0 1.5a9.135 9.135 0 0 0-1.354.117l-.109.977A2.886 2.886 0 0 1 6.525 7.17l-.898-.394a8.293 8.293 0 0 0-1.348 2.317l.798.587a2.881 2.881 0 0 1 0 4.643l-.799.588c.32.842.776 1.626 1.348 2.322l.905-.397a2.882 2.882 0 0 1 4.017 2.318l.11.984c.889.15 1.798.15 2.687 0l.11-.984a2.881 2.881 0 0 1 4.018-2.322l.905.396a8.296 8.296 0 0 0 1.347-2.318l-.798-.588a2.881 2.881 0 0 1 0-4.643l.796-.587a8.293 8.293 0 0 0-1.348-2.317l-.896.393a2.884 2.884 0 0 1-4.023-2.324l-.11-.976a8.988 8.988 0 0 0-1.333-.117ZM12 8.25a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Zm0 1.5a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z" fill="currentColor"/></svg>',
  wifi: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.745 10.75a8.291 8.291 0 0 1 1.492 2.07.75.75 0 1 1-1.335.683 6.798 6.798 0 0 0-1.218-1.692 6.562 6.562 0 0 0-10.493 1.673.75.75 0 1 1-1.339-.677 8.062 8.062 0 0 1 12.893-2.057Zm-2.102 3.07c.448.447.816.997 1.072 1.582a.75.75 0 1 1-1.373.602 3.72 3.72 0 0 0-.76-1.124 3.592 3.592 0 0 0-5.08 0c-.31.31-.562.689-.746 1.11a.75.75 0 1 1-1.375-.6 5.11 5.11 0 0 1 1.061-1.57 5.092 5.092 0 0 1 7.201 0Zm4.805-5.541c.51.509.99 1.09 1.409 1.697a.75.75 0 0 1-1.235.852 10.822 10.822 0 0 0-1.234-1.489c-4.08-4.08-10.695-4.08-14.776 0-.421.422-.84.934-1.222 1.484a.75.75 0 0 1-1.232-.855c.43-.62.905-1.2 1.394-1.69 4.666-4.665 12.23-4.665 16.896 0Zm-7.387 8.16a1.5 1.5 0 1 1-2.122 2.122 1.5 1.5 0 0 1 2.122-2.122Z" fill="currentColor"/></svg>',
  speaker: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15 4.25c0-1.079-1.274-1.65-2.08-.934L8.427 7.309a.75.75 0 0 1-.498.19H4.25A2.25 2.25 0 0 0 2 9.749v4.497a2.25 2.25 0 0 0 2.25 2.25h3.68a.75.75 0 0 1 .498.19l4.491 3.994c.806.716 2.081.144 2.081-.934V4.25ZM9.425 8.43 13.5 4.807v14.382l-4.075-3.624a2.25 2.25 0 0 0-1.495-.569H4.25a.75.75 0 0 1-.75-.75V9.75a.75.75 0 0 1 .75-.75h3.68a2.25 2.25 0 0 0 1.495-.569ZM18.992 5.897a.75.75 0 0 1 1.049.157A9.959 9.959 0 0 1 22 12a9.96 9.96 0 0 1-1.96 5.946.75.75 0 0 1-1.205-.892A8.459 8.459 0 0 0 20.5 12a8.459 8.459 0 0 0-1.665-5.054.75.75 0 0 1 .157-1.049Z" /><path d="M17.143 8.37a.75.75 0 0 1 1.017.302c.536.99.84 2.125.84 3.328a6.973 6.973 0 0 1-.84 3.328.75.75 0 0 1-1.32-.714c.42-.777.66-1.666.66-2.614s-.24-1.837-.66-2.614a.75.75 0 0 1 .303-1.017Z"/></svg>',
  speaker_off: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06L6.438 7.5H4.25A2.25 2.25 0 0 0 2 9.749v4.497a2.25 2.25 0 0 0 2.25 2.25h3.68a.75.75 0 0 1 .498.19l4.491 3.994c.806.716 2.081.144 2.081-.934V16.06l5.72 5.72a.75.75 0 0 0 1.06-1.061L3.28 2.22ZM13.5 14.56v4.629l-4.075-3.624a2.25 2.25 0 0 0-1.495-.569H4.25a.75.75 0 0 1-.75-.75V9.75a.75.75 0 0 1 .75-.75h3.688L13.5 14.56ZM13.5 4.807v5.511l1.5 1.5V4.25c0-1.079-1.274-1.65-2.08-.934l-3.4 3.022 1.063 1.063L13.5 4.807ZM17.141 13.96l1.138 1.137A6.974 6.974 0 0 0 19 12a6.973 6.973 0 0 0-.84-3.328.75.75 0 0 0-1.32.714c.42.777.66 1.666.66 2.614 0 .691-.127 1.351-.359 1.96ZM19.388 16.206l1.093 1.094A9.955 9.955 0 0 0 22 12a9.959 9.959 0 0 0-1.96-5.946.75.75 0 0 0-1.205.892A8.46 8.46 0 0 1 20.5 12a8.458 8.458 0 0 1-1.112 4.206Z"/></svg>',
  download: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.25 20.5a.75.75 0 1 1 0 1.5l-13 .004a.75.75 0 1 1 0-1.5l13-.004ZM11.648 2.012l.102-.007a.75.75 0 0 1 .743.648l.007.102-.001 13.685 3.722-3.72a.75.75 0 0 1 .976-.073l.085.073a.75.75 0 0 1 .072.976l-.073.084-4.997 4.997a.75.75 0 0 1-.976.073l-.085-.073-5.003-4.996a.75.75 0 0 1 .976-1.134l.084.072 3.719 3.714L11 2.755a.75.75 0 0 1 .648-.743l.102-.007-.102.007Z" fill="currentColor"/></svg>',
  full_screen_maximize: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.5 5.75c0-.69.56-1.25 1.25-1.25h2a.75.75 0 0 0 0-1.5h-2A2.75 2.75 0 0 0 3 5.75v2a.75.75 0 0 0 1.5 0v-2ZM4.5 18.25c0 .69.56 1.25 1.25 1.25h2a.75.75 0 0 1 0 1.5h-2A2.75 2.75 0 0 1 3 18.25v-2a.75.75 0 0 1 1.5 0v2ZM18.25 4.5c.69 0 1.25.56 1.25 1.25v2a.75.75 0 0 0 1.5 0v-2A2.75 2.75 0 0 0 18.25 3h-2a.75.75 0 0 0 0 1.5h2ZM19.5 18.25c0 .69-.56 1.25-1.25 1.25h-2a.75.75 0 0 0 0 1.5h2A2.75 2.75 0 0 0 21 18.25v-2a.75.75 0 0 0-1.5 0v2Z" fill="currentColor"/></svg>',
  full_screen_minimize: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.5 3.75a.75.75 0 0 0-1.5 0v2.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 0 0 1.5h2.5A2.25 2.25 0 0 0 8.5 6.25v-2.5ZM8.5 20.25a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 1 0-1.5h2.5a2.25 2.25 0 0 1 2.25 2.25v2.5ZM16.25 3a.75.75 0 0 0-.75.75v2.5a2.25 2.25 0 0 0 2.25 2.25h2.5a.75.75 0 0 0 0-1.5h-2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 0-.75-.75ZM15.5 20.25a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 0 0-1.5h-2.5a2.25 2.25 0 0 0-2.25 2.25v2.5Z" fill="currentColor"/></svg>',
  copy: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.503 4.627 5.5 6.75v10.504a3.25 3.25 0 0 0 3.25 3.25h8.616a2.251 2.251 0 0 1-2.122 1.5H8.75A4.75 4.75 0 0 1 4 17.254V6.75c0-.98.627-1.815 1.503-2.123ZM17.75 2A2.25 2.25 0 0 1 20 4.25v13a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-13A2.25 2.25 0 0 1 8.75 2h9Zm0 1.5h-9a.75.75 0 0 0-.75.75v13c0 .414.336.75.75.75h9a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75Z" fill="currentColor"/></svg>',
  attach: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.772 3.743a6 6 0 0 1 8.66 8.302l-.19.197-8.8 8.798-.036.03a3.723 3.723 0 0 1-5.489-4.973.764.764 0 0 1 .085-.13l.054-.06.086-.088.142-.148.002.003 7.436-7.454a.75.75 0 0 1 .977-.074l.084.073a.75.75 0 0 1 .074.976l-.073.084-7.594 7.613a2.23 2.23 0 0 0 3.174 3.106l8.832-8.83A4.502 4.502 0 0 0 13 4.644l-.168.16-.013.014-9.536 9.536a.75.75 0 0 1-1.133-.977l.072-.084 9.549-9.55h.002Z" fill="currentColor"/></svg>',
  image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116 5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" fill="currentColor"/></svg>',
  emoji_multiple: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.5 2a6.503 6.503 0 0 1 6.312 4.943c-.515.01-1.02.068-1.506.171a5 5 0 1 0-6.191 6.191 8.053 8.053 0 0 0-.172 1.507A6.5 6.5 0 0 1 8.5 2Zm.16 8.006c.355-.451.759-.864 1.202-1.23a3.5 3.5 0 0 0-4.022.95.75.75 0 1 0 1.14.974 2 2 0 0 1 1.68-.694ZM7.5 6.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm4 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm1 8a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm5.458 2.042a.75.75 0 0 1 .082 1.058 4 4 0 0 1-6.075.005.75.75 0 0 1 1.138-.977 2.499 2.499 0 0 0 3.797-.003.75.75 0 0 1 1.058-.083ZM17.5 14.5a1 1 0 1 0 0-2 1 1 0 0 0 0 2ZM15 22a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0-1.5a5.5 5.5 0 1 1 0-11 5.5 5.5 0 0 1 0 11Z" fill="currentColor"/></svg>',
  image_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06l1.263 1.264A3.235 3.235 0 0 0 3 6.25v11.5A3.25 3.25 0 0 0 6.25 21h11.5c.626 0 1.21-.177 1.706-.483l1.263 1.264a.75.75 0 0 0 1.061-1.061L3.28 2.22Zm8.788 10.909 6.206 6.206.056.066a1.746 1.746 0 0 1-.58.099H6.25c-.204 0-.4-.035-.582-.099l5.807-5.686.593-.586Zm-.95-.95a2.245 2.245 0 0 0-.692.464l-5.823 5.7a1.747 1.747 0 0 1-.103-.593V6.25c0-.206.036-.404.101-.588l6.518 6.518ZM19.5 16.318V6.25a1.75 1.75 0 0 0-1.75-1.75H7.682L6.182 3H17.75A3.25 3.25 0 0 1 21 6.25v11.568l-1.5-1.5Z" fill="currentColor"/><path d="M15.252 6.5a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" fill="currentColor"/></svg>',
  disconnected: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l3.364 3.365a11.99 11.99 0 0 0-2.033 1.634c-.49.489-.964 1.069-1.394 1.689a.75.75 0 1 0 1.233.855c.381-.55.8-1.062 1.222-1.484a10.468 10.468 0 0 1 2.063-1.604l1.591 1.592a8.062 8.062 0 0 0-1.923 1.424c-.61.61-1.109 1.3-1.491 2.056a.75.75 0 1 0 1.338.677 6.51 6.51 0 0 1 1.214-1.673 6.546 6.546 0 0 1 1.984-1.362l1.93 1.93a5.07 5.07 0 0 0-2.876 1.44 5.11 5.11 0 0 0-1.061 1.57.75.75 0 0 0 1.374.602c.185-.422.437-.8.747-1.111a3.59 3.59 0 0 1 3.36-.958l7.858 7.858a.75.75 0 0 0 1.06-1.06L3.28 2.22Zm8.304 6.182 1.584 1.584a6.532 6.532 0 0 1 3.516 1.825 6.798 6.798 0 0 1 1.217 1.692.75.75 0 1 0 1.336-.683 8.292 8.292 0 0 0-1.492-2.07 8.042 8.042 0 0 0-6.16-2.348ZM8.487 5.305 9.713 6.53a10.44 10.44 0 0 1 10.908 4.297.75.75 0 1 0 1.235-.852 11.946 11.946 0 0 0-13.369-4.67Zm4.573 11.134a1.5 1.5 0 1 1-2.121 2.122 1.5 1.5 0 0 1 2.121-2.122Z" fill="currentColor"/></svg>',
  wand: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m13.314 7.565-.136.126-10.48 10.488a2.27 2.27 0 0 0 3.211 3.208L16.388 10.9a2.251 2.251 0 0 0-.001-3.182l-.157-.146a2.25 2.25 0 0 0-2.916-.007Zm-.848 2.961 1.088 1.088-8.706 8.713a.77.77 0 1 1-1.089-1.088l8.707-8.713Zm4.386 4.48L16.75 15a.75.75 0 0 0-.743.648L16 15.75v.75h-.75a.75.75 0 0 0-.743.648l-.007.102c0 .38.282.694.648.743l.102.007H16v.75c0 .38.282.694.648.743l.102.007a.75.75 0 0 0 .743-.648l.007-.102V18h.75a.75.75 0 0 0 .743-.648L19 17.25a.75.75 0 0 0-.648-.743l-.102-.007h-.75v-.75a.75.75 0 0 0-.648-.743L16.75 15l.102.007Zm-1.553-6.254.027.027a.751.751 0 0 1 0 1.061l-.711.713-1.089-1.089.73-.73a.75.75 0 0 1 1.043.018ZM6.852 5.007 6.75 5a.75.75 0 0 0-.743.648L6 5.75v.75h-.75a.75.75 0 0 0-.743.648L4.5 7.25c0 .38.282.693.648.743L5.25 8H6v.75c0 .38.282.693.648.743l.102.007a.75.75 0 0 0 .743-.648L7.5 8.75V8h.75a.75.75 0 0 0 .743-.648L9 7.25a.75.75 0 0 0-.648-.743L8.25 6.5H7.5v-.75a.75.75 0 0 0-.648-.743L6.75 5l.102.007Zm12-2L18.75 3a.75.75 0 0 0-.743.648L18 3.75v.75h-.75a.75.75 0 0 0-.743.648l-.007.102c0 .38.282.693.648.743L17.25 6H18v.75c0 .38.282.693.648.743l.102.007a.75.75 0 0 0 .743-.648l.007-.102V6h.75a.75.75 0 0 0 .743-.648L21 5.25a.75.75 0 0 0-.648-.743L20.25 4.5h-.75v-.75a.75.75 0 0 0-.648-.743L18.75 3l.102.007Z" fill="currentColor"/></svg>',
  recording: '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z"/><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM3.5 12a8.5 8.5 0 1 1 17 0 8.5 8.5 0 0 1-17 0Z"/></svg>',
  subtract: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.755 12.5h16.492a.75.75 0 0 0 0-1.5H3.755a.75.75 0 0 0 0 1.5Z" fill="currentColor"/></svg>',
  stop_recording: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3.5C9.74566 3.5 7.58365 4.39553 5.98959 5.98959C4.39553 7.58365 3.5 9.74566 3.5 12C3.5 14.2543 4.39553 16.4163 5.98959 18.0104C7.58365 19.6045 9.74566 20.5 12 20.5C14.2543 20.5 16.4163 19.6045 18.0104 18.0104C19.6045 16.4163 20.5 14.2543 20.5 12C20.5 9.74566 19.6045 7.58365 18.0104 5.98959C16.4163 4.39553 14.2543 3.5 12 3.5ZM2 12C2 6.477 6.477 2 12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22C6.477 22 2 17.523 2 12ZM8 9.5C8 9.10218 8.15804 8.72064 8.43934 8.43934C8.72064 8.15804 9.10218 8 9.5 8H14.5C14.8978 8 15.2794 8.15804 15.5607 8.43934C15.842 8.72064 16 9.10218 16 9.5V14.5C16 14.8978 15.842 15.2794 15.5607 15.5607C15.2794 15.842 14.8978 16 14.5 16H9.5C9.10218 16 8.72064 15.842 8.43934 15.5607C8.15804 15.2794 8 14.8978 8 14.5V9.5Z" fill="currentColor"/></svg>',
  warning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.91 2.782a2.25 2.25 0 0 1 2.975.74l.083.138 7.759 14.009a2.25 2.25 0 0 1-1.814 3.334l-.154.006H4.243a2.25 2.25 0 0 1-2.041-3.197l.072-.143L10.031 3.66a2.25 2.25 0 0 1 .878-.878Zm9.505 15.613-7.76-14.008a.75.75 0 0 0-1.254-.088l-.057.088-7.757 14.008a.75.75 0 0 0 .561 1.108l.095.006h15.516a.75.75 0 0 0 .696-1.028l-.04-.086-7.76-14.008 7.76 14.008ZM12 16.002a.999.999 0 1 1 0 1.997.999.999 0 0 1 0-1.997ZM11.995 8.5a.75.75 0 0 1 .744.647l.007.102.004 4.502a.75.75 0 0 1-1.494.103l-.006-.102-.004-4.502a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
  pin: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>',
  pin_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l5.905 5.905L4.81 10.33a1.25 1.25 0 0 0-.476 2.065L7.439 15.5 3 19.94V21h1.06l4.44-4.44 3.105 3.105a1.25 1.25 0 0 0 2.065-.476l1.145-3.313 5.905 5.904a.75.75 0 0 0 1.06-1.06L3.28 2.22Zm10.355 12.476-1.252 3.626-6.705-6.705 3.626-1.252 4.331 4.331Zm6.048-3.876-3.787 1.894 1.118 1.118 3.34-1.67a2.75 2.75 0 0 0 .714-4.404l-4.825-4.826a2.75 2.75 0 0 0-4.405.715l-1.67 3.34 1.118 1.117 1.894-3.787a1.25 1.25 0 0 1 2.002-.325l4.826 4.826a1.25 1.25 0 0 1-.325 2.002Z" fill="currentColor"/></svg>',
  spinner: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" stroke-width="2" stroke="currentColor" stroke-opacity="0.2" vector-effect="non-scaling-stroke"/><path d="M22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7362 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"/></svg>',
  breakout_rooms: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.5 3a2.25 2.25 0 0 1 2.25 2.25v6h6A2.25 2.25 0 0 1 21 13.5v5.25A2.25 2.25 0 0 1 18.75 21H5.25A2.25 2.25 0 0 1 3 18.75V5.25A2.25 2.25 0 0 1 5.25 3h5.25Zm.75 9.75H4.5v6c0 .414.336.75.75.75h5.999l.001-6.75Zm7.5 0h-6.001v6.75h6.001a.75.75 0 0 0 .75-.75V13.5a.75.75 0 0 0-.75-.75ZM10.5 4.5H5.25a.75.75 0 0 0-.75.75v6h6.75v-6a.75.75 0 0 0-.75-.75Zm7.398-2.493L18 2a.75.75 0 0 1 .743.648l.007.102v2.5h2.5a.75.75 0 0 1 .743.648L22 6a.75.75 0 0 1-.648.743l-.102.007h-2.5v2.5a.75.75 0 0 1-.648.743L18 10a.75.75 0 0 1-.743-.648l-.007-.102v-2.5h-2.5a.75.75 0 0 1-.743-.648L14 6a.75.75 0 0 1 .648-.743l.102-.007h2.5v-2.5a.75.75 0 0 1 .648-.743Z" fill="currentColor"/></svg>',
  add: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 3a.75.75 0 0 1 .743.648l.007.102.001 7.25h7.253a.75.75 0 0 1 .102 1.493l-.102.007h-7.253l.002 7.25a.75.75 0 0 1-1.493.101l-.007-.102-.002-7.249H3.752a.75.75 0 0 1-.102-1.493L3.752 11h7.25L11 3.75a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
  shuffle: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M14.0058 8.11111H18.7947L16.9613 9.94444C16.9095 9.99587 16.8684 10.057 16.8402 10.1243C16.812 10.1917 16.7974 10.2639 16.7971 10.3369C16.7966 10.4843 16.8547 10.6259 16.9586 10.7306C17.01 10.7823 17.0711 10.8235 17.1385 10.8517C17.2058 10.8799 17.278 10.8945 17.351 10.8947C17.4985 10.8953 17.64 10.8372 17.7447 10.7333L20.8891 7.59999L20.4947 7.20555L17.7447 4.46111C17.64 4.35723 17.4985 4.29917 17.351 4.29969C17.2036 4.30021 17.0624 4.35927 16.9586 4.46388C16.8547 4.5685 16.7966 4.71009 16.7971 4.85751C16.7977 5.00494 16.8567 5.14612 16.9613 5.24999L18.728 6.99999H13.6669C13.5699 7.00058 13.4748 7.02653 13.391 7.07526C13.3072 7.12399 13.2376 7.19381 13.1891 7.27777L11.7224 9.82777L12.3669 10.9389L14.0058 8.11111Z" fill="currentColor"/><path d="M8.15022 15.9278H3.66688C3.51954 15.9278 3.37823 15.9863 3.27405 16.0905C3.16986 16.1947 3.11133 16.336 3.11133 16.4833C3.11133 16.6307 3.16986 16.772 3.27405 16.8762C3.37823 16.9804 3.51954 17.0389 3.66688 17.0389H8.47244C8.56939 17.0383 8.6645 17.0124 8.74832 16.9636C8.83214 16.9149 8.90174 16.8451 8.95022 16.7611L10.4335 14.2222L9.77799 13.1111L8.15022 15.9278Z"/><path d="M17.7447 13.2056C17.64 13.1017 17.4985 13.0436 17.351 13.0441C17.2036 13.0447 17.0624 13.1037 16.9586 13.2083C16.8547 13.3129 16.7966 13.4545 16.7971 13.602C16.7977 13.7494 16.8567 13.8906 16.9613 13.9944L18.9058 15.9389H14.0058L8.95022 7.29444C8.90174 7.21047 8.83214 7.14066 8.74832 7.09193C8.6645 7.04319 8.56939 7.01725 8.47244 7.01666H3.66688C3.51954 7.01666 3.37823 7.07519 3.27405 7.17938C3.16986 7.28357 3.11133 7.42487 3.11133 7.57222C3.11133 7.71956 3.16986 7.86087 3.27405 7.96505C3.37823 8.06924 3.51954 8.12777 3.66688 8.12777H8.15022L13.2058 16.7667C13.2542 16.8506 13.3239 16.9204 13.4077 16.9692C13.4915 17.0179 13.5866 17.0439 13.6836 17.0444H18.6113L16.9447 18.7111C16.8929 18.7625 16.8517 18.8237 16.8235 18.891C16.7954 18.9584 16.7807 19.0306 16.7805 19.1036C16.7802 19.1766 16.7943 19.2489 16.822 19.3165C16.8497 19.384 16.8905 19.4454 16.9419 19.4972C16.9933 19.549 17.0545 19.5902 17.1218 19.6184C17.1891 19.6465 17.2614 19.6612 17.3344 19.6614C17.4074 19.6617 17.4797 19.6476 17.5472 19.6199C17.6148 19.5922 17.6762 19.5514 17.728 19.5L20.478 16.7556L20.8724 16.3611L17.7447 13.2056Z"/></svg>',
  edit: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.03 2.97a3.578 3.578 0 0 1 0 5.06L9.062 20a2.25 2.25 0 0 1-.999.58l-5.116 1.395a.75.75 0 0 1-.92-.921l1.395-5.116a2.25 2.25 0 0 1 .58-.999L15.97 2.97a3.578 3.578 0 0 1 5.06 0ZM15 6.06 5.062 16a.75.75 0 0 0-.193.333l-1.05 3.85 3.85-1.05A.75.75 0 0 0 8 18.938L17.94 9 15 6.06Zm2.03-2.03-.97.97L19 7.94l.97-.97a2.079 2.079 0 0 0-2.94-2.94Z" fill="currentColor"/></svg>',
  delete: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.75a3.25 3.25 0 0 1 3.245 3.066L15.25 5h5.25a.75.75 0 0 1 .102 1.493L20.5 6.5h-.796l-1.28 13.02a2.75 2.75 0 0 1-2.561 2.474l-.176.006H8.313a2.75 2.75 0 0 1-2.714-2.307l-.023-.174L4.295 6.5H3.5a.75.75 0 0 1-.743-.648L2.75 5.75a.75.75 0 0 1 .648-.743L3.5 5h5.25A3.25 3.25 0 0 1 12 1.75Zm6.197 4.75H5.802l1.267 12.872a1.25 1.25 0 0 0 1.117 1.122l.127.006h7.374c.6 0 1.109-.425 1.225-1.002l.02-.126L18.196 6.5ZM13.75 9.25a.75.75 0 0 1 .743.648L14.5 10v7a.75.75 0 0 1-1.493.102L13 17v-7a.75.75 0 0 1 .75-.75Zm-3.5 0a.75.75 0 0 1 .743.648L11 10v7a.75.75 0 0 1-1.493.102L9.5 17v-7a.75.75 0 0 1 .75-.75Zm1.75-6a1.75 1.75 0 0 0-1.744 1.606L10.25 5h3.5A1.75 1.75 0 0 0 12 3.25Z" fill="currentColor"/></svg>',
  back: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.75 2a.75.75 0 0 1 .743.648l.007.102v5.69l4.574-4.56a6.41 6.41 0 0 1 8.879-.179l.186.18a6.41 6.41 0 0 1 0 9.063l-8.846 8.84a.75.75 0 0 1-1.06-1.062l8.845-8.838a4.91 4.91 0 0 0-6.766-7.112l-.178.17L6.562 9.5h5.688a.75.75 0 0 1 .743.648l.007.102a.75.75 0 0 1-.648.743L12.25 11h-7.5a.75.75 0 0 1-.743-.648L4 10.25v-7.5A.75.75 0 0 1 4.75 2Z" fill="currentColor"/></svg>',
  save: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.75A2.75 2.75 0 0 1 5.75 3h9.964a3.25 3.25 0 0 1 2.299.952l2.035 2.035c.61.61.952 1.437.952 2.299v9.964A2.75 2.75 0 0 1 18.25 21H5.75A2.75 2.75 0 0 1 3 18.25V5.75ZM5.75 4.5c-.69 0-1.25.56-1.25 1.25v12.5c0 .69.56 1.25 1.25 1.25H6v-5.25A2.25 2.25 0 0 1 8.25 12h7.5A2.25 2.25 0 0 1 18 14.25v5.25h.25c.69 0 1.25-.56 1.25-1.25V8.286c0-.465-.184-.91-.513-1.238l-2.035-2.035a1.75 1.75 0 0 0-.952-.49V7.25a2.25 2.25 0 0 1-2.25 2.25h-4.5A2.25 2.25 0 0 1 7 7.25V4.5H5.75Zm10.75 15v-5.25a.75.75 0 0 0-.75-.75h-7.5a.75.75 0 0 0-.75.75v5.25h9Zm-8-15v2.75c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75V4.5h-6Z" fill="currentColor"/></svg>',
  web: '<svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.999c5.524 0 10.002 4.478 10.002 10.002 0 5.523-4.478 10.001-10.002 10.001-5.524 0-10.002-4.478-10.002-10.001C1.998 6.477 6.476 1.999 12 1.999ZM14.939 16.5H9.06c.652 2.414 1.786 4.002 2.939 4.002s2.287-1.588 2.939-4.002Zm-7.43 0H4.785a8.532 8.532 0 0 0 4.094 3.411c-.522-.82-.953-1.846-1.27-3.015l-.102-.395Zm11.705 0h-2.722c-.324 1.335-.792 2.5-1.373 3.411a8.528 8.528 0 0 0 3.91-3.127l.185-.283ZM7.094 10H3.735l-.005.017a8.525 8.525 0 0 0-.233 1.984c0 1.056.193 2.067.545 3h3.173a20.847 20.847 0 0 1-.123-5Zm8.303 0H8.603a18.966 18.966 0 0 0 .135 5h6.524a18.974 18.974 0 0 0 .135-5Zm4.868 0h-3.358c.062.647.095 1.317.095 2a20.3 20.3 0 0 1-.218 3h3.173a8.482 8.482 0 0 0 .544-3c0-.689-.082-1.36-.236-2ZM8.88 4.09l-.023.008A8.531 8.531 0 0 0 4.25 8.5h3.048c.314-1.752.86-3.278 1.583-4.41ZM12 3.499l-.116.005C10.62 3.62 9.396 5.622 8.83 8.5h6.342c-.566-2.87-1.783-4.869-3.045-4.995L12 3.5Zm3.12.59.107.175c.669 1.112 1.177 2.572 1.475 4.237h3.048a8.533 8.533 0 0 0-4.339-4.29l-.291-.121Z" fill="currentColor"/></svg>',
  checkmark: '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="m18 6.7-8.48 8.48-3.54-3.54a.996.996 0 1 0-1.41 1.41l4.24 4.24c.39.39 1.02.39 1.41 0l9.18-9.18a.999.999 0 0 0-.01-1.42c-.37-.38-1-.38-1.39.01z"/></svg>',
  spotlight: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.745 4C20.3417 4 20.914 4.23705 21.336 4.65901C21.7579 5.08097 21.995 5.65326 21.995 6.25V12.805C21.5485 12.3774 21.0434 12.0154 20.495 11.73V6.25C20.495 6.05109 20.416 5.86032 20.2753 5.71967C20.1347 5.57902 19.9439 5.5 19.745 5.5H4.25C4.05109 5.5 3.86032 5.57902 3.71967 5.71967C3.57902 5.86032 3.5 6.05109 3.5 6.25V17.755C3.5 18.169 3.836 18.505 4.25 18.505L6.999 18.504L7 15.75C7.00002 15.3108 7.16517 14.8877 7.46268 14.5646C7.76019 14.2415 8.1683 14.0421 8.606 14.006L8.75 14H12.022C11.7223 14.4675 11.484 14.9716 11.313 15.5H8.75C8.69368 15.5001 8.63904 15.5192 8.59493 15.5542C8.55083 15.5893 8.51984 15.6382 8.507 15.693L8.5 15.75L8.499 18.504H11.077C11.1569 19.0193 11.2989 19.5229 11.5 20.004H4.25C3.65344 20.004 3.08129 19.7671 2.65936 19.3453C2.23744 18.9236 2.00027 18.3516 2 17.755V6.25C2 5.65326 2.23705 5.08097 2.65901 4.65901C3.08097 4.23705 3.65326 4 4.25 4H19.745Z"/><path d="M12 7C12.7956 7 13.5587 7.31607 14.1213 7.87868C14.6839 8.44129 15 9.20435 15 10C15 10.7956 14.6839 11.5587 14.1213 12.1213C13.5587 12.6839 12.7956 13 12 13C11.2044 13 10.4413 12.6839 9.87868 12.1213C9.31607 11.5587 9 10.7956 9 10C9 9.20435 9.31607 8.44129 9.87868 7.87868C10.4413 7.31607 11.2044 7 12 7ZM12 8.5C11.6022 8.5 11.2206 8.65804 10.9393 8.93934C10.658 9.22064 10.5 9.60218 10.5 10C10.5 10.3978 10.658 10.7794 10.9393 11.0607C11.2206 11.342 11.6022 11.5 12 11.5C12.3978 11.5 12.7794 11.342 13.0607 11.0607C13.342 10.7794 13.5 10.3978 13.5 10C13.5 9.60218 13.342 9.22064 13.0607 8.93934C12.7794 8.65804 12.3978 8.5 12 8.5Z"/><path d="M23 17.5C23 18.9587 22.4205 20.3576 21.3891 21.3891C20.3576 22.4205 18.9587 23 17.5 23C16.0413 23 14.6424 22.4205 13.6109 21.3891C12.5795 20.3576 12 18.9587 12 17.5C12 16.0413 12.5795 14.6424 13.6109 13.6109C14.6424 12.5795 16.0413 12 17.5 12C18.9587 12 20.3576 12.5795 21.3891 13.6109C22.4205 14.6424 23 16.0413 23 17.5ZM18.055 14.42C18.0207 14.2993 17.9479 14.193 17.8478 14.1174C17.7476 14.0417 17.6255 14.0008 17.5 14.0008C17.3745 14.0008 17.2524 14.0417 17.1522 14.1174C17.0521 14.193 16.9793 14.2993 16.945 14.42L16.388 16.208H14.585C14.019 16.208 13.785 16.962 14.242 17.308L15.7 18.413L15.143 20.2C14.968 20.761 15.584 21.228 16.042 20.881L17.5 19.777L18.958 20.881C19.416 21.228 20.032 20.761 19.857 20.201L19.3 18.413L20.758 17.309C21.216 16.962 20.981 16.208 20.415 16.208H18.612L18.055 14.421V14.42Z"/></svg>',
  join_stage: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M17.5 22C14.4618 22 12 19.5376 12 16.5C12 13.4623 14.4618 11 17.5 11C20.5371 11 23 13.4624 23 16.5C23 19.5376 20.5371 22 17.5 22ZM17.0704 18.992L17.1167 19.0322C17.1868 19.0841 17.2716 19.1125 17.3588 19.1132C17.4461 19.1139 17.5314 19.0869 17.6023 19.036L17.654 18.992L17.6936 18.9458C17.7455 18.8757 17.7739 18.7909 17.7746 18.7037C17.7753 18.6164 17.7483 18.5311 17.6975 18.4602L17.6535 18.4085L16.158 16.9125H19.8375L19.8936 16.9092C19.9829 16.8969 20.0657 16.8558 20.1293 16.792C20.193 16.7282 20.234 16.6454 20.2462 16.5561L20.25 16.5005L20.2462 16.4444C20.2339 16.3553 20.1928 16.2725 20.1292 16.2089C20.0655 16.1452 19.9828 16.1041 19.8936 16.0919L19.8375 16.088H16.158L17.654 14.592L17.6941 14.5453C17.7537 14.4659 17.7827 14.3676 17.7756 14.2686C17.7686 14.1695 17.726 14.0763 17.6558 14.0061C17.5856 13.9359 17.4924 13.8934 17.3934 13.8863C17.2943 13.8793 17.1961 13.9082 17.1167 13.9678L17.071 14.0079L14.8699 16.2079L14.8303 16.2547C14.7784 16.3247 14.75 16.4094 14.7493 16.4965C14.7485 16.5837 14.7753 16.6688 14.8259 16.7398L14.8699 16.7915L17.0704 18.992Z"/><path d="M2.80546 3.80546C2.28973 4.32118 2 5.02065 2 5.75V16.25C2 16.6111 2.07113 16.9687 2.20933 17.3024C2.34753 17.636 2.5501 17.9392 2.80546 18.1945C3.06082 18.4499 3.36398 18.6525 3.69762 18.7907C4.03127 18.9289 4.38886 19 4.75 19H11.498C11.3 18.526 11.157 18.023 11.076 17.5H9.002V14.75C9.002 14.6837 9.02834 14.6201 9.07522 14.5732C9.12211 14.5263 9.1857 14.5 9.252 14.5H11.3135C11.4858 13.9665 11.7253 13.4632 12.0218 13H9.252C8.285 13 7.502 13.784 7.502 14.75V16H7.5V17.5H4.75C4.06 17.5 3.5 16.94 3.5 16.25V5.75C3.5 5.06 4.06 4.5 4.75 4.5H19.25C19.94 4.5 20.5 5.06 20.5 5.75V10.732C20.6457 10.808 20.7884 10.8895 20.9277 10.9762C20.9687 11.0017 21.0093 11.0276 21.0497 11.054C21.3899 11.2762 21.708 11.5294 22 11.8096V5.75C22 5.02065 21.7103 4.32118 21.1945 3.80546C20.6788 3.28973 19.9793 3 19.25 3H4.75C4.02065 3 3.32118 3.28973 2.80546 3.80546Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.4181 10.7757C14.7938 10.264 15 9.64262 15 9C15 8.20435 14.6839 7.44129 14.1213 6.87868C13.5587 6.31607 12.7956 6 12 6C11.2044 6 10.4413 6.31607 9.87868 6.87868C9.31607 7.44129 9 8.20435 9 9C9 9.79565 9.31607 10.5587 9.87868 11.1213C10.4413 11.6839 11.2044 12 12 12C12.333 12 12.6602 11.9446 12.9695 11.839C13.3992 11.4213 13.8864 11.0625 14.4181 10.7757ZM10.9393 7.93934C11.2206 7.65804 11.6022 7.5 12 7.5C12.3978 7.5 12.7794 7.65804 13.0607 7.93934C13.342 8.22064 13.5 8.60218 13.5 9C13.5 9.39782 13.342 9.77936 13.0607 10.0607C12.7794 10.342 12.3978 10.5 12 10.5C11.6022 10.5 11.2206 10.342 10.9393 10.0607C10.658 9.77936 10.5 9.39782 10.5 9C10.5 8.60218 10.658 8.22064 10.9393 7.93934Z"></svg>',
  leave_stage: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.80546 3.80546C2.28973 4.32118 2 5.02065 2 5.75V16.25C2 16.6111 2.07113 16.9687 2.20933 17.3024C2.34753 17.636 2.5501 17.9392 2.80546 18.1945C3.06082 18.4499 3.36398 18.6525 3.69762 18.7907C4.03127 18.9289 4.38886 19 4.75 19H11.498C11.3 18.526 11.157 18.023 11.076 17.5H9.002V14.75C9.002 14.6837 9.02834 14.6201 9.07522 14.5732C9.12211 14.5263 9.1857 14.5 9.252 14.5H11.3135C11.4858 13.9665 11.7253 13.4632 12.0218 13H9.252C8.285 13 7.502 13.784 7.502 14.75V16H7.5V17.5H4.75C4.06 17.5 3.5 16.94 3.5 16.25V5.75C3.5 5.06 4.06 4.5 4.75 4.5H19.25C19.94 4.5 20.5 5.06 20.5 5.75V10.732C20.6457 10.808 20.7884 10.8895 20.9277 10.9762C20.9687 11.0017 21.0093 11.0276 21.0497 11.054C21.3899 11.2762 21.708 11.5294 22 11.8096V5.75C22 5.02065 21.7103 4.32118 21.1945 3.80546C20.6788 3.28973 19.9793 3 19.25 3H4.75C4.02065 3 3.32118 3.28973 2.80546 3.80546Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.4181 10.7757C14.7938 10.264 15 9.64262 15 9C15 8.20435 14.6839 7.44129 14.1213 6.87868C13.5587 6.31607 12.7956 6 12 6C11.2044 6 10.4413 6.31607 9.87868 6.87868C9.31607 7.44129 9 8.20435 9 9C9 9.79565 9.31607 10.5587 9.87868 11.1213C10.4413 11.6839 11.2044 12 12 12C12.333 12 12.6602 11.9446 12.9695 11.839C13.3992 11.4213 13.8864 11.0625 14.4181 10.7757ZM10.9393 7.93934C11.2206 7.65804 11.6022 7.5 12 7.5C12.3978 7.5 12.7794 7.65804 13.0607 7.93934C13.342 8.22064 13.5 8.60218 13.5 9C13.5 9.39782 13.342 9.77936 13.0607 10.0607C12.7794 10.342 12.3978 10.5 12 10.5C11.6022 10.5 11.2206 10.342 10.9393 10.0607C10.658 9.77936 10.5 9.39782 10.5 9C10.5 8.60218 10.658 8.22064 10.9393 7.93934Z"/><path d="M17.5 11C20.5382 11 23 13.4624 23 16.5C23 19.5377 20.5382 22 17.5 22C14.4629 22 12 19.5377 12 16.5C12 13.4624 14.4629 11 17.5 11V11ZM17.9296 14.0079L17.8833 13.9678C17.8132 13.9159 17.7284 13.8875 17.6412 13.8868C17.5539 13.8861 17.4686 13.9131 17.3977 13.964L17.346 14.0079L17.3064 14.0542C17.2545 14.1243 17.2261 14.2091 17.2254 14.2963C17.2247 14.3836 17.2517 14.4689 17.3026 14.5398L17.3465 14.5915L18.842 16.0875H15.1625L15.1064 16.0908C15.0171 16.1031 14.9343 16.1442 14.8707 16.208C14.807 16.2718 14.766 16.3546 14.7539 16.4439L14.75 16.4995L14.7539 16.5556C14.7661 16.6447 14.8072 16.7275 14.8708 16.7911C14.9345 16.8548 15.0172 16.8959 15.1064 16.9081L15.1625 16.912H18.842L17.346 18.408L17.3059 18.4547C17.2463 18.5341 17.2173 18.6324 17.2244 18.7314C17.2314 18.8305 17.274 18.9237 17.3442 18.9939C17.4144 19.0641 17.5076 19.1066 17.6066 19.1137C17.7057 19.1207 17.8039 19.0918 17.8833 19.0322L17.929 18.9921L20.1301 16.7921L20.1697 16.7453C20.2216 16.6753 20.25 16.5906 20.2507 16.5035C20.2515 16.4163 20.2247 16.3312 20.1741 16.2602L20.1301 16.2085L17.9301 14.0079L17.8833 13.9678L17.9296 14.0079V14.0079Z"/></svg>',
  pip_off: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.8666 12.3058C11.0731 12.3058 11.2404 12.1385 11.2404 11.932V8.56753C11.2404 8.36107 11.0731 8.1937 10.8666 8.1937C10.6601 8.1937 10.4928 8.36107 10.4928 8.56753V11.0295L6.45393 6.99066C6.30794 6.84467 6.07124 6.84467 5.92525 6.99066C5.77926 7.13665 5.77926 7.37335 5.92525 7.51934L9.9641 11.5582L7.50212 11.5582C7.29566 11.5582 7.12829 11.7256 7.12829 11.932C7.12829 12.1385 7.29566 12.3058 7.50212 12.3058L10.8666 12.3058ZM5.73832 19.8879C3.6737 19.8879 2 18.2141 2 16.1495V7.73832C2 5.6737 3.6737 4 5.73832 4H18.2617C20.3263 4 22 5.6737 22 7.73832L22 13.0269C22 12.2687 21.6002 11.6038 21 11.2316C20.8468 11.1366 20.6806 11.0607 20.5047 11.0071V7.73832C20.5047 6.49955 19.5005 5.49533 18.2617 5.49533H5.73832C4.49955 5.49533 3.49533 6.49955 3.49533 7.73832V16.1495C3.49533 17.3883 4.49955 18.3925 5.73832 18.3925H10.7971C10.8506 18.5685 10.9266 18.7347 11.0216 18.8879C11.3938 19.4881 12.0587 19.8879 12.8169 19.8879H5.73832Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19.7265 12.5H13.3911C12.899 12.5 12.5 12.899 12.5 13.3911V17.6462C12.5 18.1384 12.899 18.5374 13.3911 18.5374H19.7265C20.2187 18.5374 20.6176 18.1384 20.6176 17.6462V13.3911C20.6176 12.899 20.2187 12.5 19.7265 12.5ZM13.3911 11.5C12.3467 11.5 11.5 12.3467 11.5 13.3911V17.6462C11.5 18.6907 12.3467 19.5374 13.3911 19.5374H19.7265C20.771 19.5374 21.6176 18.6907 21.6176 17.6462V13.3911C21.6176 12.3467 20.771 11.5 19.7265 11.5H13.3911Z"/></svg>',
  pip_on: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.73832 19.8879C3.6737 19.8879 2 18.2141 2 16.1495V7.73832C2 5.6737 3.6737 4 5.73832 4H18.2617C20.3263 4 22 5.6737 22 7.73832L22 13.0269C22 12.2687 21.6002 11.6038 21 11.2316C20.8468 11.1366 20.6806 11.0607 20.5047 11.0071V7.73832C20.5047 6.49955 19.5005 5.49533 18.2617 5.49533H5.73832C4.49955 5.49533 3.49533 6.49955 3.49533 7.73832V16.1495C3.49533 17.3883 4.49955 18.3925 5.73832 18.3925H10.7971C10.8506 18.5685 10.9266 18.7347 11.0216 18.8879C11.3938 19.4881 12.0587 19.8879 12.8169 19.8879H5.73832Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19.7265 12.5H13.3911C12.899 12.5 12.5 12.899 12.5 13.3911V17.6462C12.5 18.1384 12.899 18.5374 13.3911 18.5374H19.7265C20.2187 18.5374 20.6176 18.1384 20.6176 17.6462V13.3911C20.6176 12.899 20.2187 12.5 19.7265 12.5ZM13.3911 11.5C12.3467 11.5 11.5 12.3467 11.5 13.3911V17.6462C11.5 18.6907 12.3467 19.5374 13.3911 19.5374H19.7265C20.771 19.5374 21.6176 18.6907 21.6176 17.6462V13.3911C21.6176 12.3467 20.771 11.5 19.7265 11.5H13.3911Z"/><path d="M6.18951 6.88123C5.98304 6.88123 5.81567 7.0486 5.81567 7.25506V10.6195C5.81567 10.826 5.98304 10.9934 6.18951 10.9934C6.39597 10.9934 6.56334 10.826 6.56334 10.6195V8.15757L10.6022 12.1964C10.7482 12.3424 10.9849 12.3424 11.1309 12.1964C11.2769 12.0504 11.2769 11.8137 11.1309 11.6677L7.09202 7.62889L9.55399 7.62889C9.76045 7.62889 9.92782 7.46152 9.92782 7.25506C9.92782 7.0486 9.76045 6.88123 9.55399 6.88123L6.18951 6.88123Z"/></svg>',
  signal_1: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3z"></path></svg>',
  signal_2: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7z"></path></svg>',
  signal_3: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2z"></path></svg>',
  signal_4: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2zm4-3h2v14h-2z"></path></svg>',
  signal_5: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2zm4-3h2v14h-2zm4-3h2v17h-2z"></path></svg>',
  start_livestream: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M6.343 4.938a1 1 0 0 1 0 1.415a8.003 8.003 0 0 0 0 11.317a1 1 0 1 1-1.415 1.414c-3.906-3.906-3.906-10.24 0-14.146a1 1 0 0 1 1.415 0Zm12.731 0c3.906 3.907 3.906 10.24 0 14.146a1 1 0 0 1-1.414-1.414a8.003 8.003 0 0 0 0-11.317a1 1 0 0 1 1.414-1.415ZM9.31 7.812a1 1 0 0 1 0 1.414a3.92 3.92 0 0 0 0 5.544a1 1 0 1 1-1.414 1.414a5.92 5.92 0 0 1 0-8.372a1 1 0 0 1 1.414 0Zm6.959 0a5.92 5.92 0 0 1 0 8.372a1 1 0 0 1-1.415-1.414a3.92 3.92 0 0 0 0-5.544a1 1 0 0 1 1.415-1.414Zm-4.187 2.77a1.5 1.5 0 1 1 0 3a1.5 1.5 0 0 1 0-3Z"/></svg>',
  stop_livestream: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill="currentColor" d="M2.854 2.146a.5.5 0 1 0-.708.708l1.811 1.81A8.218 8.218 0 0 0 2 10a8.228 8.228 0 0 0 2.604 6.015a.725.725 0 0 0 1.01-.025c.316-.316.277-.819-.027-1.11A6.73 6.73 0 0 1 3.5 10c0-1.62.57-3.107 1.522-4.27l.712.71A5.726 5.726 0 0 0 4.5 10c0 1.691.73 3.213 1.893 4.264a.713.713 0 0 0 .983-.037c.328-.328.267-.844-.041-1.134A4.238 4.238 0 0 1 6 10c0-.93.298-1.789.804-2.489l1.842 1.842a1.5 1.5 0 0 0 2 2l6.5 6.5a.5.5 0 0 0 .708-.707l-1.811-1.81l-1.065-1.066l-.712-.71l-1.07-1.072l-1.842-1.841l-2-2L7.4 6.693l-.942-.942l-.82-.82l-.944-.944l-1.841-1.842Zm13.794 12.38A8.212 8.212 0 0 0 18 10c0-2.283-.928-4.35-2.426-5.843a.726.726 0 0 0-1.027.01c-.31.31-.28.8.01 1.095A6.727 6.727 0 0 1 16.5 10a6.718 6.718 0 0 1-.94 3.438l1.088 1.089Zm-1.822-1.822A5.73 5.73 0 0 0 15.5 10a5.733 5.733 0 0 0-1.706-4.087a.714.714 0 0 0-1.008.016c-.319.318-.272.816.014 1.111A4.235 4.235 0 0 1 14 10c0 .557-.107 1.09-.302 1.577l1.128 1.127Z"/></svg>',
  viewers: '<svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 9.005a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5ZM12 5.5c4.613 0 8.596 3.15 9.701 7.564a.75.75 0 1 1-1.455.365 8.503 8.503 0 0 0-16.493.004.75.75 0 0 1-1.455-.363A10.003 10.003 0 0 1 12 5.5Z" fill="currentColor"/></svg>',
  debug: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m10.05 15.42 6.256-8.476a.694.694 0 0 1 1.235.57l-.03.098-3.87 9.8a2.07 2.07 0 1 1-3.737-1.766l.069-.115.076-.11 6.257-8.477-6.257 8.476Zm2.05-4.549-1.226 1.66a3.32 3.32 0 0 0-2.29 3.024.75.75 0 0 1-1.5-.063A4.819 4.819 0 0 1 9.14 11.74c.9-.631 1.942-.911 2.961-.87Zm4.167 2.752c.28.586.436 1.22.463 1.866a.75.75 0 0 1-1.376.444l.913-2.31Zm-2.233-5.37-.969 1.311a6.22 6.22 0 0 0-4.736 1.02 6.208 6.208 0 0 0-2.419 3.39.75.75 0 0 1-1.442-.412 7.708 7.708 0 0 1 3-4.207 7.724 7.724 0 0 1 6.566-1.102Zm3.51 2.138c.25.267.486.556.702.865a7.727 7.727 0 0 1 1.097 2.288.75.75 0 0 1-1.44.417 6.23 6.23 0 0 0-.885-1.845l-.102-.138.627-1.587ZM15.98 5.852l-.088.054c-.123.082-.236.18-.337.295l-.096.12-.54.732a9.138 9.138 0 0 0-8.261 1.146A9.103 9.103 0 0 0 3.38 12.37a.75.75 0 1 1-1.398-.543A10.603 10.603 0 0 1 5.799 6.97 10.642 10.642 0 0 1 15.98 5.852Zm2.629 1.562a10.646 10.646 0 0 1 2.022 2.171c.49.702.892 1.451 1.199 2.235a.75.75 0 1 1-1.397.547 9.188 9.188 0 0 0-2.327-3.405l.381-.964c.076-.19.115-.388.122-.584Z" fill="currentColor"/></svg>',
  info: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.999c5.524 0 10.002 4.478 10.002 10.002 0 5.523-4.478 10.001-10.002 10.001-5.524 0-10.002-4.478-10.002-10.001C1.998 6.477 6.476 1.999 12 1.999Zm0 1.5a8.502 8.502 0 1 0 0 17.003A8.502 8.502 0 0 0 12 3.5Zm-.004 7a.75.75 0 0 1 .744.648l.007.102.003 5.502a.75.75 0 0 1-1.493.102l-.007-.101-.003-5.502a.75.75 0 0 1 .75-.75ZM12 7.003a.999.999 0 1 1 0 1.997.999.999 0 0 1 0-1.997Z" fill="currentColor"/></svg>',
  devices: '<svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm5.5-8.5V9a5.5 5.5 0 1 0-11 0v1H9a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H6.5v.25a2.25 2.25 0 0 0 2.096 2.245l.154.005h1.128a2.251 2.251 0 1 1 0 1.5H8.75a3.75 3.75 0 0 1-3.745-3.55L5 16.25V9a7 7 0 0 1 14 0v5a2 2 0 0 1-1.85 1.995L17 16h-2a1 1 0 0 1-.993-.883L14 15v-4a1 1 0 0 1 .883-.993L15 10h2.5Zm-9 1.5h-2v3h2v-3Zm9 0h-2v3H17a.5.5 0 0 0 .492-.41L17.5 14v-2.5Z" fill="currentColor"/></svg>',
  horizontal_dots: '<svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0ZM14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0ZM18 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill="currentColor"/></svg>',
  ai_sparkle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 49 48" fill="none"><path fill="#F13E1B" d="m30.023 15.96.07.016a1.362 1.362 0 0 1 .657 2.068c-.163.23-.392.403-.658.497l-3.444 1.118a7.095 7.095 0 0 0-4.495 4.492l-1.12 3.442a1.357 1.357 0 0 1-1.267.907h-.016a1.361 1.361 0 0 1-1.283-.907l-1.12-3.442a7.091 7.091 0 0 0-4.495-4.509l-3.444-1.119a1.36 1.36 0 0 1 0-2.564l3.444-1.118a7.097 7.097 0 0 0 4.427-4.492l1.119-3.442a1.36 1.36 0 0 1 2.566 0l1.12 3.442a7.09 7.09 0 0 0 4.495 4.492l3.444 1.118Zm9.195 16.007-2.755-.894a5.678 5.678 0 0 1-3.596-3.594l-.896-2.753a1.087 1.087 0 0 0-2.053 0l-.895 2.753a5.672 5.672 0 0 1-3.541 3.594l-2.756.894a1.088 1.088 0 0 0 0 2.052l2.756.895a5.675 5.675 0 0 1 3.596 3.607l.896 2.753a1.088 1.088 0 0 0 2.052 0l.896-2.753a5.672 5.672 0 0 1 3.596-3.594l2.756-.894a1.088 1.088 0 0 0 0-2.052l-.056-.014Z"/><path fill="#2160FD" d="m39.218 31.967-2.755-.894a5.677 5.677 0 0 1-3.596-3.594l-.896-2.753a1.087 1.087 0 0 0-2.053 0l-.895 2.753a5.672 5.672 0 0 1-3.541 3.594l-2.756.894a1.088 1.088 0 0 0 0 2.052l2.756.895a5.675 5.675 0 0 1 3.596 3.607l.896 2.753a1.088 1.088 0 0 0 2.052 0l.896-2.753a5.672 5.672 0 0 1 3.596-3.594l2.756-.894a1.088 1.088 0 0 0 0-2.052l-.056-.014Z"/></svg>',
  meeting_ai: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" fill="none"><path fill="#F13E1B" d="M9.111 12.888a4.98 4.98 0 0 0-1.075-.8l-.04.048a4.651 4.651 0 0 0-.903-.424l-2.446-.8a.963.963 0 0 1-.467-.356.953.953 0 0 1 0-1.116.955.955 0 0 1 .467-.352l2.446-.8A5.088 5.088 0 0 0 9.04 7.06a5.048 5.048 0 0 0 1.2-1.904l.02-.064.799-2.444A.97.97 0 0 1 11.969 2a.97.97 0 0 1 .91.648l.8 2.444a5.147 5.147 0 0 0 1.219 1.976 5.042 5.042 0 0 0 1.974 1.2l2.45.8h.048c.188.067.351.19.468.352.115.164.176.36.175.56.001.2-.06.396-.175.56a1 1 0 0 1-.468.352l-2.446.8a5.067 5.067 0 0 0-1.978 1.2 5.096 5.096 0 0 0-1.199 1.976l-.8 2.448-.023.06a1.02 1.02 0 0 1-.184.284.967.967 0 0 1-.703.3 1 1 0 0 1-.927-.644l-.8-2.448a5.11 5.11 0 0 0-.799-1.508 5.16 5.16 0 0 0-.4-.472Zm10.434 5.396a.492.492 0 0 1 .176-.236.473.473 0 0 1 .1-.048.466.466 0 0 1 .168-.04c.1 0 .197.031.28.088l.091.072a.456.456 0 0 1 .096.164l.4 1.224c.124.372.332.71.607.988.278.276.616.484.987.608l1.223.4h.028l.084.04a.536.536 0 0 1 .148.136c.056.082.087.18.088.28a.484.484 0 0 1-.32.456l-1.227.4a2.528 2.528 0 0 0-1.595 1.6l-.399 1.224a.46.46 0 0 1-.176.232.464.464 0 0 1-.28.088.475.475 0 0 1-.455-.32l-.4-1.224a2.507 2.507 0 0 0-.611-.992 2.487 2.487 0 0 0-.987-.612l-1.223-.4a.48.48 0 0 1 0-.908l1.223-.4c.367-.128.7-.337.975-.612.137-.142.257-.3.36-.468.1-.162.18-.335.24-.516l.399-1.224Z"/><path fill="currentColor" d="M19.545 18.284a.492.492 0 0 1 .176-.236.469.469 0 0 1 .1-.048.466.466 0 0 1 .168-.04c.1 0 .197.031.28.088l.091.072a.456.456 0 0 1 .096.164l.4 1.224c.124.372.332.71.607.988.279.276.616.484.988.608l1.222.4h.028l.084.04a.534.534 0 0 1 .148.136c.057.082.087.18.088.28a.484.484 0 0 1-.32.456l-1.227.4a2.528 2.528 0 0 0-1.595 1.6l-.399 1.224a.46.46 0 0 1-.175.232.464.464 0 0 1-.28.088.475.475 0 0 1-.456-.32l-.4-1.224a2.509 2.509 0 0 0-.61-.992 2.487 2.487 0 0 0-.988-.612l-1.223-.4a.48.48 0 0 1 0-.908l1.223-.4c.367-.128.7-.337.975-.612a2.7 2.7 0 0 0 .36-.468c.1-.162.18-.335.24-.516l.4-1.224Z"/></svg>',
  create_channel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path fill="currentColor" d="M2 14.75A3.25 3.25 0 0 0 5.25 18H6v2.75a1.25 1.25 0 0 0 1.999 1l2.125-1.59.396-1.583c.071-.286.177-.56.312-.82L7.5 20.252 7.499 16.5H5.25a1.75 1.75 0 0 1-1.75-1.75v-8.5c0-.966.784-1.75 1.75-1.75h13.5c.966 0 1.75.784 1.75 1.75v3.845a3.27 3.27 0 0 1 1.5.83V6.25A3.25 3.25 0 0 0 18.75 3H5.25A3.25 3.25 0 0 0 2 6.25v8.5Z"/><path fill="currentColor" d="m18.098 11.67-5.902 5.902a2.684 2.684 0 0 0-.707 1.247l-.458 1.831a1.087 1.087 0 0 0 1.319 1.318l1.83-.457a2.685 2.685 0 0 0 1.248-.707l5.902-5.902a2.285 2.285 0 1 0-3.232-3.232Z"/></svg>',
  create_channel_illustration: '<svg width="503" height="362" viewBox="0 0 503 362" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M93.3477 192.893C93.3477 190.684 95.1385 188.893 97.3477 188.893H476C478.209 188.893 480 190.684 480 192.893V311.824C480 314.033 478.209 315.824 476 315.824H469.354C467.145 315.824 465.354 317.615 465.354 319.824V339.364C465.354 342.928 461.045 344.712 458.525 342.193L433.328 316.996C432.578 316.245 431.561 315.824 430.5 315.824H97.3477C95.1385 315.824 93.3477 314.033 93.3477 311.824V192.893Z" fill="#282828"/> <path d="M306.606 230.9H136.121C134.648 230.9 133.453 232.095 133.453 233.568C133.453 235.041 134.648 236.236 136.121 236.236H306.606C308.079 236.236 309.274 235.041 309.274 233.568C309.274 232.095 308.079 230.9 306.606 230.9Z" fill="#2160FD"/> <path d="M437.226 249.358H136.121C134.648 249.358 133.453 250.553 133.453 252.026C133.453 253.499 134.648 254.694 136.121 254.694H437.226C438.7 254.694 439.894 253.499 439.894 252.026C439.894 250.553 438.7 249.358 437.226 249.358Z" fill="#5C5C5C"/> <path d="M436.926 267.816H136.121C134.648 267.816 133.453 269.011 133.453 270.484C133.453 271.957 134.648 273.152 136.121 273.152H436.926C438.4 273.152 439.594 271.957 439.594 270.484C439.594 269.011 438.399 267.816 436.926 267.816Z" fill="#5C5C5C"/> <path d="M411.652 23C411.652 20.7909 409.861 19 407.652 19H29C26.7909 19 25 20.7909 25 23V141.931C25 144.14 26.7909 145.931 29 145.931H35.646C37.8551 145.931 39.646 147.722 39.646 149.931V169.472C39.646 173.036 43.9546 174.82 46.4745 172.3L71.6714 147.103C72.4216 146.352 73.439 145.931 74.4999 145.931H407.652C409.861 145.931 411.652 144.14 411.652 141.931V23Z" fill="#282828"/> <path d="M241.188 61.9839H70.703C69.2296 61.9839 68.0352 63.1783 68.0352 64.6517C68.0352 66.1252 69.2296 67.3196 70.703 67.3196H241.188C242.662 67.3196 243.856 66.1252 243.856 64.6517C243.856 63.1783 242.662 61.9839 241.188 61.9839Z" fill="#2160FD"/> <path d="M371.808 80.4419H70.703C69.2296 80.4419 68.0352 81.6363 68.0352 83.1098C68.0352 84.5832 69.2296 85.7776 70.703 85.7776H371.808C373.282 85.7776 374.476 84.5832 374.476 83.1098C374.476 81.6363 373.282 80.4419 371.808 80.4419Z" fill="#5C5C5C"/> <path d="M371.508 98.8999H70.703C69.2296 98.8999 68.0352 100.094 68.0352 101.568C68.0352 103.041 69.2296 104.236 70.703 104.236H371.508C372.982 104.236 374.176 103.041 374.176 101.568C374.176 100.094 372.982 98.8999 371.508 98.8999Z" fill="#5C5C5C"/> </svg>',
};

const getIconPack = async (url) => {
  // check for both null/undefined
  if (url == null) {
    return defaultIconPack;
  }
  try {
    const res = await fetch(url);
    if (!res.ok) {
      return defaultIconPack;
    }
    // merge defaultIconPack with the received iconPack so as to
    // fill the missing icons with default ones
    return Object.assign({}, defaultIconPack, await res.json());
  }
  catch (_) {
    return defaultIconPack;
  }
};

const sm = 640;
const md = 768;
const lg = 1080;
const xl = 2160;
const breakpoints = {
  sm: sm,
  md: md,
  lg: lg,
  xl: xl
};

/**
 * Get the screen breakpoint from a given width
 * @param width The width of the container
 * @returns The screen breakpoint value
 */
const getSize = (width) => {
  if (width >= breakpoints.lg)
    return 'lg';
  else if (width >= breakpoints.md)
    return 'md';
  else
    return 'sm';
};

/**
 * Default language dictionary
 */
const defaultLanguage = {
  about_call: 'About Call',
  screen: 'Screen',
  leave: 'Leave',
  dismiss: 'Dismiss',
  logo: 'Logo',
  page: 'Page',
  more: 'More',
  'page.prev': 'Previous Page',
  'page.next': 'Next Page',
  layout: 'Layout',
  'layout.auto': 'Auto Layout',
  settings: 'Settings',
  file: 'File',
  image: 'Image',
  connection: 'Connection',
  leave_confirmation: 'Are you sure you want to leave the call?',
  cancel: 'Cancel',
  yes: 'Yes',
  you: 'You',
  to: 'To',
  mute: 'Mute',
  kick: 'Kick',
  pin: 'Pin',
  pinned: 'Pinned',
  unpin: 'Unpin',
  pip_on: 'Show PiP',
  pip_off: 'Hide PiP',
  viewers: 'Viewers',
  join: 'Join',
  joined: 'Joined',
  create: 'Create',
  close: 'Close',
  ask: 'Ask',
  type: 'Type',
  activate: 'Activate',
  mic_off: 'Mic Off',
  disable_mic: 'Disable Mic',
  mic_on: 'Mic On',
  enable_mic: 'Enable Mic',
  audio: 'Audio',
  mute_all: 'Mute all',
  'mute_all.description': 'Everyone in the meeting will be muted.',
  'mute_all.header': 'Are you sure?',
  'mute_all.allow_unmute': 'Allow others to unmute',
  video_off: 'Video Off',
  disable_video: 'Disable Video',
  video_on: 'Video On',
  enable_video: 'Enable Video',
  video: 'Video',
  participants: 'Participants',
  'participants.errors.empty_results': "Couldn't find a participant with the specified name or ID.",
  'participants.empty_list': 'It looks like nobody is here.',
  'participants.turn_off_video': 'Turn off video',
  polls: 'Polls',
  'polls.by': 'Poll by',
  'polls.question': 'Poll Question',
  'polls.question.placeholder': 'What is your poll for?',
  'polls.option': 'Add an option.',
  'polls.option.placeholder': 'Enter an option',
  'polls.results.anon': 'Anonymous',
  'polls.results.hide': 'Hide results before voting',
  'polls.create': 'Create Poll',
  'polls.cancel': 'Cancel Poll Creation',
  'polls.errors.question_required': 'Question is required.',
  'polls.errors.empty_option': 'Empty options not allowed.',
  screenshare: 'Screen Share',
  'screenshare.min_preview': 'Minimize Preview',
  'screenshare.max_preview': 'Expand Preview',
  'screenshare.shared': 'Your screen is being shared.',
  'screenshare.start': 'Share Screen',
  'screenshare.stop': 'Stop Sharing',
  'screenshare.error.unknown': 'An error occured while starting screenshare.',
  'screenshare.error.max_count': 'Maximum screen share limit reached.',
  plugins: 'Plugins',
  perm_denied: 'Permission denied by browser.',
  'perm_denied.audio': 'Mic Permission denied by browser',
  'perm_denied.video': 'Camera Permission denied by browser',
  'perm_denied.screenshare': 'Screenshare Permission denied by browser',
  'perm_denied.audio.chrome.message': `Under Chrome settings, navigate to 'Privacy and Security > Site Settings > Permissions'. Select 'Microphone', provide permission and reload this application.`,
  'perm_denied.video.chrome.message': `Under Chrome settings, navigate to 'Privacy and Security > Site Settings > Permissions'. Select 'Camera', provide permission and reload this application.`,
  'perm_denied.screenshare.chrome.message': `Under Chrome settings, navigate to 'Privacy and Security > Site Settings > Permissions'. Select 'Screenshare', provide permission and reload this application.`,
  'perm_denied.audio.safari.message': `Under Safari settings, navigate to 'Websites > Microphone', provide permission and reload this application.`,
  'perm_denied.video.safari.message': `Under Safari settings, navigate to 'Websites > Camera', provide permission and reload this application.`,
  'perm_denied.screenshare.safari.message': `Under Safari settings, navigate to 'Websites > Screenshare', provide permission and reload this application.`,
  'perm_denied.audio.edge.message': `Under Edge settings, navigate to 'Site Permissions > Microphone', provide permission and reload this application.`,
  'perm_denied.video.edge.message': `Under Edge settings, navigate to 'Site Permissions > Camera', provide permission and reload this application.`,
  'perm_denied.screenshare.edge.message': `Under Edge settings, navigate to 'Site Permissions > Screenshare', provide permission and reload this application.`,
  'perm_denied.audio.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Microphone', provide permission and reload this application.`,
  'perm_denied.video.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Camera', provide permission and reload this application.`,
  'perm_denied.screenshare.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Screenshare', provide permission and reload this application.`,
  'perm_denied.audio.others.message': `From your browser settings, enable 'Microphone' permissions and reload this application.`,
  'perm_denied.video.others.message': `From your browser settings, enable 'Camera' permissions and reload this application.`,
  'perm_denied.screenshare.others.message': `From your browser settings, enable 'Screenshare' permissions and reload this application.`,
  perm_sys_denied: 'Permission denied by system',
  'perm_sys_denied.audio': 'Mic permission denied by system',
  'perm_sys_denied.video': 'Camera permission denied by system',
  'perm_sys_denied.screenshare': 'Screenshare permission denied by system',
  'perm_sys_denied.audio.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Microphone'. Allow access to your browser and reload this application.`,
  'perm_sys_denied.video.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Camera'. Allow access to your browser and reload this application.`,
  'perm_sys_denied.screenshare.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Screenshare'. Allow access to your browser and reload this application.`,
  'perm_sys_denied.audio.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Microphone', allow access to your browser and reload this application.`,
  'perm_sys_denied.video.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Camera', allow access to your browser and reload this application.`,
  'perm_sys_denied.screenshare.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Screenshare', allow access to your browser and reload this application.`,
  'perm_sys_denied.audio.windows.message': `Go to windows settings, select 'Settings > Privacy > Microphone'. Allow permissions to your browser and reload this application.`,
  'perm_sys_denied.video.windows.message': `Go to windows settings, select 'Settings > Privacy > Camera'. Allow permissions to your browser and reload this application.`,
  'perm_sys_denied.screenshare.windows.message': `Go to windows settings, select 'Settings > Privacy > Screenshare'. Allow permissions to your browser and reload this application.`,
  'perm_sys_denied.audio.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Microphone permissions and reload this application.`,
  'perm_sys_denied.video.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Camera permissions and reload this application.`,
  'perm_sys_denied.screenshare.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Screenshare permissions and reload this application.`,
  'perm_sys_denied.audio.others.message': `Navigate to your system settings. Allow 'Microphone' permissions for your browser and reload this application.`,
  'perm_sys_denied.video.others.message': `Navigate to your system settings. Allow 'Camera' permissions for your browser and reload this application.`,
  'perm_sys_denied.screenshare.others.message': `Navigate to your system settings. Allow 'Screenshare' permissions for your browser and reload this application.`,
  perm_could_not_start: `Could not capture device.`,
  'perm_could_not_start.audio': `Unable to start your Microphone`,
  'perm_could_not_start.video': `Unable to start your Camera`,
  'perm_could_not_start.screenshare': `Unable to start your Screenshare`,
  'perm_could_not_start.audio.message': `Looks like the system could not capture your microphone. Please restart your device or upgrade your browser to fix this.`,
  'perm_could_not_start.video.message': `Looks like the system could not capture your camera. Please restart your device or upgrade your browser to fix this.`,
  'perm_could_not_start.screenshare.message': `Looks like the system could not capture your screenshare. Please restart your device or upgrade your browser to fix this.`,
  full_screen: 'Full Screen',
  'full_screen.exit': 'Exit Full Screen',
  'waitlist.header_title': 'Waiting',
  'waitlist.body_text': 'You are in the waiting room, the host will let you in soon.',
  'waitlist.deny_request': 'Deny request',
  'waitlist.accept_request': 'Accept request',
  'waitlist.accept_all': 'Accept all',
  'stage_request.header_title': 'Join Stage Requests',
  'stage_request.deny_request': 'Deny request',
  'stage_request.accept_request': 'Accept request',
  'stage_request.accept_all': 'Accept all',
  'stage_request.deny_all': 'Deny all',
  'stage_request.approval_pending': 'Pending',
  'stage_request.denied': 'Denied',
  'stage_request.request': 'Join stage',
  'stage_request.cancel_request': 'Cancel request',
  'stage_request.leave_stage': 'Leave stage',
  'stage_request.request_tip': 'Request to join the discussion',
  'stage_request.leave_tip': 'Leave the stage',
  'stage_request.pending_tip': 'Request pending',
  'stage_request.denied_tip': 'Rejected request',
  'stage.empty_host': 'The stage is empty',
  'stage.empty_host_summary': 'To begin the webinar, please join the stage or accept a join stage request from the participants tab.',
  'stage.empty_viewer': 'Webinar has not yet been started',
  'stage.remove_from_stage': 'Remove from stage',
  'stage.add_to_stage': 'Add to stage',
  'stage.join_title': 'Join Stage',
  'stage.join_summary': 'You are about to join the stage, your video & audio as shown above will be visible to all participants.',
  'stage.join_cancel': 'Cancel',
  'stage.join_confirm': 'Join',
  'setup_screen.join_in_as': 'Join in as',
  'setup_screen.joining_as': 'Joining as',
  'setup_screen.your_name': 'Your name',
  'stage.reconnecting': 'Reconnecting...',
  'recording.label': 'REC',
  'recording.indicator': 'This meeting is being recorded.',
  'recording.started': 'This meeting is being recorded.',
  'recording.stopped': 'Recording for this meeting has been stopped.',
  'recording.error.start': 'Error while starting recording.',
  'recording.error.stop': 'Error while stopping recording',
  'recording.start': 'Start Recording',
  'recording.stop': 'Stop Recording',
  'recording.starting': 'Starting',
  'recording.stopping': 'Stopping',
  'recording.loading': 'Loading',
  'recording.idle': 'Record',
  audio_playback: 'Play Audio',
  'audio_playback.title': 'Allow Audio Playback',
  'audio_playback.description': 'In order to play audio properly on your device, click the button below.',
  breakout_rooms: 'Breakout Rooms',
  'breakout_rooms.room_config_header': 'Create Breakout',
  'breakout_rooms.join_breakout_header': 'Join Breakout',
  'breakout_rooms.empty': 'Nobody here yet.',
  'breakout_rooms.delete': 'Delete Room',
  'breakout_rooms.switch': 'Switch',
  'breakout_rooms.main_room': 'Main Room',
  'breakout_rooms.shuffle_participants': 'Shuffle Participants',
  'breakout_rooms.deselect': 'Deselect',
  'breakout_rooms.selected': 'selected',
  'breakout_rooms.num_of_rooms': 'No. of Rooms',
  'breakout_rooms.approx': 'Approx.',
  'breakout_rooms.participants_per_room': 'participants/room',
  'breakout_rooms.division_text': 'when equally divided.',
  'breakout_rooms.start_breakout': 'Start Breakout',
  'breakout_rooms.close_breakout': 'Close Breakout',
  'breakout_rooms.update_breakout': 'Update Breakout',
  'breakout_rooms.discard_changes': 'Discard Changes',
  'breakout_rooms.room': 'Room',
  'breakout_rooms.rooms': 'Rooms',
  'breakout_rooms.room_name': 'Room Name',
  'breakout_rooms.edit_room_name': 'Edit Room Name',
  'breakout_rooms.save_room_name': 'Save Room Name',
  'breakout_rooms.add_room': 'Add',
  'breakout_rooms.add_room_brief': 'Add Room',
  'breakout_rooms.select_all': 'Select all',
  'breakout_rooms.unassign_all': 'Unassign all',
  'breakout_rooms.assign': 'Assign',
  'breakout_rooms.assign_participants': 'Assign Participants',
  'breakout_rooms.none_assigned': 'No participants assigned yet',
  'breakout_rooms.drag_drop_participants': 'Drag and drop participants',
  'breakout_rooms.click_drop_participants': 'Click here to assign',
  'breakout_rooms.status.assign_multiple': 'Assign multiple participants at once by clicking and selecting them',
  'breakout_rooms.status.select_room': 'Select a room to assign',
  'breakout_rooms.ephemeral_status.participants_assigned': 'Participants assigned',
  'breakout_rooms.ephemeral_status.participants_assigned_randomly': 'Participants assigned randomly',
  'breakout_rooms.ephemeral_status.changes_discarded': 'Changes discarded',
  'breakout_rooms.confirm_modal.start_breakout.header': 'Start breakout rooms?',
  'breakout_rooms.confirm_modal.start_breakout.content': 'Once started, all participants will be moved to their assigned rooms.',
  'breakout_rooms.confirm_modal.start_breakout.cancelText': 'No, go back',
  'breakout_rooms.confirm_modal.start_breakout.ctaText': 'Yes, start',
  'breakout_rooms.confirm_modal.close_breakout.header': 'Close breakout rooms?',
  'breakout_rooms.confirm_modal.close_breakout.content': 'All breakout rooms will be closed & participants will be moved back to the main room.',
  'breakout_rooms.confirm_modal.close_breakout.ctaText': 'Yes, close breakout',
  'breakout_rooms.move_reason.started_msg': 'Starting breakout rooms...',
  'breakout_rooms.move_reason.started_desc': 'You are being moved to your assigned room',
  'breakout_rooms.move_reason.closed_msg': 'Closing Breakout rooms...',
  'breakout_rooms.move_reason.closed_desc': 'You are being moved back to the main room',
  'breakout_rooms.move_reason.switch_room': 'Joining Breakout Room...',
  'breakout_rooms.move_reason.switch_main_room': 'Joining Main Room...',
  'breakout_rooms.all_assigned': 'All participants have been assigned',
  'breakout_rooms.empty_main_room': 'No more participants in the main room.',
  'breakout_rooms.leave_confirmation': 'Are you sure you want to leave the call? You are in a breakout room, you can join the main room too.',
  'breakout_rooms.leave_confirmation.main_room_btn': 'Go back to main room',
  ai: 'AI',
  'ai.meeting_ai': 'MeetingAI',
  'ai.home': 'Home',
  'ai.transcriptions': 'Transcriptions',
  'ai.personal': 'Personal',
  'ai.caption_view': 'Caption View',
  'ai.chat.tooltip': 'This conversation will just be visible to you and not to others in the call.',
  'ai.chat.summerise': 'Hey AI, summarise this call',
  'ai.chat.agenda': "Hey AI, what is today's agenda?",
  search: 'Search',
  'search.could_not_find': "Couldn't find a participant with the specified name or ID.",
  'search.empty': 'It looks like nobody is here.',
  end: 'End Meeting',
  'end.all': 'End meeting for all',
  ended: 'The meeting ended.',
  'ended.rejected': 'Your request to join the meeting was denied.',
  'ended.left': 'You left the meeting.',
  'ended.kicked': 'You were removed from the meeting.',
  'ended.disconnected': 'The call ended because the connection was lost.',
  'ended.network': 'Please check your internet connection and try again.',
  network: 'Network',
  'network.reconnecting': 'Connection lost. Trying to reconnect...',
  'network.delay': 'Taking too long to reconnect...',
  'network.delay_extended': 'Taking too long to reconnect. Please check your network connection.',
  'network.restored': 'Connection restored',
  'network.lost': 'Connection lost',
  'network.lost_extended': 'Connection lost. Please check your network connection.',
  'network.disconnected': 'Could not reconnect. Please leave the meeting and try refreshing the window.',
  'network.leaving': 'Automatically leaving the meeting in 10 seconds.',
  livestream: 'Livestream',
  'livestream.indicator': 'This meeting is being livestreamed.',
  'livestream.skip': 'Skip to Live',
  'livestream.idle': 'Waiting to go live.',
  'livestream.starting': 'Livestream is starting...',
  'livestream.stopping': 'Livestream is stopping...',
  'livestream.error.not_supported': 'Player not supported.',
  'livestream.error.not_found': 'Playback URL not found.',
  'livestream.error.unknown': 'An unknown error occured.',
  'livestream.error.sync': 'Could not sync livestream please try again later.',
  'livestream.error.start': 'Error while starting livestream.',
  'livestream.error.stop': 'Error while stopping livestream.',
  'livestream.go_live': 'Go Live',
  'livestream.end_live': 'End Live',
  'livestream.error': 'Error',
  'cta.help': 'Need help on how to do this?',
  'cta.continue': 'Continue as it is',
  'cta.reload': 'Reload',
  'cta.confirmation': 'Are you sure?',
  'remote_access.empty': 'There are no remote requests, yet.',
  'remote_access.requests': 'The following people have requested remote control to your screen share.',
  'remote_access.allow': 'Please select whom you want to give access to.',
  'remote_access.grant': 'Grant acess',
  'remote_access.indicator': 'Any plugin or screenshare you switch to will sync the change across the meeting',
  chat: 'Chat',
  'chat.new': 'New',
  'chat.new_channel': 'Create new channel',
  'chat.channel_name': 'Enter channel name',
  'chat.member_name': 'Enter member name',
  'chat.add_members': 'Add members',
  'chat.delete_msg': 'Delete',
  'chat.edit_msg': 'Edit',
  'chat.send_msg': 'Send message',
  'chat.send_attachment': 'Drop files/images to send',
  'chat.send_img': 'Send an image',
  'chat.send_file': 'Send a file',
  'chat.send_emoji': 'Send an emoji',
  'chat.update_msg': 'Update message',
  'chat.channel_members': 'Channel Members',
  'chat.img.loading': 'Loading image',
  'chat.error.img_not_found': 'Image not found',
  'chat.error.empty_results': "Couldn't find a member with the specified name.",
  'chat.img.shared_by': 'Shared by',
  'chat.reply': 'Reply',
  'chat.message_placeholder': 'Message..',
  'chat.click_to_send': 'Click to send as message',
  'chat.search_msgs': 'Search messages',
  'chat.search_conversations': 'Search conversations',
  'chat.start_conversation': 'Start a conversation..',
  'chat.empty_search': 'No messages found',
  'chat.empty_channel': 'Send a message to get started',
  'chat.cancel_upload': 'Cancel upload',
  'date.today': 'Today',
  'date.yesteday': 'Yesterday',
  'date.sunday': 'Sunday',
  'date.monday': 'Monday',
  'date.tuesday': 'Tuesday',
  'date.wednesday': 'Wednesday',
  'date.thursday': 'Thursday',
  'date.friday': 'Friday',
  'date.saturday': 'Saturday',
  'list.empty': 'No items found',
};

/**
 * Creates an i18n instance from a language dictionary/object.
 * @param lang The language dictionary
 * @returns A function which handles i18n
 */
const useLanguage = (lang = defaultLanguage) => {
  const locale = Object.assign({}, defaultLanguage, lang);
  return (key) => {
    var _a;
    return (_a = locale[key]) !== null && _a !== void 0 ? _a : key;
  };
};

/**
 * Computes selectors and returns them based on their priority.
 */
const computeSelectors = ({ element, size, states = {}, config = {}, }) => {
  let selectors = [];
  const data = config === null || config === void 0 ? void 0 : config.root[element];
  const add = (selector) => {
    selectors.push(selector);
    if (typeof size === 'string') {
      selectors.push(`${selector}.${size}`);
    }
  };
  add(element);
  if (typeof data === 'object' && !Array.isArray(data) && data !== null) {
    // check if the data variable is an object, strictly and not an array or just null
    const { state, states: elementStates } = data;
    let selector = element;
    let activeStates = [];
    if (Array.isArray(elementStates)) {
      activeStates = elementStates.filter((state) => states[state]);
      activeStates.sort();
      for (const state of activeStates) {
        add(`${selector}.${state}`);
      }
      if (activeStates.length > 1) {
        const booleanStateSelector = [selector, ...activeStates].join('.');
        add(booleanStateSelector);
      }
    }
    if (typeof state === 'string') {
      // dyte-meeting[meeting=joined]
      const keyValueSelector = `${element}[${state}=${states[state]}]`;
      add(keyValueSelector);
      for (const state of activeStates) {
        add(`${keyValueSelector}.${state}`);
      }
      if (activeStates.length > 1) {
        const withBooleanStateSelector = [keyValueSelector, ...activeStates].join('.');
        add(withBooleanStateSelector);
      }
    }
  }
  return selectors;
};
/**
 * Returns the computed styles - styles obtained from combining styles from all computed selectors
 * on the basis of their priorities.
 */
const getComputedStyles = ({ selectors, styles }) => {
  if (!Array.isArray(selectors) || styles == null)
    return {};
  const computedStyles = {};
  for (const selector of selectors) {
    const style = styles[selector];
    if (style != null) {
      Object.assign(computedStyles, style);
    }
  }
  return computedStyles;
};
/**
 * Returns the computed children which are to be rendered inside an element
 */
const getComputedChildren = ({ selectors, root }) => {
  if (!root || !Array.isArray(selectors))
    return [];
  let children = [];
  for (const selector of selectors) {
    const el = root[selector];
    if (Array.isArray(el)) {
      children = [...el];
    }
    else if (el) {
      if (el.children) {
        children = [...el.children];
      }
      if (Array.isArray(el.remove)) {
        for (const toRemove of el.remove) {
          children = children.filter((child) => {
            if (typeof child === 'string') {
              return child !== toRemove;
            }
            else if (Array.isArray(child)) {
              return child[0] !== toRemove;
            }
            return true;
          });
        }
      }
      if (el.addBefore) {
        for (const [beforeEl, toAdd] of Object.entries(el.addBefore)) {
          const idx = children.findIndex((child) => {
            if (typeof child === 'string') {
              return child === beforeEl;
            }
            else if (Array.isArray(child)) {
              return child[0] === beforeEl;
            }
            return false;
          });
          if (idx >= 0) {
            children.splice(idx, 0, ...toAdd);
          }
        }
      }
      if (Array.isArray(el.add)) {
        children = children.concat(el.add);
      }
      if (Array.isArray(el.prepend)) {
        children = el.prepend.concat(children);
      }
    }
  }
  return children;
};

/**
 * Renders the children of an element.
 */
const RenderChildren = ({ elements, defaults, props = {}, deepProps = false, elementProps = {}, }) => {
  if (!Array.isArray(elements) || elements.length === 0)
    return null;
  return elements.map((element) => {
    return (h(Render, { element: element, defaults: defaults, props: props, childProps: deepProps && props, elementProps: elementProps }));
  });
};
/**
 * Renders an element from UI Config
 */
const Render = ({ element, defaults, childProps = {}, props = {}, onlyChildren = false, asHost = false, deepProps = false, elementProps = {}, }, children) => {
  var _a;
  const { config, size, states } = defaults;
  let Tag, configProps = {};
  if (Array.isArray(element)) {
    // get props if element is passed in array form:
    // ['dyte-participant-tile', { variant: 'gradient' }]
    [Tag, configProps] = element;
  }
  else {
    Tag = element;
  }
  const elemData = (_a = config === null || config === void 0 ? void 0 : config.root) === null || _a === void 0 ? void 0 : _a[Tag];
  if (elemData != null && 'props' in elemData) {
    props = Object.assign(Object.assign({}, elemData['props']), props);
  }
  props = Object.assign(Object.assign({}, props), configProps);
  if (Tag in elementProps) {
    props = Object.assign(Object.assign({}, props), elementProps[Tag]);
  }
  const selectors = computeSelectors({ element: Tag, size, states, config });
  const computedChildren = getComputedChildren({ selectors, root: config.root });
  if (onlyChildren) {
    return (h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }));
  }
  const styles = getComputedStyles({ selectors, styles: config.styles });
  if (asHost) {
    return (h(Host, Object.assign({}, defaults, { style: styles }, props),
      h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
      children));
  }
  if (['dyte-header', 'dyte-controlbar'].includes(Tag)) {
    props['disableRender'] = true;
  }
  if (Tag.startsWith('dyte-')) {
    return (h(Tag, Object.assign({}, defaults, { style: styles }, props),
      h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
      children));
  }
  else {
    const [HTMLTag, id] = Tag.split('#');
    return (h(HTMLTag, { id: id, style: styles },
      h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
      children));
  }
};

const handler = {
  get: (target, name, receiver) => (...args) => {
    try {
      return Reflect.get(target, name, receiver).apply(target, args);
    }
    catch (_a) {
      return null;
    }
  },
};
let gracefulStorage;
try {
  gracefulStorage = new Proxy(localStorage, handler);
}
catch (_a) {
  gracefulStorage = new Proxy({}, handler);
}
const gracefulStorage$1 = gracefulStorage;

const KEY = 'dyte-prefs';
const setPreference = (key, value) => {
  const data = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
  data[key] = JSON.stringify(value);
  gracefulStorage$1.setItem('dyte-prefs', JSON.stringify(data));
};
const getPreference = (key) => {
  const data = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
  return data[key];
};
const getUserPreferences = () => {
  const prefs = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
  const mirrorVideo = prefs['mirror-video'] ? prefs['mirror-video'] === 'true' : true;
  const muteNotificationSounds = prefs['mute-notification-sounds']
    ? prefs['mute-notification-sounds'] === 'true'
    : false;
  return { mirrorVideo, muteNotificationSounds };
};
const chatUnreadTimestamps = {};

const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce$1 = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce$1((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof getRenderingRef !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = getRenderingRef();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(forceUpdate));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};

const { state, onChange } = createStore({});

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver$1 = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver$1.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver$1;
})();

const dyteMeetingCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));overflow:hidden;position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);height:100%;width:100%}:host([mode='fill']){position:relative}";

const DyteMeeting = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.roomJoinedListener = () => {
      this.setStates({ meeting: 'joined' });
      state.meeting = 'joined';
    };
    this.waitlistedListener = () => {
      this.setStates({ meeting: 'waiting' });
      state.meeting = 'waiting';
    };
    this.roomLeftListener = ({ state: state$1 }) => {
      const states = this.states || state;
      if ((states === null || states === void 0 ? void 0 : states.roomLeftState) === 'disconnected') {
        this.setStates({ meeting: 'ended', roomLeftState: state$1 });
        state.meeting = 'ended';
        return;
      }
      this.setStates({ meeting: 'ended', roomLeftState: state$1 });
      state.meeting = 'ended';
      state.roomLeftState = state$1;
    };
    this.mediaPermissionUpdateListener = ({ kind, message }) => {
      if (['audio', 'video'].includes(kind)) {
        if (message === 'ACCEPTED' || state.activeDebugger)
          return;
        const permissionModalSettings = {
          enabled: true,
          kind,
        };
        this.setStates({ activePermissionsMessage: permissionModalSettings });
        state.activePermissionsMessage = permissionModalSettings;
      }
    };
    this.joinStateAcceptedListener = () => {
      this.setStates({ activeJoinStage: true });
      this.stateUpdate.emit({ activeJoinStage: true });
      state.activeJoinStage = true;
    };
    this.loadConfigFromPreset = true;
    this.applyDesignSystem = true;
    this.mode = 'fixed';
    this.leaveOnUnmount = false;
    this.meeting = undefined;
    this.showSetupScreen = undefined;
    this.t = useLanguage();
    this.config = defaultConfig;
    this.iconPackUrl = undefined;
    this.size = undefined;
    this.gridLayout = 'row';
    this.states = {
      meeting: 'idle',
      prefs: {
        mirrorVideo: true,
        muteNotificationSounds: false,
      },
    };
    this.middlewares = {};
    this.newMeeting = undefined;
    this.iconPack = defaultIconPack;
  }
  connectedCallback() {
    var _a;
    this.resizeObserver = new index(() => this.handleResize());
    this.resizeObserver.observe(this.host);
    if (this.applyDesignSystem &&
      ((_a = this.config) === null || _a === void 0 ? void 0 : _a.designTokens) != null &&
      typeof document !== 'undefined') {
      provideDyteDesignSystem(document.documentElement, this.config.designTokens);
    }
    this.meetingChanged(this.meeting);
    this.iconPackUrlChanged(this.iconPackUrl);
    this.initializePreferences();
  }
  clearListeners(meeting) {
    if (meeting == undefined)
      return;
    meeting.self.removeListener('roomJoined', this.roomJoinedListener);
    meeting.self.removeListener('socketServiceRoomJoined', this.roomJoinedListener);
    meeting.meta.removeListener('socketReconnected', this.roomJoinedListener);
    meeting.self.removeListener('roomLeft', this.roomLeftListener);
    meeting.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    meeting.self.removeListener('waitlisted', this.waitlistedListener);
    meeting.self.removeListener('joinStageRequestAccepted', this.joinStateAcceptedListener);
  }
  disconnectedCallback() {
    var _a;
    if (this.leaveOnUnmount) {
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.leaveRoom();
    }
    this.resizeObserver.disconnect();
    this.clearListeners(this.meeting);
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting == null)
      return;
    if (this.loadConfigFromPreset && meeting.self.config != null) {
      const theme = meeting.self.config;
      const { config, data } = generateConfig(theme, meeting);
      if (this.config === defaultConfig) {
        // only override the config if the object is same as defaultConfig
        // which means it's a different object passed via prop
        this.config = config;
      }
      if (this.showSetupScreen == null) {
        // only override this value if the prop isn't passed
        this.showSetupScreen = data.showSetupScreen;
      }
      if (meeting.connectedMeetings.supportsConnectedMeetings &&
        ((_a = state.activeBreakoutRoomsManager) === null || _a === void 0 ? void 0 : _a.destinationMeetingId)) {
        this.showSetupScreen = false;
      }
    }
    if (this.applyDesignSystem &&
      ((_b = this.config) === null || _b === void 0 ? void 0 : _b.designTokens) != null &&
      typeof document !== 'undefined') {
      provideDyteDesignSystem(document.documentElement, this.config.designTokens);
    }
    if (isLiveStreamViewer(meeting)) {
      meeting.self.addListener('socketServiceRoomJoined', this.roomJoinedListener);
    }
    else {
      meeting.self.addListener('roomJoined', this.roomJoinedListener);
    }
    meeting.self.addListener('waitlisted', this.waitlistedListener);
    meeting.self.addListener('roomLeft', this.roomLeftListener);
    meeting.self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    meeting.self.addListener('joinStageRequestAccepted', this.joinStateAcceptedListener);
    if (meeting.connectedMeetings.supportsConnectedMeetings) {
      meeting.connectedMeetings.once('changingMeeting', this.handleChangingMeeting);
    }
    if (meeting.self.roomJoined) {
      this.states = Object.assign(Object.assign({}, this.states), { meeting: 'joined' });
      state.meeting = 'joined';
    }
    else {
      if (this.showSetupScreen && this.newMeeting == null) {
        this.states = Object.assign(Object.assign({}, this.states), { meeting: 'setup' });
        state.meeting = 'setup';
      }
      else {
        // join directly to the meeting
        meeting.joinRoom();
      }
    }
  }
  async iconPackUrlChanged(url) {
    this.iconPack = await getIconPack(url);
  }
  listenState(e) {
    e.stopPropagation();
    this.setStates(e.detail);
  }
  initializePreferences() {
    const prefs = getUserPreferences();
    this.setStates({ prefs });
    state.prefs = prefs;
  }
  handleChangingMeeting(destinationMeetingId) {
    state.activeBreakoutRoomsManager = Object.assign(Object.assign({}, state.activeBreakoutRoomsManager), { destinationMeetingId });
  }
  handleResize() {
    this.size = getSize(this.host.clientWidth);
  }
  setStates(states) {
    const newStates = Object.assign({}, this.states);
    merge(newStates, states);
    this.states = newStates;
  }
  render() {
    var _a, _b, _c;
    const defaults = {
      meeting: (_a = this.newMeeting) !== null && _a !== void 0 ? _a : this.meeting,
      size: this.size,
      states: this.states || state,
      config: this.config,
      iconPack: this.iconPack,
      t: this.t,
      middlewares: this.middlewares,
    };
    const elementProps = {
      'dyte-grid': {
        layout: this.gridLayout,
      },
    };
    if (((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.viewType) === 'CHAT')
      return h(Render, { element: "dyte-chat", defaults: defaults });
    return h(Render, { element: "dyte-meeting", defaults: defaults, asHost: true, elementProps: elementProps });
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "iconPackUrl": ["iconPackUrlChanged"]
  }; }
};
DyteMeeting.style = dyteMeetingCss;

var dyteMeeting_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_meeting: DyteMeeting
});

const dyteAiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;box-sizing:border-box;display:flex;width:100%;max-width:var(--dyte-space-80, 320px);flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden}.close{position:absolute;top:var(--dyte-space-3, 12px);left:var(--dyte-space-3, 12px)}.title{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-2, 8px);-webkit-user-select:none;-moz-user-select:none;user-select:none;padding:var(--dyte-space-0, 0px);text-align:center;font-size:16px;font-weight:400}#mobile-header{margin-top:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-evenly;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}#mobile-header dyte-button{border-bottom:var(--dyte-border-width-md, 2px) solid transparent;position:relative;border-radius:var(--dyte-border-radius-none, 0)}#mobile-header dyte-button:hover{background-color:transparent}#mobile-header dyte-button.active{border-color:rgb(var(--dyte-colors-brand-400, 53 110 253))}#mobile-header dyte-button .dot{font-size:48px;position:absolute;top:-26px;right:calc(var(--dyte-space-1, 4px) * -1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}dyte-ai-home,dyte-ai-transcriptions,dyte-ai-chat{flex:1}:host([view='sidebar']){margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}:host([view='full-screen']){position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:50;max-width:100%;border:none}";

const DyteAi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.close = () => {
      this.stateUpdate.emit({ activeAI: false });
      state.activeAI = false;
    };
    this.transcriptionHandler = () => {
      if (this.tab !== 'transcriptions') {
        this.newTranscriptionAvailable = true;
      }
    };
    this.aiMessageHandler = () => {
      if (this.tab !== 'home') {
        this.newAiMessageAvailable = true;
      }
    };
    this.defaultSection = 'home';
    this.meeting = undefined;
    this.middlewares = {};
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.size = undefined;
    this.view = 'sidebar';
    this.tab = this.defaultSection;
    this.newTranscriptionAvailable = false;
    this.newAiMessageAvailable = false;
  }
  connectedCallback() {
    var _a, _b, _c, _d;
    this.viewChanged(this.view);
    (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.on('transcription', this.transcriptionHandler);
    (_d = (_c = this.middlewares) === null || _c === void 0 ? void 0 : _c.speech) === null || _d === void 0 ? void 0 : _d.on('chatGPTReply', this.aiMessageHandler);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d;
    this.keydownListener && document.removeEventListener('keydown', this.keydownListener);
    (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.off('transcription', this.transcriptionHandler);
    (_d = (_c = this.middlewares) === null || _c === void 0 ? void 0 : _c.speech) === null || _d === void 0 ? void 0 : _d.off('chatGPTReply', this.aiMessageHandler);
  }
  viewChanged(view) {
    if (view === 'full-screen') {
      this.keydownListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      document.addEventListener('keydown', this.keydownListener);
    }
  }
  tabChanged(tab) {
    if (tab === 'transcriptions' && this.newTranscriptionAvailable) {
      this.newTranscriptionAvailable = false;
    }
    if (tab === 'home' && this.newAiMessageAvailable) {
      this.newAiMessageAvailable = false;
    }
  }
  viewSection(section) {
    this.tab = section;
    state.activeSidebar = true;
  }
  render() {
    var _a;
    if (!this.middlewares.speech || !((_a = this.states) === null || _a === void 0 ? void 0 : _a.activeAI)) {
      return null;
    }
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states || state,
      size: this.size,
      t: this.t,
      iconPack: this.iconPack,
      middlewares: this.middlewares,
    };
    const aiClient = this.middlewares.speech;
    return (h(Host, null, h("h3", { class: "title" }, this.t('ai')), h("div", { id: "mobile-header" }, h("dyte-button", { variant: "ghost", class: { active: this.tab === 'home' }, onClick: () => this.viewSection('home'), iconPack: this.iconPack, t: this.t }, this.t('ai.home'), this.newAiMessageAvailable && h("span", { class: "dot" }, ".")), h("dyte-button", { variant: "ghost", class: { active: this.tab === 'transcriptions' }, onClick: () => this.viewSection('transcriptions'), iconPack: this.iconPack, t: this.t }, this.t('ai.transcriptions'), this.newTranscriptionAvailable && h("span", { class: "dot" }, "."))), h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: this.close, "aria-label": this.t('close'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t })), this.tab === 'home' && (h(Render, { element: "dyte-ai-home", defaults: defaults, props: {
        aiClient: aiClient,
        initialMessages: aiClient.aiMesssages,
        meeting: this.meeting,
      } })), this.tab === 'transcriptions' && (h(Render, { element: "dyte-ai-transcriptions", defaults: defaults, props: { aiClient: aiClient, initialTranscriptions: aiClient.transcriptions } })), this.tab === 'personal' && h(Render, { element: "dyte-ai-chat", defaults: defaults })));
  }
  static get watchers() { return {
    "view": ["viewChanged"],
    "tab": ["tabChanged"]
  }; }
};
DyteAi.style = dyteAiCss;

var dyteAi_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ai: DyteAi
});

const dyteAiChatCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column}.private-message{text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));margin-top:var(--dyte-space-8, 32px);margin-bottom:var(--dyte-space-8, 32px);margin-left:var(--dyte-space-10, 40px);margin-right:var(--dyte-space-10, 40px)}.hint-message{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;flex:1 1 0%;font-size:14px;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}i{font-weight:500;font-style:italic;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}";

const DyteAiChat = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("p", { class: "private-message" }, this.t('ai.chat.tooltip')), h("div", { class: "hint-message" }, h("p", null, this.t('ask'), " ", h("i", null, "\"", this.t('ai.chat.summerise'), "\""), h("br", null), " or ", h("br", null), this.t('type'), " ", h("i", null, "\"", this.t('ai.chat.agenda'), "\"")))));
  }
};
DyteAiChat.style = dyteAiChatCss;

var dyteAiChat_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ai_chat: DyteAiChat
});

const differenceInMinutes = (oldDate, newDate) => {
  // difference in milliseconds
  const diff = newDate.getTime() - oldDate.getTime();
  return Math.round(Math.abs(diff / 1000 / 60));
};
const elapsedDuration = (oldDate, newDate) => {
  const minutes = differenceInMinutes(oldDate, newDate);
  if (minutes < 2) {
    return 'just now';
  }
  if (minutes < 60) {
    return `${minutes}m ago`;
  }
  const hours = Math.round(minutes / 60);
  if (minutes < 90) {
    return `about ${hours}h ago`;
  }
  if (hours < 24) {
    return `${hours}h ago`;
  }
  const days = Math.round(hours / 24);
  if (days < 7) {
    return `${days}d ago`;
  }
  const weeks = Math.round(days / 7);
  return `${weeks}w ago`;
};
const formatDateTime = (date) => {
  return date.toDateString() + ' ' + date.toLocaleTimeString();
};

/**
 * Shorten a string upto a maximum length of characters and add `...` as suffix if it exceeds the maximum length
 * @param str The The string you want to shorten
 * @param maxLength Maximum length of character
 * @returns Formatted shortedned string
 */
const shorten = (str, maxLength = 20) => {
  if (str == null)
    return '';
  if (str.length > maxLength) {
    return `${str.substring(0, maxLength)}...`;
  }
  return str;
};
/**
 * Checks if a given string consists of only emojis.
 *
 * However this classifies a string with numbers as emoji as well.
 * Which works in our favour for now in chat as it enlarges messages with just numbers.
 * @param str String on which to perform the check on
 * @returns A Boolean value which indicates if string consists of only emojis
 */
const hasOnlyEmojis = (str) => {
  const num = /^\d+$/;
  const re = /^\p{Emoji}+$/u;
  return re.test(str) && !num.test(str);
};
const sanitizeLink = (link) => {
  // TODO: needs more work
  if (link === null || link === void 0 ? void 0 : link.trim().toLowerCase().startsWith('javascript:')) {
    return 'https://dyte.io';
  }
  return link;
};
/**
 * Formats a given name and returns **Participant** for unnamed participants.
 * @param name Name of participant
 * @returns Name to use in the UI
 */
const formatName = (name) => {
  name = name === null || name === void 0 ? void 0 : name.trim();
  if (name === '')
    return 'Participant';
  return name;
};
function getInitials(name, maxInitials = 2) {
  // removes any character that is not a letter, number or whitespace
  const cleanedName = name.replace(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/g, '');
  const words = cleanedName.trim().split(/\s+/).slice(0, maxInitials);
  return words
    .map((word) => word.charAt(0))
    .join('')
    .toUpperCase();
}

const ChatHead = ({ name, time, now }) => {
  return (h("div", { class: "head" },
    h("div", { class: "name" }, shorten(formatName(name), 20)),
    h("div", { class: "time", title: formatDateTime(time) }, elapsedDuration(time, now))));
};

/**
 * Scroll to bottom of an element.
 *
 * Works in all browsers - just that in Safari, the smooth scrolling doesn't work.
 * @param el The bottom of which element you want to scroll down to
 */
const smoothScrollToBottom = (el, smooth = true) => {
  if (el == null)
    return;
  el.scrollTo({ top: el.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
};

const dyteAiHomeCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.head{display:flex;align-items:center}.head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}*{box-sizing:border-box;border-width:0;border-style:solid}:host{display:flex;flex-direction:column}.public-message{text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));margin-top:var(--dyte-space-8, 32px);margin-bottom:var(--dyte-space-8, 32px);margin-left:var(--dyte-space-10, 40px);margin-right:var(--dyte-space-10, 40px)}.content{box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-3, 12px);flex:1 0 0px;overflow-y:scroll;}.subtitle{margin-top:var(--dyte-space-1, 4px);font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.hint-message{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;flex:1 1 0%;font-size:14px;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}i{font-weight:500;font-style:italic;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.actions{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);display:flex;align-items:center;justify-content:space-between;font-size:12px}.actions div{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.actions button{display:inline-flex;cursor:pointer;border-radius:var(--dyte-border-radius-md, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.5);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.prompt{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.prompt input{height:var(--dyte-space-12, 48px);width:100%;resize:none;background-color:transparent;padding:var(--dyte-space-4, 16px);font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px}.message .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);white-space:pre-wrap;font-size:14px}.message .loader{display:flex;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);font-size:12px}.message{margin-bottom:var(--dyte-space-3, 12px)}.message:last-child{margin-bottom:var(--dyte-space-0, 0px)}.prompt-text{margin-top:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-1, 4px);border-left-width:var(--dyte-border-width-sm, 1px);border-left-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}";

const DyteAiHome = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.handleSubmit = (e) => {
      var _a, _b;
      e.preventDefault();
      e.stopPropagation();
      this.messages = [
        ...this.messages,
        {
          action: 'Prompt',
          participantName: this.meeting.self.name,
          createdAt: new Date(),
          prompt: this.prompt,
          loading: true,
        },
      ];
      (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.sendMessageToChatGPT({ action: 'default', message: this.prompt });
      this.prompt = '';
    };
    this.handleSummarise = () => {
      var _a, _b;
      (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.sendMessageToChatGPT({ action: 'summarization' });
    };
    this.handleAgenda = () => {
      var _a, _b;
      (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.sendMessageToChatGPT({ action: 'agenda generation' });
    };
    this.handleMoM = () => {
      var _a, _b;
      (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.sendMessageToChatGPT({ action: 'action items generation' });
    };
    this.prompt = '';
    this.messages = [];
    this.meeting = undefined;
    this.initialMessages = undefined;
    this.middlewares = {};
  }
  handleChatGPTReply(data) {
    const existingMessage = this.messages.find((message) => data.action === 'default'
      ? message.id === data.id
      : message.id === data.id || message.action === this.mapMessageAction(data.action));
    if (existingMessage &&
      (existingMessage.loading || existingMessage.action !== this.mapMessageAction('default'))) {
      this.messages = [
        ...this.messages.map((message) => message.id === data.id || message.action === this.mapMessageAction(data.action)
          ? Object.assign(Object.assign({}, data), { action: this.mapMessageAction(data.action) }) : message),
      ];
    }
    else {
      this.messages = [...this.messages, Object.assign(Object.assign({}, data), { action: this.mapMessageAction(data.action) })];
    }
  }
  connectedCallback() {
    var _a, _b, _c;
    if (this.initialMessages) {
      this.messages = this.initialMessages.map((message) => (Object.assign(Object.assign({}, message), { action: this.mapMessageAction(message.action) })));
    }
    else {
      /**
       * NOTE: There is a latency in aiClient.aiMessages that's why sometimes
       * initialMessages comes as undefined. This is a really hacky solution
       * to wait for the aiMessages to set. But probably we can refactor this
       * in future.
       */
      if ((_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) {
        setTimeout(() => {
          var _a;
          this.messages = (_a = this.middlewares.speech.aiMesssages) === null || _a === void 0 ? void 0 : _a.map((message) => (Object.assign(Object.assign({}, message), { action: this.mapMessageAction(message.action) })));
        }, 1000);
      }
    }
    (_c = (_b = this.middlewares) === null || _b === void 0 ? void 0 : _b.speech) === null || _c === void 0 ? void 0 : _c.on('chatGPTReply', (data) => this.handleChatGPTReply(data));
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.off('chatGPTReply', (data) => this.handleChatGPTReply(data));
  }
  messagesUpdated() {
    // NOTE: I don't know why initially contentContainer ref is not set, That's
    // why this setTimeout. We can figure a better approach for this
    setTimeout(() => {
      smoothScrollToBottom(this.contentContainer, false);
    }, 100);
  }
  mapMessageAction(action) {
    switch (action) {
      case 'default':
        return 'Prompt';
      case 'summarization':
        return 'Summary';
      case 'agenda generation':
        return 'Agenda';
      case 'action items generation':
        return 'Action items';
    }
  }
  render() {
    return (h(Host, null, h("div", { class: "content scrollbar", ref: (el) => (this.contentContainer = el) }, h("p", { class: "public-message" }, "This conversation will be visible to everyone on the call."), !this.messages.length && (h("div", { class: "hint-message" }, h("p", null, "Ask ", h("i", null, "\"Hey AI, summarise this call\""), h("br", null), " or ", h("br", null), "Type ", h("i", null, "\"Hey AI, what is today's agenda?\"")))), this.messages.length > 0 && (h("div", { class: "" }, this.messages.map((message) => (h("div", { class: "message" }, h(ChatHead, { name: message.action, time: new Date(message.createdAt), now: new Date() }), h("p", { class: "subtitle" }, "Triggered by ", message.participantName), message.prompt && h("div", { class: "prompt-text" }, message.prompt), message.loading ? (h("div", { class: "loader" }, h("dyte-spinner", { size: "sm" }), "\u00A0\u00A0Generating...")) : (h("div", { class: "body" }, message.response)))))))), h("div", { class: "actions" }, h("span", null, "Quick actions:"), h("div", null, h("button", { onClick: this.handleSummarise }, "Summarise"), h("button", { onClick: this.handleAgenda }, "Agenda"), h("button", { onClick: this.handleMoM }, "MoM"))), h("form", { class: "prompt", onSubmit: this.handleSubmit }, h("input", { value: this.prompt, onInput: (e) => {
        this.prompt = e.target.value;
      }, placeholder: "Type your prompt..." }))));
  }
  static get watchers() { return {
    "messages": ["messagesUpdated"]
  }; }
};
DyteAiHome.style = dyteAiHomeCss;

var dyteAiHome_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ai_home: DyteAiHome
});

const dyteAiToggleCss = ":host{display:block}";

const DyteAiToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.variant = 'button';
    this.states = undefined;
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.middlewares = {};
    this.aiActive = false;
  }
  statesChanged(s) {
    const states = s || state;
    this.aiActive = states.activeAI;
  }
  toggleAI() {
    const states = this.states || state;
    this.aiActive = !(states === null || states === void 0 ? void 0 : states.activeAI);
    this.stateUpdate.emit({
      activeAI: this.aiActive,
      activeMoreMenu: false,
      activeSidebar: false,
    });
    state.activeAI = this.aiActive;
    state.activeMoreMenu = false;
  }
  render() {
    const text = this.t('ai.meeting_ai');
    if (!this.middlewares.speech) {
      return null;
    }
    return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.aiActive }, onClick: () => this.toggleAI(), icon: this.iconPack.meeting_ai, label: text, variant: this.variant, brandIcon: true })));
  }
  static get watchers() { return {
    "states": ["statesChanged"]
  }; }
};
DyteAiToggle.style = dyteAiToggleCss;

var dyteAiToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ai_toggle: DyteAiToggle
});

const dyteAiTranscriptionsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.head{display:flex;align-items:center}.head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}*{box-sizing:border-box;border-width:0;border-style:solid}:host{width:100%;display:flex;flex-direction:column}.processing{display:flex;flex:1 1 0%;flex-direction:column;align-items:center;justify-content:center}.content{box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-3, 12px);flex:1 0 0px;overflow-y:scroll}.started-message{margin-top:var(--dyte-space-5, 20px);margin-bottom:var(--dyte-space-5, 20px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.search-bar{height:var(--dyte-space-14, 56px);width:100%;border-bottom-width:var(--dyte-border-width-sm, 1px);--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));padding:var(--dyte-space-3, 12px)}input{height:100%;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-size:14px;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.caption-view{height:var(--dyte-space-12, 48px);width:100%;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));display:flex;align-items:center;justify-content:space-between;font-size:14px}.message .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;word-break:break-word}.message{margin-bottom:var(--dyte-space-3, 12px)}.message:last-child{margin-bottom:var(--dyte-space-0, 0px)}";

const DyteAiTranscriptions = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.participantQuery = '';
    this.isProcessing = false;
    this.captionViewEnabled = false;
    this.t = useLanguage();
    this.meeting = undefined;
    this.transcriptions = [];
    this.initialTranscriptions = undefined;
    this.middlewares = {};
  }
  transcriptionHandler(data) {
    this.transcriptions = [...this.transcriptions, data];
  }
  connectedCallback() {
    var _a, _b;
    if (this.initialTranscriptions) {
      this.transcriptions = [...this.initialTranscriptions];
    }
    (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.on('transcription', (data) => this.transcriptionHandler(data));
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.middlewares) === null || _a === void 0 ? void 0 : _a.speech) === null || _b === void 0 ? void 0 : _b.off('transcription', (data) => this.transcriptionHandler(data));
  }
  transcriptionsChanged() {
    setTimeout(() => {
      smoothScrollToBottom(this.contentContainer, false);
    }, 100);
  }
  render() {
    return (h(Host, null, h("div", { class: "search-bar" }, h("input", { type: "text", placeholder: "Search Participant", value: this.participantQuery, onInput: (e) => (this.participantQuery = e.target.value) })), this.isProcessing && (h("div", { class: "processing" }, h("p", null, "Processing audio...."))), !this.isProcessing && (h("div", { class: "content scrollbar", ref: (el) => (this.contentContainer = el) }, h("div", { class: "started-message" }, "Transcription started"), this.transcriptions
      .filter((t) => this.participantQuery
      ? t.name.toLowerCase().includes(this.participantQuery.toLowerCase())
      : true)
      .map((transcription) => (h("div", { class: "message" }, h(ChatHead, { name: transcription.name, time: new Date(transcription.date), now: new Date() }), h("div", { class: "body" }, transcription.transcript)))))), this.captionViewEnabled && h("dyte-ai-caption", null)));
  }
  static get watchers() { return {
    "transcriptions": ["transcriptionsChanged"]
  }; }
};
DyteAiTranscriptions.style = dyteAiTranscriptionsCss;

var dyteAiTranscriptions_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ai_transcriptions: DyteAiTranscriptions
});

var __classPrivateFieldSet = function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __rest = function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _DraftStateManager_instances, _DraftStateManager_hasLocalChanges, _DraftStateManager_state, _DraftStateManager_participantsNewMeetingMap, _DraftStateManager_participantsOldMeetingMap, _DraftStateManager_meetingParticipantsMap, _DraftStateManager_allParticipantsMap, _DraftStateManager_allMeetingsMap, _DraftStateManager_meetingsToUpdate, _DraftStateManager_meetingsToDelete, _DraftStateManager_init, _DraftStateManager_addNewMeetingToState, _DraftStateManager_addNewParticipantToState, _DraftStateManager_replaceDraftMeetingIds, _DraftStateManager_getMeetingParticipants;
class DraftStateManager {
  constructor() {
    _DraftStateManager_instances.add(this);
    _DraftStateManager_hasLocalChanges.set(this, false);
    _DraftStateManager_state.set(this, void 0);
    _DraftStateManager_participantsNewMeetingMap.set(this, void 0);
    _DraftStateManager_participantsOldMeetingMap.set(this, void 0);
    _DraftStateManager_meetingParticipantsMap.set(this, void 0);
    _DraftStateManager_allParticipantsMap.set(this, void 0);
    _DraftStateManager_allMeetingsMap.set(this, void 0);
    _DraftStateManager_meetingsToUpdate.set(this, void 0);
    _DraftStateManager_meetingsToDelete.set(this, void 0);
  }
  get hasLocalChanges() {
    return __classPrivateFieldGet(this, _DraftStateManager_hasLocalChanges, "f");
  }
  get currentState() {
    let parentMeeting;
    let meetings = [];
    Array.from(__classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").keys()).forEach((meetingId) => {
      const meeting = __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").get(meetingId);
      if (meeting.isParent) {
        parentMeeting = Object.assign(Object.assign({}, meeting), { participants: __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_getMeetingParticipants).call(this, meetingId) });
      }
      else {
        meetings.push(Object.assign(Object.assign({}, meeting), { participants: __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_getMeetingParticipants).call(this, meetingId) }));
      }
    });
    return {
      parentMeeting,
      meetings,
    };
  }
  get allConnectedMeetings() {
    return this.currentState.meetings.sort((a, b) => a.title.localeCompare(b.title));
  }
  get allParticipants() {
    return Array.from(__classPrivateFieldGet(this, _DraftStateManager_allParticipantsMap, "f").values());
  }
  get unassignedParticipants() {
    return __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_getMeetingParticipants).call(this, __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.id);
  }
  /**
   * get participants of a meeting
   */
  getParticipantsForMeeting(meetingId) {
    return __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_getMeetingParticipants).call(this, meetingId);
  }
  /**
   * add a new connected meeting
   */
  addNewMeeting() {
    __classPrivateFieldSet(this, _DraftStateManager_hasLocalChanges, true, "f");
    const _a = createDraftRoom(), meeting = __rest(_a, ["participants"]);
    __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_addNewMeetingToState).call(this, Object.assign(Object.assign({}, meeting), { isParent: false }));
    return meeting;
  }
  /**
   * add multiple new connected meetings
   */
  addNewMeetings(count) {
    return Array.from({ length: count }).map(() => this.addNewMeeting());
  }
  /**
   * update a meeting's title
   */
  updateMeetingTitle(meetingId, newTitle) {
    __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").get(meetingId).title = newTitle;
    if (!isDraftRoom(meetingId)) {
      __classPrivateFieldGet(this, _DraftStateManager_meetingsToUpdate, "f").add(meetingId);
    }
  }
  /**
   * deleteMeeting
   */
  deleteMeeting(meetingId) {
    __classPrivateFieldSet(this, _DraftStateManager_hasLocalChanges, true, "f");
    const meeting = __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").get(meetingId);
    const participants = __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_getMeetingParticipants).call(this, meeting.id).map(participantIdentifier);
    this.assignParticipantsToMeeting(participants, __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.id);
    __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").delete(meeting.id);
    __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").delete(meeting.id);
    if (!isDraftRoom(meeting.id)) {
      __classPrivateFieldGet(this, _DraftStateManager_meetingsToDelete, "f").add(meeting.id);
    }
  }
  /**
   * assign participants to a meeting
   */
  assignParticipantsToMeeting(customParticipantIds, destinationMeetingId) {
    __classPrivateFieldSet(this, _DraftStateManager_hasLocalChanges, true, "f");
    customParticipantIds.forEach((participantId) => {
      const currentMeetingId = __classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").get(participantId);
      __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").get(currentMeetingId).delete(participantId);
      __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").get(destinationMeetingId).add(participantId);
      __classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").set(participantId, destinationMeetingId);
    });
    return this.currentState;
  }
  /**
   * assign participants randomly
   */
  assignParticipantsRandomly() {
    const splits = splitCollection(this.unassignedParticipants, this.allConnectedMeetings.length);
    this.allConnectedMeetings.forEach((meeting, index) => {
      const toAssign = splits[index];
      if (toAssign && toAssign.length !== 0) {
        this.assignParticipantsToMeeting(toAssign.map((participant) => participant.customParticipantId), meeting.id);
      }
    });
    return this.currentState;
  }
  /**
   * unassign participants
   */
  unassignParticipants(customParticipantIds) {
    const destinationMeetingId = __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.id;
    return this.assignParticipantsToMeeting(customParticipantIds, destinationMeetingId);
  }
  /**
   * unassign all participants
   */
  unassignAllParticipants() {
    const destinationMeetingId = __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.id;
    const customParticipantIds = this.allParticipants.map(participantIdentifier);
    return this.assignParticipantsToMeeting(customParticipantIds, destinationMeetingId);
  }
  /**
   * update current state
   */
  updateCurrentState(state) {
    if (!__classPrivateFieldGet(this, _DraftStateManager_hasLocalChanges, "f")) {
      __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_init).call(this, state);
    }
    [state.parentMeeting, ...state.meetings].forEach((meeting, index) => {
      const draftMeeting = Object.assign(Object.assign({}, meeting), { isParent: index === 0 });
      __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_addNewMeetingToState).call(this, draftMeeting);
      meeting.participants.forEach((participant) => {
        __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_addNewParticipantToState).call(this, participant, draftMeeting);
      });
    });
  }
  get meetingsToCreate() {
    return this.allConnectedMeetings
      .filter((meeting) => isDraftRoom(meeting.id))
      .map(({ id, title }) => ({ id, title }));
  }
  get meetingsToUpdate() {
    return this.allConnectedMeetings
      .filter((meeting) => __classPrivateFieldGet(this, _DraftStateManager_meetingsToUpdate, "f").has(meeting.id))
      .map(({ id, title }) => ({ id, title }));
  }
  get meetingsToDelete() {
    return Array.from(__classPrivateFieldGet(this, _DraftStateManager_meetingsToDelete, "f"));
  }
  get participantsToMove() {
    // gather participants
    const moveMap = new Map();
    Array.from(__classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").keys()).forEach((participantId) => {
      const sourceMeetingId = __classPrivateFieldGet(this, _DraftStateManager_participantsOldMeetingMap, "f").get(participantId);
      const destinationMeetingId = __classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").get(participantId);
      if (sourceMeetingId === destinationMeetingId)
        return;
      const key = `${sourceMeetingId}__${destinationMeetingId}`;
      if (!moveMap.has(key)) {
        moveMap.set(key, []);
      }
      const participantDetails = __classPrivateFieldGet(this, _DraftStateManager_allParticipantsMap, "f").get(participantId);
      moveMap.get(key).push(participantDetails.id);
    });
    return Array.from(moveMap.keys()).map((key) => {
      const [sourceMeetingId, destinationMeetingId] = key.split('__');
      return {
        sourceMeetingId,
        destinationMeetingId,
        participantIds: moveMap.get(key),
      };
    });
  }
  async applyChanges(meeting) {
    // create new rooms
    const createMeetingsPromise = this.meetingsToCreate.length !== 0
      ? meeting.connectedMeetings.createMeetings(this.meetingsToCreate)
      : Promise.resolve([]);
    // update old rooms titles
    const updateMeetingsPromise = this.meetingsToUpdate.length !== 0
      ? meeting.connectedMeetings.updateMeetings(this.meetingsToUpdate)
      : Promise.resolve();
    const [createMeetingsResponse] = await Promise.all([
      createMeetingsPromise,
      updateMeetingsPromise,
    ]);
    // replace temporary ids
    if (createMeetingsResponse) {
      createMeetingsResponse.forEach((meeting) => {
        this.meetingsToCreate.forEach((draftMeeting) => {
          if (draftMeeting.title === meeting.title) {
            __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_replaceDraftMeetingIds).call(this, __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").get(draftMeeting.id), meeting.id);
          }
        });
      });
    }
    // move participants (no async)
    if (this.participantsToMove.length !== 0) {
      this.participantsToMove.forEach(({ sourceMeetingId, destinationMeetingId, participantIds }) => {
        meeting.connectedMeetings.moveParticipants(sourceMeetingId, destinationMeetingId, participantIds);
      });
    }
    // delete rooms
    if (this.meetingsToDelete.length !== 0) {
      meeting.connectedMeetings.deleteMeetings(this.meetingsToDelete);
    }
  }
  /**
   * discard local changes
   */
  discardChanges() {
    __classPrivateFieldSet(this, _DraftStateManager_hasLocalChanges, false, "f");
    this.updateCurrentState(__classPrivateFieldGet(this, _DraftStateManager_state, "f"));
    return this.currentState;
  }
}
_DraftStateManager_hasLocalChanges = new WeakMap(), _DraftStateManager_state = new WeakMap(), _DraftStateManager_participantsNewMeetingMap = new WeakMap(), _DraftStateManager_participantsOldMeetingMap = new WeakMap(), _DraftStateManager_meetingParticipantsMap = new WeakMap(), _DraftStateManager_allParticipantsMap = new WeakMap(), _DraftStateManager_allMeetingsMap = new WeakMap(), _DraftStateManager_meetingsToUpdate = new WeakMap(), _DraftStateManager_meetingsToDelete = new WeakMap(), _DraftStateManager_instances = new WeakSet(), _DraftStateManager_init = function _DraftStateManager_init(state) {
  __classPrivateFieldSet(this, _DraftStateManager_state, state, "f");
  __classPrivateFieldSet(this, _DraftStateManager_allMeetingsMap, new Map(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_allParticipantsMap, new Map(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_meetingsToUpdate, new Set(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_meetingsToDelete, new Set(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_meetingParticipantsMap, new Map(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_participantsNewMeetingMap, new Map(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_participantsOldMeetingMap, new Map(), "f");
  __classPrivateFieldSet(this, _DraftStateManager_participantsOldMeetingMap, new Map(), "f");
  __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.participants.forEach((participant) => {
    __classPrivateFieldGet(this, _DraftStateManager_participantsOldMeetingMap, "f").set(participantIdentifier(participant), __classPrivateFieldGet(this, _DraftStateManager_state, "f").parentMeeting.id);
  });
  __classPrivateFieldGet(this, _DraftStateManager_state, "f").meetings.forEach((meeting) => {
    meeting.participants.forEach((participant) => {
      __classPrivateFieldGet(this, _DraftStateManager_participantsOldMeetingMap, "f").set(participantIdentifier(participant), meeting.id);
    });
  });
}, _DraftStateManager_addNewMeetingToState = function _DraftStateManager_addNewMeetingToState(meeting) {
  if (!__classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").has(meeting.id)) {
    __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").set(meeting.id, meeting);
    __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").set(meeting.id, new Set());
  }
}, _DraftStateManager_addNewParticipantToState = function _DraftStateManager_addNewParticipantToState(participant, meeting) {
  if (__classPrivateFieldGet(this, _DraftStateManager_allParticipantsMap, "f").has(participantIdentifier(participant))) {
    return;
  }
  __classPrivateFieldGet(this, _DraftStateManager_allParticipantsMap, "f").set(participantIdentifier(participant), participant);
  __classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").set(participantIdentifier(participant), meeting.id);
  __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").get(meeting.id).add(participantIdentifier(participant));
}, _DraftStateManager_replaceDraftMeetingIds = function _DraftStateManager_replaceDraftMeetingIds(draftMeeting, realId) {
  const draftId = draftMeeting.id;
  __classPrivateFieldGet(this, _DraftStateManager_instances, "m", _DraftStateManager_addNewMeetingToState).call(this, Object.assign(Object.assign({}, draftMeeting), { id: realId }));
  __classPrivateFieldGet(this, _DraftStateManager_allMeetingsMap, "f").delete(draftId);
  const participantSet = __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").get(draftId);
  __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").set(realId, participantSet);
  __classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").delete(draftId);
  Array.from(__classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").keys()).forEach((participantId) => {
    if (__classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").get(participantId) === draftId) {
      __classPrivateFieldGet(this, _DraftStateManager_participantsNewMeetingMap, "f").set(participantId, realId);
    }
  });
}, _DraftStateManager_getMeetingParticipants = function _DraftStateManager_getMeetingParticipants(meetingId) {
  const participantIds = Array.from(__classPrivateFieldGet(this, _DraftStateManager_meetingParticipantsMap, "f").get(meetingId));
  return participantIds.map((id) => __classPrivateFieldGet(this, _DraftStateManager_allParticipantsMap, "f").get(id));
};

const dyteBreakoutRoomsManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.color-brand{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.color-danger{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.loading-content{height:var(--dyte-space-60, 240px);width:var(--dyte-space-96, 384px);padding:var(--dyte-space-9, 36px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;align-items:center;justify-content:center}.room-config{overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-96, 384px);padding-left:var(--dyte-space-9, 36px);padding-right:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-10, 40px);padding-bottom:var(--dyte-space-10, 40px)}header{margin-bottom:var(--dyte-space-8, 32px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);font-size:24px;font-weight:600}header dyte-icon{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}.create-room{margin-bottom:var(--dyte-space-4, 16px);display:flex;align-items:center;gap:var(--dyte-space-3, 12px);width:100%}.create-room p{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-1, 4px);font-size:16px}.distribution-hint{margin-bottom:var(--dyte-space-8, 32px);font-size:14px;font-weight:400;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.distribution-hint em{font-style:normal;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}footer{display:flex;flex-direction:row;vertical-align:middle;justify-content:center}footer dyte-button{width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}label{margin-bottom:var(--dyte-space-3, 12px);font-weight:400;color:rgb(var(--dyte-colors-text-1000, 255 255 255));opacity:0.4}.participant-config-wrapper{width:850px;height:595px;max-width:100%;max-height:100%;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));display:flex;flex-direction:column}.participant-config-actions{display:flex;justify-content:space-between;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-5, 20px);padding-bottom:var(--dyte-space-5, 20px);border-bottom-right-radius:var(--dyte-border-radius-md, 8px);border-bottom-left-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.participant-config{display:flex;flex-grow:1;flex-direction:row;overflow:hidden}aside{box-sizing:border-box;display:flex;width:var(--dyte-space-96, 384px);flex-grow:1;flex-direction:column;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-4, 16px);border-right-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-right-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity))}aside header{margin-bottom:var(--dyte-space-4, 16px);width:100%;padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px);padding-top:var(--dyte-space-8, 32px);font-size:20px;font-weight:500;line-height:2rem}.shuffle-button{display:flex;flex-direction:row;align-items:center}.shuffle-button dyte-icon{height:var(--dyte-space-8, 32px)}.participants-assign-actions{display:flex;flex-direction:row;align-items:center;justify-content:space-between;font-size:14px;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-2, 8px);margin-left:calc(var(--dyte-space-8, 32px) * -1);margin-right:calc(var(--dyte-space-4, 16px) * -1);padding-top:var(--dyte-space-0\\.5, 2px);padding-bottom:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.participants-assign-actions .deselect-button{height:var(--dyte-space-6, 24px)}.participants-assign-actions .deselect-button:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.assign-rooms{padding:var(--dyte-space-8, 32px);display:flex;width:100%;flex-direction:column}.assign-rooms .disabled{opacity:0.2}.assign-rooms .back{display:flex;cursor:pointer;flex-direction:row;align-items:center;justify-content:flex-start;padding:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-0, 0px);font-size:14px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.assign-rooms .back dyte-icon{height:var(--dyte-space-5, 20px)}.assign-rooms .row{display:flex;flex-direction:row;align-items:center;justify-content:flex-start;gap:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}.assign-rooms .row-header{margin:var(--dyte-space-0, 0px);font-size:16px;line-height:2rem}.assign-rooms .cta-buttons{display:flex;align-items:center;justify-content:flex-start;gap:var(--dyte-space-2, 8px)}.assign-rooms .cta-buttons dyte-button div{display:flex;flex-direction:row;align-items:center}.assign-rooms .cta-buttons dyte-button div dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.rooms{margin-bottom:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-1, 4px);display:flex;flex-grow:1;flex-direction:column;gap:var(--dyte-space-2, 8px);overflow-y:auto;max-height:500px}.rooms::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px)}.rooms::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.rooms::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.breakout-actions{display:flex;flex-direction:row;align-items:center;justify-content:flex-end;gap:var(--dyte-space-2, 8px)}.breakout-actions .start-breakout-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.breakout-actions .close-breakout-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}.breakout-actions .update-breakout-button{background-color:transparent;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity));border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}.status-bar{display:flex;align-items:center;font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));width:var(--dyte-space-80, 320px)}.ephemeral-status{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.ephemeral-status dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.room-switcher-container{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));width:468px;padding:var(--dyte-space-8, 32px)}.add-room-jumbo-btn div{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.add-room-jumbo-btn div dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.br-primary-btn:not([disabled]){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-primary-btn:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}.br-secondary-btn:not([disabled]){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-secondary-btn:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

const MIN_ROOMS = 1;
const DyteBreakoutRoomsManager = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.updateLocalState = (payload) => {
      this.stateManager.updateCurrentState(payload);
      this.draftState = this.stateManager.currentState;
      if (this.meeting.connectedMeetings.isActive) {
        this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { mode: 'edit' });
      }
      if (this.roomConfig.mode === 'create' && !this.meeting.connectedMeetings.isActive) {
        resetRoomCount();
      }
      if (['edit', 'view'].includes(this.roomConfig.mode)) {
        this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { rooms: payload.meetings.length, step: 'participants-config' });
        this.selectedParticipants = [];
      }
    };
    this.onAddNewRoom = () => {
      this.stateManager.addNewMeeting();
      this.draftState = this.stateManager.currentState;
      this.selectorRef.scrollTo({ top: this.selectorRef.scrollHeight, behavior: 'smooth' });
    };
    this.onRoomUpdate = (event) => {
      const { detail } = event;
      this.stateManager.updateMeetingTitle(detail.id, detail.title);
      this.draftState = this.stateManager.currentState;
    };
    this.onRoomDelete = (id) => {
      const toDelete = this.stateManager.allConnectedMeetings.find((meeting) => meeting.id === id);
      if (toDelete) {
        this.stateManager.deleteMeeting(id);
        this.draftState = this.stateManager.currentState;
      }
    };
    this.unassignParticipant = (id) => {
      this.stateManager.unassignParticipants([id]);
      this.draftState = this.stateManager.currentState;
    };
    this.onUnassignAll = () => {
      this.stateManager.unassignAllParticipants();
      this.draftState = this.stateManager.currentState;
    };
    this.assignParticipantsToRoom = (destinationMeetingId) => {
      if (this.selectedParticipants.length === 0 || this.assigningParticipants == false)
        return;
      this.stateManager.assignParticipantsToMeeting(this.selectedParticipants, destinationMeetingId);
      this.draftState = this.stateManager.currentState;
      this.selectedParticipants = [];
      this.assigningParticipants = false;
      this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.participants_assigned'));
    };
    this.handleClose = (stateUpdate, store) => {
      stateUpdate.emit({
        activeBreakoutRoomsManager: {
          active: true,
        },
      });
      store.activeBreakoutRoomsManager = {
        active: true,
      };
    };
    this.enableConfirmationModal = (modalType = 'start-breakout') => {
      let activeConfirmationModal = {
        active: true,
        header: 'breakout_rooms.confirm_modal.start_breakout.header',
        content: 'breakout_rooms.confirm_modal.start_breakout.content',
        variant: 'primary',
        cancelText: 'breakout_rooms.confirm_modal.start_breakout.cancelText',
        ctaText: 'breakout_rooms.confirm_modal.start_breakout.ctaText',
        onClick: () => this.applyChanges(),
        onClose: this.handleClose,
      };
      if (modalType === 'close-breakout') {
        activeConfirmationModal = {
          active: true,
          header: 'breakout_rooms.confirm_modal.close_breakout.header',
          content: 'breakout_rooms.confirm_modal.close_breakout.content',
          variant: 'danger',
          cancelText: 'cancel',
          ctaText: 'breakout_rooms.confirm_modal.close_breakout.ctaText',
          onClick: () => this.closeBreakout(),
          onClose: this.handleClose,
        };
      }
      this.stateUpdate.emit({
        activeBreakoutRoomsManager: { active: false },
        activeConfirmationModal,
      });
      state.activeBreakoutRoomsManager = { active: false };
      state.activeConfirmationModal = activeConfirmationModal;
    };
    this.close = () => {
      var _a;
      this.stateManager.discardChanges();
      (_a = this.stateUpdate) === null || _a === void 0 ? void 0 : _a.emit({
        activeBreakoutRoomsManager: {
          active: false,
        },
      });
      state.activeBreakoutRoomsManager = { active: false };
    };
    this.applyChanges = async () => {
      this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { applyingChanges: true });
      await this.stateManager.applyChanges(this.meeting);
      this.close();
      this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { applyingChanges: false });
    };
    this.loading = false;
    this.roomConfig = {
      rooms: 2,
      step: 'room-config',
      mode: 'create',
      applyingChanges: false,
    };
    this.draftState = undefined;
    this.assigningParticipants = false;
    this.selectedParticipants = [];
    this.ephemeralStatusText = '';
    this.isDragMode = false;
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  onSelectedParticipantsChanged(participants) {
    if (participants.length > 0)
      this.assigningParticipants = true;
    else
      this.assigningParticipants = false;
  }
  connectedCallback() {
    this.permissions = this.meeting.self.permissions.connectedMeetings;
    this.meeting.connectedMeetings.on('stateUpdate', this.updateLocalState);
    this.meeting.connectedMeetings.on('changingMeeting', this.close);
    this.stateManager = new DraftStateManager();
    this.fetchRoomState();
  }
  disconnectedCallback() {
    this.meeting.connectedMeetings.off('stateUpdate', this.updateLocalState);
    this.meeting.connectedMeetings.off('changingMeeting', this.close);
  }
  async fetchRoomState() {
    this.loading = true;
    await this.meeting.connectedMeetings.getConnectedMeetings();
    this.loading = false;
  }
  setEphemeralStatus(text) {
    this.ephemeralStatusText = text;
    setTimeout(() => {
      this.ephemeralStatusText = '';
    }, 3000);
  }
  onCreateRooms() {
    this.selectedParticipants = [];
    this.stateManager.addNewMeetings(this.roomConfig.rooms);
    this.draftState = this.stateManager.currentState;
    // move to next step -> participants-config
    this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { step: 'participants-config' });
  }
  onParticipantDelete(event) {
    const { detail } = event;
    const id = participantIdentifier(detail);
    if (id == null)
      return;
    this.unassignParticipant(id);
  }
  toggleDragMode(e) {
    this.isDragMode = e.detail;
  }
  assignParticipantsRandomly() {
    if (this.stateManager.unassignedParticipants.length === 0)
      return;
    this.stateManager.assignParticipantsRandomly();
    this.draftState = this.stateManager.currentState;
    this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.participants_assigned_randomly'));
  }
  async joinRoom(destinationMeetingId) {
    const participantId = participantIdentifier(this.meeting.self);
    this.stateManager.assignParticipantsToMeeting([participantId], destinationMeetingId);
    await this.applyChanges();
  }
  async closeBreakout() {
    this.stateManager.allConnectedMeetings.forEach((meeting) => this.stateManager.deleteMeeting(meeting.id));
    await this.applyChanges();
  }
  updateSelectedParticipants(e) {
    this.selectedParticipants = e.detail;
  }
  updateAllParticipants(e) {
    this.selectedParticipants = e.detail;
  }
  getStatusText() {
    if (this.ephemeralStatusText !== '')
      return this.ephemeralStatusText;
    let statusText = '';
    if (this.roomConfig.mode === 'create') {
      statusText = this.t('breakout_rooms.status.assign_multiple');
      if (this.selectedParticipants.length !== 0) {
        statusText = this.t('breakout_rooms.status.select_room');
      }
    }
    return statusText;
  }
  getApproxDistribution() {
    const num = this.stateManager.unassignedParticipants.length / (this.roomConfig.rooms || MIN_ROOMS);
    return Math.max(MIN_ROOMS, Math.round(num));
  }
  deselectAll() {
    this.selectedParticipants = [];
  }
  async discardChanges() {
    this.stateManager.discardChanges();
    await this.fetchRoomState();
    this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.changes_discarded'));
  }
  shouldShowOnlyRoomSwitcher() {
    return this.permissions.canAlterConnectedMeetings === false;
  }
  getPermittedRooms() {
    if (this.permissions.canAlterConnectedMeetings || this.permissions.canSwitchConnectedMeetings) {
      return this.stateManager.allConnectedMeetings;
    }
    return this.stateManager.allConnectedMeetings.filter((cMeeting) => cMeeting.id === this.meeting.meta.roomName);
  }
  renderMainRoomMaybe() {
    if (!(this.meeting.connectedMeetings.isActive && this.permissions.canSwitchToParentMeeting)) {
      return null;
    }
    return (h("dyte-breakout-room-manager", { key: this.stateManager.currentState.parentMeeting['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, meeting: this.meeting, mode: this.roomConfig.mode, onParticipantsAdd: () => this.assignParticipantsToRoom(this.stateManager.currentState.parentMeeting['id']), onRoomJoin: () => this.joinRoom(this.stateManager.currentState.parentMeeting['id']), onUpdate: this.onRoomUpdate, states: this.states, room: Object.assign({}, this.stateManager.currentState.parentMeeting), iconPack: this.iconPack, t: this.t }));
  }
  renderRoomSwitcher() {
    return (h(Host, null, h("div", { class: "room-switcher-container" }, h("header", null, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("span", null, this.t('breakout_rooms.join_breakout_header'))), h("div", { class: "rooms", ref: (el) => (this.selectorRef = el) }, this.renderMainRoomMaybe(), this.getPermittedRooms().map((room, idx) => {
      return (h("dyte-breakout-room-manager", { key: room['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, defaultExpanded: idx === 0, meeting: this.meeting, mode: this.roomConfig.mode, onDelete: () => this.onRoomDelete(room['id']), onParticipantsAdd: () => this.assignParticipantsToRoom(room['id']), onRoomJoin: () => this.joinRoom(room['id']), states: this.states, room: Object.assign({}, room), iconPack: this.iconPack, t: this.t, allowDelete: false }));
    })))));
  }
  renderLoading() {
    return (h(Host, null, h("div", { class: "loading-content" }, h("dyte-spinner", { size: "xl" }))));
  }
  renderRoomConfig() {
    return (h(Host, null, h("div", { class: "room-config" }, h("header", null, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("span", null, this.t('breakout_rooms.room_config_header'))), h("div", { class: "create-room" }, h("p", null, this.t('breakout_rooms.num_of_rooms')), h("dyte-counter", { value: this.roomConfig.rooms, minValue: MIN_ROOMS, iconPack: this.iconPack, t: this.t, onValueChange: (val) => {
        this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { rooms: Math.max(+val.detail, MIN_ROOMS) });
      } })), h("span", { class: "distribution-hint" }, `${this.t('breakout_rooms.approx')}${' '}`, ' ', h("em", null, this.getApproxDistribution(), " ", this.t('breakout_rooms.participants_per_room')), ' ', this.t('breakout_rooms.division_text')), h("footer", null, h("dyte-button", { kind: "button", iconPack: this.iconPack, t: this.t, size: "lg", title: this.t('create'), disabled: this.roomConfig.rooms === 0, onClick: () => this.onCreateRooms() }, this.t('create'))))));
  }
  render() {
    if (this.loading) {
      return this.renderLoading();
    }
    if (this.shouldShowOnlyRoomSwitcher()) {
      return this.renderRoomSwitcher();
    }
    if (this.roomConfig.step === 'room-config') {
      return this.renderRoomConfig();
    }
    // participant config
    return (h(Host, null, h("div", { class: "participant-config-wrapper" }, h("div", { class: "participant-config" }, h("aside", { part: "menu" }, h("header", null, this.t('breakout_rooms.assign_participants')), h("dyte-breakout-room-participants", { meeting: this.meeting, iconPack: this.iconPack, t: this.t, participantIds: this.stateManager.unassignedParticipants.map(participantIdentifier), selectedParticipantIds: this.selectedParticipants }, h("dyte-tooltip", { label: this.t('breakout_rooms.shuffle_participants'), iconPack: this.iconPack, t: this.t, slot: "shuffle-button" }, h("dyte-button", { disabled: this.roomConfig.mode === 'edit' ||
        this.stateManager.unassignedParticipants.length === 0, iconPack: this.iconPack, t: this.t, kind: "button", variant: "secondary", size: "md", onClick: () => this.assignParticipantsRandomly(), class: "shuffle-button br-primary-btn" }, h("dyte-icon", { icon: this.iconPack.shuffle, iconPack: this.iconPack, t: this.t })))), this.selectedParticipants.length !== 0 && (h("div", { class: "participants-assign-actions" }, h("span", null, `${this.selectedParticipants.length} ${this.t('breakout_rooms.selected')}`), h("dyte-button", { disabled: this.roomConfig.mode === 'edit', iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", size: "md", onClick: () => this.deselectAll(), class: "deselect-button color-danger" }, this.t('breakout_rooms.deselect'))))), h("div", { class: "assign-rooms" }, h("div", { class: "row" }, h("p", { class: "row-header" }, this.t('breakout_rooms.rooms'), " (", this.stateManager.allConnectedMeetings.length, ")"), !this.assigningParticipants && (h("div", { class: "cta-buttons" }, h("dyte-button", { kind: "button", variant: "secondary", iconPack: this.iconPack, t: this.t, class: "br-primary-btn" }, h("div", { onClick: this.onAddNewRoom }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }), this.t('breakout_rooms.add_room'))), this.stateManager.allConnectedMeetings.flatMap((m) => m.participants)
      .length !== 0 && (h("dyte-button", { kind: "button", variant: "ghost", onClick: this.onUnassignAll, iconPack: this.iconPack, t: this.t }, this.t('breakout_rooms.unassign_all')))))), h("div", { class: "rooms", ref: (el) => (this.selectorRef = el) }, this.renderMainRoomMaybe(), this.getPermittedRooms().map((room, idx) => {
      return (h("dyte-breakout-room-manager", { key: room['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, defaultExpanded: idx === 0, meeting: this.meeting, mode: this.roomConfig.mode, onDelete: () => this.onRoomDelete(room['id']), onParticipantsAdd: () => this.assignParticipantsToRoom(room['id']), onRoomJoin: () => this.joinRoom(room['id']), onUpdate: this.onRoomUpdate, states: this.states, room: Object.assign({}, room), iconPack: this.iconPack, t: this.t, allowDelete: this.stateManager.allConnectedMeetings.length > MIN_ROOMS }));
    }), h("dyte-button", { kind: "button", variant: "secondary", iconPack: this.iconPack, t: this.t, onClick: this.onAddNewRoom, class: "add-room-jumbo-btn br-secondary-btn" }, h("div", null, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }), h("span", null, this.t('breakout_rooms.add_room_brief'))))))), h("div", { class: "participant-config-actions" }, h("div", { class: { 'status-bar': true, 'ephemeral-status': this.ephemeralStatusText !== '' } }, this.ephemeralStatusText !== '' && (h("dyte-icon", { icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t })), this.getStatusText()), h("div", { class: "breakout-actions" }, this.roomConfig.mode === 'create' && this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "start-breakout-button", onClick: () => this.enableConfirmationModal('start-breakout') }, this.t('breakout_rooms.start_breakout'))), this.roomConfig.mode === 'edit' &&
      this.stateManager.hasLocalChanges &&
      this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "color-danger", variant: "ghost", onClick: () => this.discardChanges() }, this.t('breakout_rooms.discard_changes'))), this.roomConfig.mode === 'edit' &&
      this.stateManager.hasLocalChanges &&
      this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "update-breakout-button", onClick: this.applyChanges }, this.t('breakout_rooms.update_breakout'))), this.roomConfig.mode === 'edit' &&
      !this.stateManager.hasLocalChanges &&
      this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "close-breakout-button", onClick: () => this.enableConfirmationModal('close-breakout') }, this.t('breakout_rooms.close_breakout'))))))));
  }
  static get watchers() { return {
    "selectedParticipants": ["onSelectedParticipantsChanged"]
  }; }
};
DyteBreakoutRoomsManager.style = dyteBreakoutRoomsManagerCss;

var dyteBreakoutRoomsManager_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_breakout_rooms_manager: DyteBreakoutRoomsManager
});

const dyteBreakoutRoomsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteBreakoutRoomsToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.breakoutRoomToggle = () => {
      var _a, _b, _c;
      const mode = this.meeting.connectedMeetings.isActive ? 'view' : 'create';
      this.stateUpdate.emit({
        activeBreakoutRoomsManager: {
          active: !((_b = (_a = this.states) === null || _a === void 0 ? void 0 : _a.activeBreakoutRoomsManager) === null || _b === void 0 ? void 0 : _b.active),
          mode,
        },
      });
      state.activeBreakoutRoomsManager = {
        active: !((_c = state.activeBreakoutRoomsManager) === null || _c === void 0 ? void 0 : _c.active),
        mode,
      };
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    if (!canToggleBreakout(this.meeting))
      return;
    return (h(Host, { title: this.t('breakout_rooms') }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.breakoutRoomToggle, icon: this.iconPack.breakout_rooms, label: this.t('breakout_rooms'), variant: this.variant })));
  }
};
DyteBreakoutRoomsToggle.style = dyteBreakoutRoomsToggleCss;

var dyteBreakoutRoomsToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_breakout_rooms_toggle: DyteBreakoutRoomsToggle
});

const dyteBroadcastMessageModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);padding:var(--dyte-space-4, 16px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));width:400px;max-width:80%}.content-col{display:flex;width:100%;flex-direction:column}h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-2, 8px)}.content-row{display:flex;width:100%;flex-direction:row}.content-row dyte-button{margin-top:var(--dyte-space-4, 16px);width:100%}textarea{margin-top:var(--dyte-space-3, 12px);resize:none;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;font-family:var(--dyte-font-family, sans-serif);outline:2px solid transparent;outline-offset:2px;height:var(--dyte-space-16, 64px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}textarea::-moz-placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}textarea::placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}select{border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);outline:2px solid transparent;outline-offset:2px;border-right-width:var(--dyte-border-width-md, 2px);border-style:solid;border-color:transparent;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}p{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-2, 8px);width:100%;text-align:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));display:flex;flex-direction:row;align-items:center;justify-content:center}p dyte-icon{margin-left:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px)}";

const DyteBroadcastMessageModal = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.messagePayload = {
      to: 'Everyone',
      message: '',
    };
    this.successMessage = false;
  }
  close() {
    var _a;
    (_a = this.stateUpdate) === null || _a === void 0 ? void 0 : _a.emit({ activeBroadcastMessageModal: false });
    state.activeBroadcastMessageModal = false;
  }
  sendMessage() {
    // TODO:(ishita1805) Send this.messagePayload to webcore.
    this.successMessage = true;
    setTimeout(() => {
      this.close();
    }, 2000);
  }
  render() {
    return (h(Host, null, h("div", { class: "content-col" }, h("h2", null, "Broadcast message to"), h("select", { onChange: (e) => {
        this.messagePayload = Object.assign(Object.assign({}, this.messagePayload), { to: e.target.value });
      } }, h("option", null, "Everyone"), h("option", null, "List of rooms")), h("textarea", { placeholder: "Type message here...", onInput: (e) => {
        this.messagePayload = Object.assign(Object.assign({}, this.messagePayload), { message: e.target.value });
      } }), this.successMessage ? (h("p", null, "Message sent to ", this.messagePayload.to, h("dyte-icon", { icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t }))) : (h("div", { class: "content-row" }, h("dyte-button", { onClick: () => this.close(), variant: "secondary", iconPack: this.iconPack, t: this.t }, "Cancel"), "\u2002", h("dyte-button", { variant: "primary", onClick: () => this.sendMessage(), iconPack: this.iconPack, t: this.t }, "Send"))))));
  }
};
DyteBroadcastMessageModal.style = dyteBroadcastMessageModalCss;

var dyteBroadcastMessageModal_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_broadcast_message_modal: DyteBroadcastMessageModal
});

const dyteCameraToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteCameraToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.videoUpdateListener = ({ videoEnabled }) => {
      this.videoEnabled = videoEnabled;
    };
    this.selfJoinStateListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.selfStateLeftListener = () => {
      this.canProduceVideo = false;
    };
    this.mediaPermissionUpdateListener = ({ kind, message }) => {
      if (kind === 'video') {
        this.cameraPermission = message;
      }
    };
    this.toggleCamera = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__.logger.info('dyteCameraToggle::toggleCamera', {
        media: {
          video: {
            enabled: Boolean((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self) === null || _c === void 0 ? void 0 : _c.videoEnabled),
            permission: this.cameraPermission,
            canProduce: (_f = (_e = (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self) === null || _e === void 0 ? void 0 : _e.permissions) === null || _f === void 0 ? void 0 : _f.canProduceVideo,
          },
        },
        webinar: {
          stageStatus: (_h = (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self) === null || _h === void 0 ? void 0 : _h.webinarStageStatus,
        },
        livestream: {
          stageStatus: (_k = (_j = this.meeting) === null || _j === void 0 ? void 0 : _j.stage) === null || _k === void 0 ? void 0 : _k.status,
        },
        moduleExists: {
          self: Boolean((_l = this.meeting) === null || _l === void 0 ? void 0 : _l.self),
        },
      });
      if (this.hasPermissionError()) {
        const permissionModalSettings = {
          enabled: true,
          kind: 'video',
        };
        this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
        state.activePermissionsMessage = permissionModalSettings;
        return false;
      }
      const self = (_m = this.meeting) === null || _m === void 0 ? void 0 : _m.self;
      if (self == null || !this.canProduceVideo) {
        return;
      }
      if (self.videoEnabled) {
        self.disableVideo();
      }
      else {
        self.enableVideo();
      }
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.videoEnabled = false;
    this.canProduceVideo = false;
    this.cameraPermission = 'NOT_REQUESTED';
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.removeListener('videoUpdate', this.videoUpdateListener);
    (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('joinStageRequestAccepted', this.selfJoinStateListener);
    (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self.removeListener('joinStageRequestRejected', this.selfJoinStateListener);
    (_e = this.meeting) === null || _e === void 0 ? void 0 : _e.self.removeListener('stageJoined', this.selfJoinStateListener);
    (_f = this.meeting) === null || _f === void 0 ? void 0 : _f.self.removeListener('stageLeft', this.selfStateLeftListener);
    (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self.removeListener('removedFromStage', this.selfJoinStateListener);
    (_j = (_h = this.meeting) === null || _h === void 0 ? void 0 : _h.stage) === null || _j === void 0 ? void 0 : _j.removeListener('stageStatusUpdate', this.selfJoinStateListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      const { self, stage } = meeting;
      this.updateCanProduce(meeting);
      this.cameraPermission = self.mediaPermissions.video || 'NOT_REQUESTED';
      this.videoEnabled = self.videoEnabled;
      self.addListener('videoUpdate', this.videoUpdateListener);
      self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      self.addListener('joinStageRequestAccepted', this.selfJoinStateListener);
      self.addListener('joinStageRequestRejected', this.selfJoinStateListener);
      self.addListener('stageJoined', this.selfJoinStateListener);
      self.addListener('stageLeft', this.selfStateLeftListener);
      self.addListener('removedFromStage', this.selfJoinStateListener);
      stage === null || stage === void 0 ? void 0 : stage.addListener('stageStatusUpdate', this.selfJoinStateListener);
    }
  }
  updateCanProduce(meeting) {
    const { self, meta, stage } = meeting;
    const canProduceVideo = self.permissions.canProduceVideo === 'ALLOWED';
    const isWebinar = meta.viewType === 'WEBINAR';
    const isLiveStream = meta.viewType === 'LIVESTREAM';
    this.canProduceVideo = false;
    if (canProduceVideo && !isLiveStream) {
      this.canProduceVideo = true;
    }
    else if (isWebinar || isLiveStream) {
      if (canProduceVideo &&
        stage.status !== 'OFF_STAGE' &&
        stage.status !== 'REQUESTED_TO_JOIN_STAGE')
        this.canProduceVideo = true;
      const canRequestVideo = self.permissions.canProduceVideo === 'CAN_REQUEST';
      // If the has approved request to present
      if (canRequestVideo &&
        ((isWebinar &&
          (self.webinarStageStatus === 'ON_STAGE' ||
            self.webinarStageStatus === 'ACCEPTED_TO_JOIN_STAGE')) ||
          (isLiveStream &&
            (stage.status === 'ON_STAGE' || stage.status === 'ACCEPTED_TO_JOIN_STAGE')))) {
        this.canProduceVideo = true;
      }
    }
  }
  hasPermissionError() {
    return this.cameraPermission === 'DENIED' || this.cameraPermission === 'SYSTEM_DENIED';
  }
  getState() {
    let tooltipLabel = '';
    let label = '';
    let icon = '';
    let classList = {};
    let hasError = this.hasPermissionError();
    let couldNotStart = this.cameraPermission === 'COULD_NOT_START';
    if (this.videoEnabled && !hasError) {
      label = this.t('video_on');
      icon = this.iconPack.video_on;
    }
    else {
      label = this.t('video_off');
      icon = this.iconPack.video_off;
      classList['red-icon'] = true;
    }
    if (couldNotStart) {
      tooltipLabel = this.t('perm_could_not_start.video');
    }
    else if (this.cameraPermission === 'SYSTEM_DENIED') {
      tooltipLabel = this.t('perm_sys_denied.video');
    }
    else if (this.cameraPermission === 'DENIED') {
      tooltipLabel = this.t('perm_denied.video');
    }
    else {
      tooltipLabel = this.videoEnabled ? this.t('disable_video') : this.t('enable_video');
    }
    return {
      tooltipLabel,
      label,
      icon,
      classList,
      showWarning: hasError || couldNotStart,
      disable: hasError,
    };
  }
  render() {
    if (!this.canProduceVideo) {
      return null;
    }
    const { tooltipLabel, label, icon, classList, showWarning, disable } = this.getState();
    return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: tooltipLabel, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: classList, variant: this.variant, label: label, icon: icon, onClick: this.toggleCamera, showWarning: showWarning, disabled: disable }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteCameraToggle.style = dyteCameraToggleCss;

var dyteCameraToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_camera_toggle: DyteCameraToggle
});

const dyteChannelCreatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-96, 384px);padding-left:var(--dyte-space-9, 36px);padding-right:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-10, 40px);padding-bottom:var(--dyte-space-10, 40px)}header{margin-bottom:var(--dyte-space-8, 32px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);font-size:24px;font-weight:600}.channel-name-input{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-3, 12px);font-size:16px;-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:1.25;outline:2px solid transparent;outline-offset:2px}.channel-name-input:focus{outline-width:2px;outline-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}footer{margin-top:var(--dyte-space-5, 20px);display:flex;justify-content:flex-end}.member{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding:var(--dyte-space-2, 8px)}.member dyte-avatar{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.input-container{position:relative;-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:1.25;outline:2px solid transparent;outline-offset:2px;outline-width:2px;outline-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5);border-radius:var(--dyte-border-radius-sm, 4px)}.input-container .members{margin:var(--dyte-space-0, 0px);max-height:var(--dyte-space-28, 112px);border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);list-style-type:none;display:flex;flex-wrap:wrap;gap:var(--dyte-space-1, 4px);cursor:text;font-size:16px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));overflow-y:auto;min-height:var(--dyte-space-7, 28px)}.input-container .pill{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.input-container .pill dyte-avatar{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.input-container .pill span{max-width:var(--dyte-space-32, 128px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.input-container .pill dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);cursor:pointer}.input-container input{width:var(--dyte-space-24, 96px);border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-1, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;font-size:16px;line-height:1.25rem}.input-container input.wide-input{width:100%}.search-results{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-1, 4px);max-height:var(--dyte-space-28, 112px);width:100%;padding:var(--dyte-space-0, 0px);position:absolute;list-style-type:none;overflow-y:auto;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-md, 8px);--tw-border-spacing-x:var(--dyte-space-2, 8px);--tw-border-spacing-y:var(--dyte-space-2, 8px);border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-style:solid;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.search-results .member{cursor:pointer}.search-results .member dyte-avatar{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.search-results .member:hover,.search-results .member.selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}";

const DyteChannelCreator = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.switchChannel = createEvent(this, "switchChannel", 7);
    this.allMembers = new Map();
    this.inputTextRef = null;
    this.searchInputTextRef = null;
    this.focusOnSearch = (selectText = false) => {
      this.focusedMemberIndex = -1;
      writeTask(() => {
        var _a, _b;
        (_a = this.searchInputTextRef) === null || _a === void 0 ? void 0 : _a.focus();
        if (selectText)
          (_b = this.searchInputTextRef) === null || _b === void 0 ? void 0 : _b.select();
      });
    };
    this.onClickHandler = async () => {
      if (this.channelName.length === 0)
        return;
      if (this.step === 1) {
        const members = this.meeting.participants.all.toArray();
        const selfId = this.meeting.self.userId;
        const nonSelfMembers = members.filter((member) => member.userId !== selfId);
        nonSelfMembers.forEach((member) => this.allMembers.set(member.userId, member));
        this.step = 2;
        this.focusOnSearch();
        return;
      }
      // step 2 - add members and create channel
      await this.createChannel();
    };
    this.createChannel = async () => {
      const members = Array.from(this.selectedMemberIds);
      const newChannel = await this.meeting.chat.createChannel(this.channelName, members, {
        displayPictureUrl: '',
        visibility: 'public',
        isDirectMessage: false,
      });
      this.switchChannel.emit(newChannel.id);
      this.stateUpdate.emit({ activeChannelCreator: false });
      state.activeChannelCreator = false;
    };
    this.onMemberAdd = (id) => {
      this.showAllMembersList = false;
      this.selectedMemberIds.add(id);
      this.searchQuery = '';
      this.focusOnSearch();
    };
    this.keyDownHandler = (e, filteredMembers) => {
      if (e.key === 'ArrowDown') {
        this.focusedMemberIndex = Math.min(this.focusedMemberIndex + 1, filteredMembers.length - 1);
      }
      else if (e.key === 'ArrowUp') {
        if (this.focusedMemberIndex === -1)
          return;
        if (this.focusedMemberIndex === 0) {
          this.focusOnSearch(true);
          return;
        }
        this.focusedMemberIndex = Math.max(this.focusedMemberIndex - 1, 0);
      }
      else if (e.key === 'Enter') {
        this.onMemberAdd(filteredMembers[this.focusedMemberIndex].userId);
      }
      else if (e.key === 'Backspace') {
        if (this.searchQuery.length !== 0)
          return;
        if (this.selectedMemberIds.size === 0)
          return;
        const lastMemberId = Array.from(this.selectedMemberIds.values()).at(-1);
        this.selectedMemberIds.delete(lastMemberId);
        forceUpdate(this.$el);
      }
    };
    this.renderMemberSelector = () => {
      const filteredMembers = Array.from(this.allMembers.values()).filter((member) => !this.selectedMemberIds.has(member.userId) &&
        member.name.toLowerCase().includes(this.searchQuery.toLowerCase()));
      const selectedMembers = Array.from(this.selectedMemberIds.values()).map((id) => this.allMembers.get(id));
      const disableInput = this.selectedMemberIds.size === this.allMembers.size;
      return (h("div", { class: "input-container" }, h("ul", { class: "members scrollbar", onClick: () => {
          var _a;
          (_a = this.searchInputTextRef) === null || _a === void 0 ? void 0 : _a.focus();
        } }, selectedMembers.map((member) => (h("li", { class: "pill" }, h("dyte-avatar", { participant: {
          name: member.name,
          picture: member.picture,
        }, size: "sm" }), h("span", null, member.name), h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t, onClick: () => {
          this.selectedMemberIds.delete(member.userId);
          forceUpdate(this.$el);
          this.focusOnSearch();
        } })))), !disableInput && (h("input", { type: "text", ref: (el) => (this.searchInputTextRef = el), value: this.searchQuery, placeholder: this.selectedMemberIds.size === 0 ? this.t('chat.member_name') : '', class: {
          'wide-input': this.selectedMemberIds.size === 0,
        }, onInput: (e) => {
          this.searchQuery = e.target.value.trim();
        }, onClick: () => {
          this.showAllMembersList = !this.showAllMembersList;
        }, onKeyDown: (e) => this.keyDownHandler(e, filteredMembers) }))), (this.searchQuery.length !== 0 || this.showAllMembersList) && (h("ul", { class: "search-results" }, filteredMembers.map((member, index) => (h("li", { class: { member: true, selected: index === this.focusedMemberIndex }, onClick: () => this.onMemberAdd(member.userId), ref: ($li) => {
          if (index === this.focusedMemberIndex) {
            writeTask(() => {
              if ($li)
                $li.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
            });
          }
        } }, h("dyte-avatar", { participant: {
          name: member.name,
          picture: member.picture,
        }, size: "sm" }), h("span", null, member.name)))), filteredMembers.length === 0 && (h("li", { class: "member" }, h("span", null, this.t('chat.error.empty_results'))))))));
    };
    this.meeting = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.channelName = '';
    this.searchQuery = '';
    this.step = 1;
    this.loading = false;
    this.selectedMemberIds = new Set();
    this.focusedMemberIndex = -1;
    this.showAllMembersList = false;
  }
  componentDidLoad() {
    var _a;
    (_a = this.inputTextRef) === null || _a === void 0 ? void 0 : _a.focus();
  }
  render() {
    return (h(Host, null, h("header", null, this.step === 1 ? this.t('chat.new_channel') : this.t('chat.add_members')), this.step === 1 && (h("input", { class: "channel-name-input", type: "text", placeholder: this.t('chat.channel_name'), ref: (el) => (this.inputTextRef = el), onInput: (e) => {
        this.channelName = e.target.value.trim();
      } })), this.step === 2 && this.renderMemberSelector(), h("footer", null, h("dyte-button", { kind: "button", iconPack: this.iconPack, t: this.t, size: "lg", disabled: this.channelName.length === 0, onClick: this.onClickHandler }, this.step === 1 ? this.t('chat.add_members') : this.t('create')))));
  }
  get $el() { return getElement(this); }
};
DyteChannelCreator.style = dyteChannelCreatorCss;

var dyteChannelCreator_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_channel_creator: DyteChannelCreator
});

const canViewChat = (meeting) => {
  if (meeting && !meeting.chat)
    return false;
  const config = meeting === null || meeting === void 0 ? void 0 : meeting.self.config;
  if (config && !config.controlBar.elements.chat)
    return false;
  const { chatPublic, chatPrivate } = meeting.self.permissions;
  return (chatPublic.canSend ||
    chatPublic.text ||
    chatPublic.files ||
    chatPrivate.canSend ||
    chatPrivate.canReceive ||
    chatPrivate.files ||
    chatPrivate.text);
};
const canViewPolls = (meeting) => {
  if (meeting && !meeting.polls)
    return false;
  const config = meeting === null || meeting === void 0 ? void 0 : meeting.self.config;
  if (config && !config.controlBar.elements.polls)
    return false;
  const { polls } = meeting.self.permissions;
  return polls.canCreate || polls.canView || polls.canVote;
};
const canViewParticipants = (meeting) => {
  var _a, _b;
  if (showLivestream(meeting) && !((_a = meeting.self.permissions) === null || _a === void 0 ? void 0 : _a.acceptPresentRequests))
    return false;
  if (meeting && !meeting.participants)
    return false;
  if (meeting.meta.viewType === 'LIVESTREAM') {
    return meeting.self.permissions.acceptPresentRequests || ((_b = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _b === void 0 ? void 0 : _b.status) === 'ON_STAGE';
  }
  const config = meeting === null || meeting === void 0 ? void 0 : meeting.self.config;
  if (config && !config.controlBar.elements.participants)
    return false;
  return true;
};
const canViewPlugins = (meeting) => {
  if (isLiveStreamViewer(meeting))
    return false;
  if (meeting && !meeting.plugins)
    return false;
  if (meeting.meta.viewType === 'LIVESTREAM')
    return meeting.stage.status === 'ON_STAGE';
  const config = meeting === null || meeting === void 0 ? void 0 : meeting.self.config;
  if (config && !config.controlBar.elements.plugins)
    return false;
  const { plugins } = meeting.self.permissions;
  return plugins.canClose || plugins.canStart;
};

const dyteChatToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}.unread-count-dot{position:absolute;right:var(--dyte-space-3, 12px);z-index:10;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));border-radius:50%;display:flex;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);align-items:center;justify-content:center}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .unread-count{right:var(--dyte-space-4, 16px);top:auto}";

const DyteChatToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onChatUpdate = ({ action, message }) => {
      var _a;
      if (this.chatActive)
        return;
      if (action === 'add' && message.userId !== ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.userId)) {
        this.hasNewMessages = true;
        this.unreadMessageCount += 1;
      }
    };
    this.toggleChat = () => {
      const states = this.states || state;
      this.chatActive = !((states === null || states === void 0 ? void 0 : states.activeSidebar) && (states === null || states === void 0 ? void 0 : states.sidebar) === 'chat');
      if (this.chatActive) {
        this.unreadMessageCount = 0;
        this.hasNewMessages = false;
      }
      state.activeSidebar = this.chatActive;
      state.activeMoreMenu = false;
      state.sidebar = this.chatActive ? 'chat' : undefined;
      this.stateUpdate.emit({
        activeSidebar: this.chatActive,
        sidebar: this.chatActive ? 'chat' : undefined,
        activeMoreMenu: false,
        activeAI: false,
      });
    };
    this.updateCanView = () => {
      this.canViewChat = canViewChat(this.meeting);
    };
    this.unreadMessageCount = 0;
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.chatActive = false;
    this.canViewChat = false;
    this.hasNewMessages = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.statesChanged(this.states);
    onChange('sidebar', () => this.statesChanged());
  }
  disconnectedCallback() {
    var _a, _b, _c, _d;
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.chat) === null || _b === void 0 ? void 0 : _b.removeListener('chatUpdate', this.onChatUpdate);
    (_d = (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.stage) === null || _d === void 0 ? void 0 : _d.removeListener('stageStatusUpdate', this.updateCanView);
  }
  meetingChanged(meeting) {
    var _a, _b, _c, _d;
    if (meeting == null)
      return;
    if (usePaginatedChat(meeting)) {
      (_a = meeting.chat) === null || _a === void 0 ? void 0 : _a.getMessages(new Date().getTime(), 1, true).then((res) => {
        var _a;
        if ((_a = res === null || res === void 0 ? void 0 : res.messages) === null || _a === void 0 ? void 0 : _a.length)
          this.hasNewMessages = true;
      });
    }
    this.unreadMessageCount = ((_b = meeting.chat) === null || _b === void 0 ? void 0 : _b.messages.length) || 0;
    (_c = meeting.chat) === null || _c === void 0 ? void 0 : _c.addListener('chatUpdate', this.onChatUpdate);
    this.canViewChat = canViewChat(meeting);
    (_d = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _d === void 0 ? void 0 : _d.on('stageStatusUpdate', this.updateCanView);
  }
  statesChanged(s) {
    const states = s || state;
    if (states != null) {
      this.chatActive = states.activeSidebar === true && states.sidebar === 'chat';
    }
  }
  render() {
    if (!this.canViewChat)
      return;
    return (h(Host, { title: this.t('chat') }, usePaginatedChat(this.meeting)
      ? this.hasNewMessages && h("div", { class: "unread-count-dot", part: "unread-count-dot" })
      : this.unreadMessageCount !== 0 &&
        !this.chatActive && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadMessageCount <= 100 ? this.unreadMessageCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.chatActive }, onClick: this.toggleChat, icon: this.iconPack.chat, label: this.t('chat'), variant: this.variant })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "states": ["statesChanged"]
  }; }
};
DyteChatToggle.style = dyteChatToggleCss;

var dyteChatToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_chat_toggle: DyteChatToggle
});

const dyteClockCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;align-items:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-variant-numeric:tabular-nums}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

const addZero = (n) => Math.trunc(n).toString().padStart(2, '0');
const DyteClock = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.disconnectMeeting = () => {
      var _a, _b;
      this.timeout && clearTimeout(this.timeout);
      typeof this.request === 'number' && cancelAnimationFrame(this.request);
      (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.removeListener('meetingStartTimeUpdate', this.startedTimeUpdateListener);
    };
    this.startedTimeUpdateListener = () => {
      var _a, _b, _c;
      this.startedTime = (_c = (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.meetingStartedTimestamp) === null || _c === void 0 ? void 0 : _c.toISOString();
    };
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.startedTime = undefined;
    this.timeDiff = undefined;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    this.disconnectMeeting();
  }
  meetingChanged(meeting) {
    var _a, _b, _c;
    this.disconnectMeeting();
    if (meeting != null) {
      this.startedTime = (_b = (_a = meeting.meta) === null || _a === void 0 ? void 0 : _a.meetingStartedTimestamp) === null || _b === void 0 ? void 0 : _b.toISOString();
      (_c = meeting.meta) === null || _c === void 0 ? void 0 : _c.addListener('meetingStartTimeUpdate', this.startedTimeUpdateListener);
    }
  }
  startedTimeChanged(startedTime) {
    if (startedTime !== undefined) {
      const animate = () => {
        this.timeDiff = (Date.now() - new Date(this.startedTime).getTime()) / 1000;
        this.timeout = setTimeout(() => {
          if (this.request != null) {
            this.request = requestAnimationFrame(animate);
          }
        }, 500);
      };
      this.request = requestAnimationFrame(animate);
    }
  }
  getFormattedTime() {
    if (this.timeDiff == null) {
      return null;
    }
    const diff = this.timeDiff;
    let time = '';
    if (diff >= 3600) {
      time = `${addZero(diff / 3600)}:`;
    }
    time += `${addZero((diff % 3600) / 60)}:${addZero(diff % 60)}`;
    return time;
  }
  render() {
    return (h(Host, { tabIndex: 0, role: "timer", "aria-live": "off" }, this.startedTime !== undefined && [
      h("dyte-icon", { icon: this.iconPack.clock, "aria-hidden": true, tabIndex: -1, part: "icon", iconPack: this.iconPack, t: this.t }),
      h("span", { part: "text" }, this.getFormattedTime()),
    ]));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "startedTime": ["startedTimeChanged"]
  }; }
};
DyteClock.style = dyteClockCss;

var dyteClock_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_clock: DyteClock
});

const dyteConfirmationModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);padding:var(--dyte-space-8, 32px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));width:400px;max-width:80%}.leave-modal{width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px)}.leave-modal .content{font-size:14px}.leave-message p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px)}.leave-meeting{display:flex;flex-direction:row;justify-content:space-between;gap:var(--dyte-space-4, 16px)}.leave-meeting dyte-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255));flex:1 1 0%}.end-meeting{margin-top:var(--dyte-space-2, 8px)}.br-secondary-btn{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-secondary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

const DyteConfirmationModal = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.keyPressListener = (e) => {
      if (e.key === 'Escape') {
        this.close();
      }
    };
    this.close = () => {
      this.stateUpdate.emit({ activeConfirmationModal: { active: false } });
      state.activeConfirmationModal = { active: false };
      this.states.activeConfirmationModal.onClose(this.stateUpdate, state, this.meeting);
    };
    this.onConfirmation = async () => {
      this.stateUpdate.emit({ activeConfirmationModal: { active: false } });
      state.activeConfirmationModal = { active: false };
      this.states.activeConfirmationModal.onClick(this.stateUpdate, state, this.meeting);
    };
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    document.addEventListener('keydown', this.keyPressListener);
  }
  componentDidLoad() { }
  disconnectedCallback() {
    document.removeEventListener('keydown', this.keyPressListener);
  }
  render() {
    var _a, _b;
    const state = this.states.activeConfirmationModal;
    return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, state.header ? this.t(state.header) : this.t('cta.confirmation'))), h("p", { class: "message" }, state.content ? this.t(state.content) : ''), h("div", { class: "content" }, h("div", { class: "leave-meeting" }, h("dyte-button", { variant: "secondary", title: state.cancelText ? this.t(state.cancelText) : this.t('cancel'), onClick: this.close, iconPack: this.iconPack, t: this.t, class: "br-secondary-btn" }, state.cancelText ? this.t(state.cancelText) : this.t('cancel')), h("dyte-button", { onClick: () => this.onConfirmation(), variant: (_b = (_a = this.states.activeConfirmationModal) === null || _a === void 0 ? void 0 : _a.variant) !== null && _b !== void 0 ? _b : 'danger', title: state.ctaText ? this.t(state.ctaText) : this.t('yes'), iconPack: this.iconPack, t: this.t }, state.ctaText ? this.t(state.ctaText) : this.t('yes')))))));
  }
};
DyteConfirmationModal.style = dyteConfirmationModalCss;

var dyteConfirmationModal_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_confirmation_modal: DyteConfirmationModal
});

const dyteControlbarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:flex;align-items:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);position:relative;z-index:10}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{padding-top:var(--dyte-space-0, 0px) !important}}";

const DyteControlbar = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.variant = 'solid';
    this.disableRender = false;
    this.meeting = undefined;
    this.config = defaultConfig;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.middlewares = {};
    this.size = undefined;
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states,
      t: this.t,
      iconPack: this.iconPack,
      size: this.size,
      middlewares: this.middlewares,
    };
    return (h(Host, null, !this.disableRender && h(Render, { element: "dyte-header", defaults: defaults, onlyChildren: true }), h("slot", null)));
  }
};
DyteControlbar.style = dyteControlbarCss;

var dyteControlbar_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_controlbar: DyteControlbar
});

const dyteDebuggerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{margin-right:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-between;padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}header h3{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px)}.back-btn{border-radius:var(--dyte-border-radius-sm, 4px);background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.back-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside{box-sizing:border-box;display:flex;max-width:var(--dyte-space-56, 224px) !important;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px)}aside button{margin-top:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;width:100%;align-items:center;justify-content:space-between;border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);background-color:transparent;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));cursor:default;font-size:14px;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px}aside button .right{display:flex;align-items:center}aside button .right dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}aside button .right dyte-icon:last-child{margin-left:var(--dyte-space-4, 16px)}aside button[type='button']{cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}aside button[type='button']:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside button[type='button']{border-right:var(--dyte-border-width-md, 2px) solid transparent}aside button.active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}aside button.active:hover{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}main{position:relative;box-sizing:border-box;display:flex;height:100%;width:100%;flex-direction:column;padding-top:var(--dyte-space-1, 4px)}:host([size='sm']) aside{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));width:100% !important;max-width:100% !important;padding-left:var(--dyte-space-0, 0px)}:host([size='sm']) aside button{border-radius:var(--dyte-border-radius-none, 0)}:host([size='sm']) aside button.active{border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}:host([size='sm']) aside button.active:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) aside.hide{display:none}:host([size='sm']) main{display:none;height:100%;width:100%;padding:var(--dyte-space-0, 0px)}:host([size='sm']) main.active{display:block}:host([size='sm']) header{margin:var(--dyte-space-0, 0px);justify-content:center}:host([size='sm']) header dyte-button{position:absolute;left:var(--dyte-space-4, 16px)}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}::-webkit-scrollbar-thumb:hover{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.progress-bar{height:var(--dyte-space-1, 4px);width:100%;overflow:hidden;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.progress-indicator{height:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}";

const DyteDebugger = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.keyPressListener = (e) => {
      if (e.key === 'Escape') {
        this.close();
      }
    };
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.activeTab = 'audio';
    this.isMobileMainVisible = false;
    this.progress = 0;
  }
  connectedCallback() {
    document.addEventListener('keydown', this.keyPressListener);
  }
  disconnectedCallback() {
    this.keyPressListener && document.removeEventListener('keydown', this.keyPressListener);
  }
  progressUpdate(event) {
    this.progress = event.detail;
  }
  changeTab(tab) {
    this.activeTab = tab;
    if (this.size === 'sm') {
      if (!this.isMobileMainVisible) {
        this.isMobileMainVisible = true;
      }
    }
  }
  close() {
    this.stateUpdate.emit({ activeDebugger: false });
    state.activeDebugger = false;
  }
  getActiveTab() {
    switch (this.activeTab) {
      case 'audio':
        return this.t('Audio Troubleshooting');
      case 'screenshare':
        return this.t('Media Troubleshooting');
      case 'video':
        return this.t('Video Troubleshooting');
      default:
        return this.t('Troubleshooting');
    }
  }
  render() {
    if (this.meeting == null)
      return null;
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      iconPack: this.iconPack,
      t: this.t,
      size: this.size,
    };
    const tab = this.getActiveTab();
    return (h(Host, null, h("aside", { class: { hide: this.isMobileMainVisible }, part: "menu" }, h("header", null, h("h3", null, this.t('Troubleshooting'))), h("button", { type: "button", class: { active: this.activeTab === 'audio' }, onClick: () => this.changeTab('audio') }, this.t('audio'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.mic_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), h("button", { type: "button", class: { active: this.activeTab === 'video' }, onClick: () => this.changeTab('video') }, this.t('video'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.video_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), h("button", { type: "button", class: { active: this.activeTab === 'screenshare' }, onClick: () => this.changeTab('screenshare') }, this.t('Screenshare'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.share_screen_start, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t }))))), h("main", { class: { active: this.isMobileMainVisible }, part: "main-content" }, this.size === 'sm' && (h("header", null, h("dyte-button", { kind: "icon", class: "back-btn", onClick: () => (this.isMobileMainVisible = false), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), h("h4", null, tab))), this.activeTab === 'audio' && h("dyte-debugger-audio", Object.assign({}, defaults)), this.activeTab === 'video' && h("dyte-debugger-video", Object.assign({}, defaults)), this.activeTab === 'screenshare' && (h("dyte-debugger-screenshare", Object.assign({}, defaults))), this.progress > 1 && (h("div", { class: "progress-bar" }, h("div", { class: "progress-indicator", style: {
        width: `${this.progress}%`,
      } }))))));
  }
};
DyteDebugger.style = dyteDebuggerCss;

var dyteDebugger_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_debugger: DyteDebugger
});

const dyteDebuggerNetworkCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);display:flex;height:100%;width:100%;flex:1 1 0%;flex-direction:column;align-items:flex-start;justify-content:flex-start}";

const DyteDebuggerNetwork = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.issueKey = 0;
  }
  render() {
    return h(Host, null);
  }
};
DyteDebuggerNetwork.style = dyteDebuggerNetworkCss;

var dyteDebuggerNetwork_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_debugger_network: DyteDebuggerNetwork
});

const dyteDebuggerToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteDebuggerToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.size = undefined;
  }
  toggleDebugger() {
    var _a;
    this.stateUpdate.emit({
      activeDebugger: !((_a = this.states) === null || _a === void 0 ? void 0 : _a.activeDebugger),
      activeMoreMenu: false,
    });
    state.activeDebugger = !state.activeDebugger;
    state.activeMoreMenu = false;
  }
  render() {
    var _a;
    if (!((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.troubleshoot))
      return;
    return (h(Host, { title: this.t('Network & Trouble Shooting') }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleDebugger(), icon: this.iconPack.debug, label: this.t('Troubleshooting and Help'), variant: this.variant })));
  }
};
DyteDebuggerToggle.style = dyteDebuggerToggleCss;

var dyteDebuggerToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_debugger_toggle: DyteDebuggerToggle
});

const dyteEndedScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;-webkit-user-select:none;-moz-user-select:none;user-select:none;display:flex;flex-direction:column;align-items:center;justify-content:center}.ctr{display:flex;flex-direction:column;align-items:center}dyte-logo{margin-bottom:var(--dyte-space-8, 32px);height:var(--dyte-space-12, 48px)}.rejoin-button{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-6, 24px);padding-bottom:var(--dyte-space-6, 24px);padding-left:var(--dyte-space-16, 64px);padding-right:var(--dyte-space-16, 64px)}.rejoin-icon{margin-right:var(--dyte-space-2, 8px)}p{font-size:16px;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}p.breakout{font-size:20px;display:flex;flex-direction:column;align-items:center}p.breakout span{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-0, 0px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}span{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}";

const DyteEndedScreen = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.config = defaultConfig;
    this.size = undefined;
    this.icon = defaultIconPack;
    this.states = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.message = '';
    this.meeting = undefined;
  }
  connectedCallback() {
    this.statesChanged(this.states);
    onChange('roomLeftState', () => this.statesChanged());
  }
  getBreakoutRoomsMessage(states) {
    var _a;
    let message;
    if ((states === null || states === void 0 ? void 0 : states.roomLeftState) === 'connected-meeting') {
      if (((_a = state.activeBreakoutRoomsManager) === null || _a === void 0 ? void 0 : _a.destinationMeetingId) ===
        this.meeting.connectedMeetings.parentMeeting.id) {
        message = 'breakout_rooms.move_reason.switch_main_room';
      }
      else {
        message = 'breakout_rooms.move_reason.switch_room';
      }
    }
    return message;
  }
  statesChanged(s) {
    const states = s || state;
    if (states != null) {
      switch (states === null || states === void 0 ? void 0 : states.roomLeftState) {
        case 'left':
          this.message = 'ended.left';
          break;
        case 'kicked':
          this.message = 'ended.kicked';
          break;
        case 'disconnected':
          this.message = 'ended.disconnected';
          break;
        case 'rejected':
          this.message = 'ended.rejected';
          break;
        case 'connected-meeting':
          this.message = this.getBreakoutRoomsMessage(states);
          break;
        default:
          this.message = 'ended';
      }
    }
  }
  renderBreakoutRoomScreen() {
    return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("p", { part: "message", class: "breakout" }, this.t(this.message)))));
  }
  render() {
    const states = this.states || state;
    if (states.roomLeftState === 'connected-meeting') {
      return this.renderBreakoutRoomScreen();
    }
    return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("dyte-logo", { meeting: this.meeting, config: this.config, part: "logo", t: this.t }), h("p", { part: "message" }, this.t(this.message)), (states === null || states === void 0 ? void 0 : states.roomLeftState) === 'disconnected' && (h("span", { part: "description" }, this.t('ended.network'))))));
  }
  static get watchers() { return {
    "states": ["statesChanged"]
  }; }
};
DyteEndedScreen.style = dyteEndedScreenCss;

var dyteEndedScreen_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ended_screen: DyteEndedScreen
});

const requestFullScreen = (el) => {
  if (el == null)
    return;
  if (el.requestFullscreen != null) {
    el.requestFullscreen();
  }
  else if (el.mozRequestFullScreen != null) {
    /* Firefox */
    el.mozRequestFullScreen();
  }
  else if (el.webkitRequestFullscreen != null) {
    /* Chrome, Safari & Opera */
    el.webkitRequestFullscreen();
  }
  else if (el.msRequestFullscreen != null) {
    /* IE/Edge */
    el.msRequestFullscreen();
  }
};
const exitFullSreen = () => {
  if (document.exitFullscreen != null) {
    document.exitFullscreen();
  }
  else if (document.mozExitFullScreen != null) {
    /* Firefox */
    document.mozExitFullScreen();
  }
  else if (document.webkitExitFullscreen != null) {
    /* Chrome, Safari & Opera */
    document.webkitExitFullscreen();
  }
  else if (document.msExitFullscreen != null) {
    /* IE/Edge */
    document.msExitFullscreen();
  }
};
const isFullScreenEnabled = () => {
  return document.fullscreenElement != null || document.webkitCurrentFullScreenElement != null;
};
const isFullScreenSupported = () => {
  if (typeof document !== 'undefined') {
    return (document.fullscreenEnabled ||
      document.mozFullscreenEnabled ||
      document.webkitFullscreenEnabled ||
      document.msFullscreenEnabled);
  }
  return false;
};

const dyteFullscreenToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteFullscreenToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onFullScreenchange = () => {
      this.fullScreenActive = isFullScreenEnabled();
    };
    this.toggleFullScreen = () => {
      const fullScreenElement = document.querySelector('dyte-meeting');
      if (!fullScreenElement)
        return;
      if (!this.fullScreenActive) {
        requestFullScreen(fullScreenElement);
        this.fullScreenActive = true;
      }
      else {
        exitFullSreen();
        this.fullScreenActive = false;
      }
      this.stateUpdate.emit({ activeMoreMenu: false });
      state.activeMoreMenu = false;
    };
    this.states = undefined;
    this.variant = 'button';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.fullScreenActive = false;
    this.isFullScreenSupported = true;
  }
  connectedCallback() {
    this.isFullScreenSupported = isFullScreenSupported();
    this.onFullScreenchange();
    window.addEventListener('webkitfullscreenchange', this.onFullScreenchange);
    window.addEventListener('fullscreenchange', this.onFullScreenchange);
  }
  disconnectedCallback() {
    window.removeEventListener('webkitfullscreenchange', this.onFullScreenchange);
    window.removeEventListener('fullscreenchange', this.onFullScreenchange);
  }
  render() {
    if (!this.isFullScreenSupported) {
      return null;
    }
    return (h(Host, { title: this.t('full_screen') }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.toggleFullScreen, icon: this.fullScreenActive
        ? this.iconPack.full_screen_minimize
        : this.iconPack.full_screen_maximize, label: this.fullScreenActive ? this.t('full_screen.exit') : this.t('full_screen'), variant: this.variant })));
  }
};
DyteFullscreenToggle.style = dyteFullscreenToggleCss;

var dyteFullscreenToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_fullscreen_toggle: DyteFullscreenToggle
});

function roundDown(num, places) {
  const factor = Math.pow(10, places);
  return Math.floor(num * factor) / factor;
}
function useGrid({ dimensions, count, aspectRatio, gap }) {
  const { width, height, rows, cols } = useGridItemDimensions({
    dimensions,
    count,
    aspectRatio,
    gap,
  });
  const getPosition = useGridPositioning({
    parentDimensions: dimensions,
    dimensions: { width, height },
    rows,
    cols,
    count,
    gap,
  });
  return { width, height, getPosition };
}
function useGridItemDimensions({ count, dimensions, aspectRatio, gap, }) {
  let { width: W, height: H } = dimensions;
  if (W === 0 || H === 0)
    return { width: 0, height: 0, rows: 1, cols: 1 };
  W -= gap * 2;
  H -= gap * 2;
  const s = gap, N = count;
  const r = getAspectRatio(aspectRatio);
  let w = 0, h = 0;
  let a = 1, b = 1;
  const widths = [];
  for (let n = 1; n <= N; n++) {
    widths.push((W - s * (n - 1)) / n);
    widths.push((H - s * (n - 1)) / (n * r));
  }
  // sort in descending order, largest first
  widths.sort((a, b) => b - a);
  for (const width of widths) {
    // We fix the precision to 4 decimal places to prevent
    // floating point overflow errors. Anyway, accuracy above
    // 4 decimal places does not really matter.
    w = roundDown(width, 4);
    h = roundDown(w * r, 4);
    a = Math.floor((W + s) / (w + s));
    b = Math.floor((H + s) / (h + s));
    if (a * b >= N) {
      // recalculate rows, as row calculated above can be inaccurate
      b = Math.ceil(N / a);
      break;
    }
  }
  return { width: w, height: h, rows: b, cols: a };
}
function useGridPositioning({ parentDimensions, dimensions, rows, cols, count, gap, }) {
  const { width: W, height: H } = parentDimensions;
  const { width: w, height: h } = dimensions;
  const firstTop = (H - (h * rows + (rows - 1) * gap)) / 2;
  let firstLeft = (W - (w * cols + (cols - 1) * gap)) / 2;
  const topAdd = h + gap;
  const leftAdd = w + gap;
  let col = 0, row = 0;
  const incompleteRowCols = count % cols;
  function getPosition(index) {
    const remaining = count - index;
    if (remaining === incompleteRowCols) {
      // in last row with incomplete columns, recalculate firstLeft to make it centered
      firstLeft = (W - (w * remaining + (remaining - 1) * gap)) / 2;
    }
    const top = firstTop + row * topAdd;
    const left = firstLeft + col * leftAdd;
    col++;
    if ((index + 1) % cols === 0) {
      // if a row has been traversed completely, increment row, reset col
      row++;
      col = 0;
    }
    return { top, left };
  }
  return getPosition;
}
/**
 * Parses the Aspect Ratio value
 * @param ratio The aspect ratio in the format of `16:9` where `width:height`
 * @returns The parsed value of aspect ratio
 */
const getAspectRatio = (ratio) => {
  const [width, height] = ratio.split(':');
  return Number.parseInt(height) / Number.parseInt(width);
};
const defaultGridSize = {
  spotlight: 'sm',
  mixed: 'sm',
};

const dyteGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;overflow:hidden;flex-wrap:wrap;align-content:center;align-items:center;justify-content:center;color:rgb(var(--dyte-colors-text-1000, 255 255 255));transition:0.4s}dyte-participant-tile{aspect-ratio:initial;box-sizing:border-box}.webinar-stage{box-sizing:border-box;display:flex;align-content:center;align-items:center;justify-content:center;text-align:center}.webinar-stage h2{margin:var(--dyte-space-0, 0px);font-weight:normal}.livestream-stage{box-sizing:border-box;margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex;height:100%;flex-grow:1;align-content:center;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-md, 8px);text-align:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}dyte-viewer-count{display:none}dyte-livestream-indicator{display:none}@media only screen and (max-device-height: 480px) and (orientation: landscape){dyte-viewer-count[variant='embedded']{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-2, 8px);z-index:20;margin-top:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0, 0px);display:flex}dyte-livestream-indicator{position:absolute;top:var(--dyte-space-0, 0px);left:var(--dyte-space-2, 8px);z-index:20;margin-top:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0, 0px);display:flex}}";

const DyteGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.hideSelf = false;
    this.networkUpdateListener = ({ event }) => {
      this.connected = event === 'connected';
    };
    this.meetingDisconnectedListener = () => {
      this.networkUpdateListener({ event: 'disconnected' });
    };
    this.meetingConnectedListener = () => {
      this.networkUpdateListener({ event: 'connected' });
    };
    this.eventCallback = (event) => {
      const { self } = this.meeting;
      if (event === PiPEvents.CAMERA) {
        if (self.videoEnabled) {
          self.disableVideo();
        }
        else {
          self.enableVideo();
        }
      }
      if (event === PiPEvents.MIC) {
        if (self.audioEnabled) {
          self.disableAudio();
        }
        else {
          self.enableAudio();
        }
      }
      if (event === PiPEvents.END) {
        store.cleanup();
        this.stateUpdate.emit({ activePipMode: false });
        this.meeting.leaveRoom();
      }
    };
    this.enablePipMediaControls = (meeting = this.meeting) => {
      const canProduceAudio = meeting.self.permissions.canProduceAudio;
      const canProduceVideo = meeting.self.permissions.canProduceVideo;
      if (canProduceAudio)
        store.mountAudioEvents(this.eventCallback);
      if (canProduceVideo)
        store.mountVideoEvents(this.eventCallback);
    };
    this.disablePipMediaControls = () => {
      store.unmountAudioEvents();
      store.unmountVideoEvents();
    };
    // NOTE: (ishita1805) Only for `DyteStage` events
    this.handlePipMediaControls = (status) => {
      if (status === 'ON_STAGE')
        this.enablePipMediaControls();
      else
        this.disablePipMediaControls();
    };
    // TODO(@madhugb): Temp hack, remove this when we ship manual subscription
    this.filterParticipants = (participants) => {
      var _a;
      // Only filter for non recorders
      if (this.overrides && ((_a = this.overrides) === null || _a === void 0 ? void 0 : _a.videoUnsubscribed)) {
        const presetFilters = this.overrides.videoUnsubscribed.preset;
        if (presetFilters.length > 0) {
          // Filter out unsubscribed participants
          participants = participants.filter((p) => {
            const unsubscribed = presetFilters.some((regex) => {
              if (p.presetName === undefined)
                return false;
              return p.presetName.match(regex);
            });
            return !unsubscribed;
          });
        }
      }
      return participants;
    };
    this.onSelfVideoUpdateListener = ({ videoEnabled }) => {
      store.updateMediaSession(PiPEvents.CAMERA, videoEnabled);
    };
    this.onSelfAudioUpdateListener = ({ audioEnabled }) => {
      store.updateMediaSession(PiPEvents.MIC, audioEnabled);
    };
    this.onViewModeChanged = () => {
      if (this.meeting == null)
        return;
      this.updateActiveParticipants();
    };
    this.onParticipantJoined = (participant) => {
      if (this.meeting == null)
        return;
      if (!this.participants.some((p) => p.id === participant.id)) {
        this.participants = this.filterParticipants([participant, ...this.participants]);
      }
      if (participant.isPinned && !this.pinnedParticipants.some((p) => p.id === participant.id)) {
        this.pinnedParticipants = this.pinnedParticipants.concat([participant]);
      }
      this.updateWebinarStage();
    };
    this.onParticipantLeft = (participant) => {
      this.participants = this.participants.filter((p) => p.id !== participant.id);
      this.participants = this.participants.concat(this.meeting.participants.active
        .toArray()
        .filter((p) => !this.participants.find((p1) => p1.id === p.id)));
      this.participants = this.filterParticipants(this.participants);
      this.pinnedParticipants = this.pinnedParticipants.filter((p) => p.id !== participant.id);
      if (participant.screenShareEnabled) {
        this.removeScreenShare(participant);
      }
      this.updateWebinarStage();
    };
    this.selfStageJoinListener = () => {
      this.updateActiveParticipants();
    };
    this.selfStageLeaveListener = () => {
      this.removeScreenShare(this.meeting.self);
      this.updateActiveParticipants();
    };
    this.onPresentationStart = () => {
      if (this.meeting == null)
        return;
      this.updateActiveParticipants();
    };
    this.onPresentationEnd = (participant) => {
      if (this.meeting == null)
        return;
      this.removePinned(participant);
      this.removeScreenShare(participant);
      this.updateActiveParticipants();
    };
    this.onScreenShareUpdate = (participant) => {
      if (participant.screenShareEnabled) {
        this.addScreenShare(participant);
      }
      else {
        this.removeScreenShare(participant);
      }
    };
    this.onSelfScreenShareUpdate = ({ screenShareEnabled, }) => {
      if (screenShareEnabled) {
        this.addScreenShare(this.meeting.self);
      }
      else {
        this.removeScreenShare(this.meeting.self);
      }
    };
    this.onPluginStateUpdate = (plugin, { active }) => {
      if (active) {
        if (!this.plugins.some((p) => p.id === plugin.id)) {
          this.plugins = [...this.plugins, plugin];
        }
      }
      else {
        this.plugins = this.plugins.filter((p) => p.id !== plugin.id);
      }
    };
    this.onParticipantPinned = () => {
      this.updateActiveParticipants();
    };
    this.onParticipantUnpinned = () => {
      this.updateActiveParticipants();
    };
    this.participants = [];
    this.pinnedParticipants = [];
    this.screenShareParticipants = [];
    this.plugins = [];
    this.showWebinarStage = false;
    this.showLiveStreamPlayer = false;
    this.canCurrentPeerHost = false;
    this.connected = true;
    this.pipSupported = false;
    this.pipEnabled = false;
    this.layout = 'row';
    this.aspectRatio = '16:9';
    this.meeting = undefined;
    this.gap = 8;
    this.size = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.gridSize = defaultGridSize;
    this.overrides = {};
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectMeeting(meeting) {
    var _a, _b;
    if (meeting == null)
      return;
    this.participants = [];
    this.plugins = [];
    const { self, participants, plugins, meta } = meeting;
    participants.active.removeListener('participantJoined', this.onParticipantJoined);
    participants.active.removeListener('participantLeft', this.onParticipantLeft);
    participants.joined.removeListener('screenShareUpdate', this.onScreenShareUpdate);
    participants.joined.removeListener('peerStartedPresenting', this.onPresentationStart);
    participants.joined.removeListener('peerStoppedPresenting', this.onPresentationEnd);
    self.removeListener('screenShareUpdate', this.onSelfScreenShareUpdate);
    plugins === null || plugins === void 0 ? void 0 : plugins.all.removeListener('stateUpdate', this.onPluginStateUpdate);
    participants.pinned.removeListener('participantJoined', this.onParticipantPinned);
    participants.pinned.removeListener('participantLeft', this.onParticipantUnpinned);
    self.removeListener('pinned', this.onParticipantPinned);
    self.removeListener('unpinned', this.onParticipantUnpinned);
    participants.removeListener('viewModeChanged', this.onViewModeChanged);
    self.removeListener('stageJoined', this.selfStageJoinListener);
    self.removeListener('stageLeft', this.selfStageLeaveListener);
    self.removeListener('removedFromStage', this.selfStageLeaveListener);
    self.removeListener('videoUpdate', this.onSelfVideoUpdateListener);
    self.removeListener('audioUpdate', this.onSelfAudioUpdateListener);
    meta.removeListener('disconnected', this.meetingDisconnectedListener);
    meta.removeListener('connected', this.meetingConnectedListener);
    (_a = meeting.stage) === null || _a === void 0 ? void 0 : _a.removeListener('stageStatusUpdate', this.handlePipMediaControls);
    meeting.self.removeListener('stageJoined', this.enablePipMediaControls);
    meeting.self.removeListener('stageLeft', this.disablePipMediaControls);
    (_b = meeting.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', this.updateLiveStreamStage);
  }
  disconnectedCallback() {
    this.disconnectMeeting(this.meeting);
  }
  screenShareParticipantsChanged(participants) {
    const activeScreenShare = participants.length > 0;
    this.stateUpdate.emit({ activeScreenShare });
    state.activeScreenShare = activeScreenShare;
  }
  pluginsChanged(plugins) {
    const activePlugin = plugins.length > 0;
    this.stateUpdate.emit({ activePlugin });
    state.activePlugin = activePlugin;
  }
  pinnedParticipantsChanged(participants) {
    const activeSpotlight = participants.length > 0;
    this.stateUpdate.emit({ activeSpotlight });
    state.activeSpotlight = activeSpotlight;
  }
  updateActiveParticipants() {
    var _a, _b;
    const { self, participants } = this.meeting;
    const isWebinarHiddenParticipant = ((_a = self.config) === null || _a === void 0 ? void 0 : _a.viewType) === 'WEBINAR' && self.webinarStageStatus !== 'ON_STAGE';
    // NOTE(ishita1805): checking hiddenParticipant for v2 meetings.
    const isRecorder = (_b = self.permissions) === null || _b === void 0 ? void 0 : _b.isRecorder;
    this.hideSelf = isWebinarHiddenParticipant || isRecorder || self.permissions.hiddenParticipant;
    this.participants = this.filterParticipants([
      ...participants.active.toArray().filter((p) => p.id !== self.id),
      ...(participants.viewMode === 'ACTIVE_GRID' && !self.isPinned && !this.hideSelf
        ? [self]
        : []),
    ]);
    this.pinnedParticipants = [
      ...participants.pinned.toArray().filter((p) => p.id !== self.id),
      ...(self.isPinned && !this.hideSelf ? [self] : []),
    ];
    this.screenShareParticipants = participants.joined
      .toArray()
      .filter((participant) => participant.screenShareEnabled);
    if (self.screenShareEnabled) {
      this.screenShareParticipants = this.screenShareParticipants.concat([self]);
    }
    this.updateWebinarStage();
  }
  updateWebinarStage() {
    if (this.meeting && this.meeting.meta.viewType === 'WEBINAR') {
      this.showWebinarStage =
        this.participants.length === 0 && this.pinnedParticipants.length === 0;
    }
    else {
      this.showWebinarStage = false;
    }
  }
  updateLiveStreamStage() {
    this.showLiveStreamPlayer = isLiveStreamViewer(this.meeting);
  }
  meetingChanged(meeting, oldMeeting) {
    var _a, _b, _c;
    if (oldMeeting !== null)
      this.disconnectMeeting(oldMeeting);
    if (meeting != null) {
      const { self, participants, plugins, meta, stage } = meeting;
      // Initialize values
      const { config, permissions } = self;
      const isWebinarHiddenParticipant = (config === null || config === void 0 ? void 0 : config.viewType) === 'WEBINAR' && this.meeting.self.webinarStageStatus !== 'ON_STAGE';
      const isRecorder = permissions === null || permissions === void 0 ? void 0 : permissions.isRecorder;
      this.hideSelf = isWebinarHiddenParticipant || isRecorder || permissions.hiddenParticipant;
      this.participants = this.filterParticipants([
        ...participants.active.toArray(),
        ...(!self.isPinned && !this.hideSelf ? [self] : []),
      ]);
      this.pinnedParticipants = [
        ...participants.pinned.toArray(),
        ...(self.isPinned && !this.hideSelf ? [self] : []),
      ];
      this.screenShareParticipants = participants.joined
        .toArray()
        .filter((participant) => participant.screenShareEnabled);
      this.plugins = (plugins === null || plugins === void 0 ? void 0 : plugins.active.toArray()) || [];
      if ((config === null || config === void 0 ? void 0 : config.viewType) === 'WEBINAR') {
        this.canCurrentPeerHost = permissions.acceptPresentRequests || permissions.canPresent;
        this.updateWebinarStage();
      }
      // Check if PiP is supported and enabled
      this.pipSupported = store.isSupported() && ((_a = meeting.self.config) === null || _a === void 0 ? void 0 : _a.pipMode);
      if (this.pipSupported) {
        const onReady = () => { };
        const onStop = () => {
          this.stateUpdate.emit({ activePipMode: false });
        };
        store.create(onReady, onStop, this.eventCallback);
        this.enablePipMediaControls(meeting);
        (_b = meeting.stage) === null || _b === void 0 ? void 0 : _b.on('stageStatusUpdate', this.handlePipMediaControls);
        meeting.self.on('stageJoined', this.enablePipMediaControls);
        meeting.self.on('stageLeft', this.disablePipMediaControls);
      }
      const isEnabled = document.pictureInPictureElement !== null;
      const localStates = this.states || state;
      // correct PiP state
      if (store.isSupported() && localStates.activePipMode !== isEnabled) {
        this.stateUpdate.emit({ activePipMode: isEnabled });
      }
      // Add all listeners
      participants.active.addListener('participantJoined', this.onParticipantJoined);
      participants.active.addListener('participantLeft', this.onParticipantLeft);
      participants.joined.addListener('screenShareUpdate', this.onScreenShareUpdate);
      participants.joined.addListener('peerStartedPresenting', this.onPresentationStart);
      participants.joined.addListener('peerStoppedPresenting', this.onPresentationEnd);
      self.addListener('screenShareUpdate', this.onSelfScreenShareUpdate);
      plugins === null || plugins === void 0 ? void 0 : plugins.all.addListener('stateUpdate', this.onPluginStateUpdate);
      participants.pinned.addListener('participantJoined', this.onParticipantPinned);
      participants.pinned.addListener('participantLeft', this.onParticipantUnpinned);
      self.addListener('pinned', this.onParticipantPinned);
      self.addListener('videoUpdate', this.onSelfVideoUpdateListener);
      self.addListener('audioUpdate', this.onSelfAudioUpdateListener);
      self.addListener('unpinned', this.onParticipantUnpinned);
      self.addListener('stageJoined', this.selfStageJoinListener);
      self.addListener('stageLeft', this.selfStageLeaveListener);
      self.addListener('removedFromStage', this.selfStageLeaveListener);
      meta.addListener('disconnected', this.meetingDisconnectedListener);
      meta.addListener('connected', this.meetingConnectedListener);
      stage === null || stage === void 0 ? void 0 : stage.addListener('stageStatusUpdate', this.updateLiveStreamStage.bind(this));
      participants.addListener('viewModeChanged', this.onViewModeChanged);
      if ((_c = meeting.stage) === null || _c === void 0 ? void 0 : _c.status) {
        this.updateLiveStreamStage();
      }
    }
  }
  addScreenShare(participant) {
    if (!this.screenShareParticipants.some((p) => p.id === participant.id)) {
      this.screenShareParticipants = [...this.screenShareParticipants, participant];
    }
  }
  removeScreenShare(participant) {
    this.screenShareParticipants = this.screenShareParticipants.filter((p) => p.id !== participant.id);
  }
  removePinned(participant) {
    this.pinnedParticipants = this.pinnedParticipants.filter((p) => p.id !== participant.id);
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      size: this.size,
      states: this.states || state,
      config: this.config,
      iconPack: this.iconPack,
      t: this.t,
    };
    if (!this.connected && this.hideSelf) {
      return (h("div", { class: "webinar-stage" }, h("div", { class: "center" }, h("h2", null, this.t('stage.reconnecting')))));
    }
    if (this.showWebinarStage) {
      return (h(Host, null, h("div", { class: "webinar-stage" }, h("div", { class: "center" }, this.canCurrentPeerHost && (h("div", null, h("h2", null, this.t('stage.empty_host')), h("p", null, this.t('stage.empty_host_summary')))), !this.canCurrentPeerHost && h("h2", null, this.t('stage.empty_viewer'))))));
    }
    if (this.showLiveStreamPlayer) {
      return (h(Host, null, h("dyte-livestream-player", { meeting: this.meeting, size: this.size }), h("dyte-livestream-indicator", { meeting: this.meeting, size: "sm", t: this.t }), h("dyte-viewer-count", { meeting: this.meeting, variant: "embedded", t: this.t })));
    }
    return (h(Host, null, h(Render, { element: "dyte-grid", defaults: defaults, childProps: {
        participants: this.participants,
        screenShareParticipants: this.screenShareParticipants,
        plugins: this.plugins,
        pinnedParticipants: this.pinnedParticipants,
        aspectRatio: this.aspectRatio,
        gap: this.gap,
        layout: this.layout,
        gridSize: this.gridSize,
      }, onlyChildren: true }), h("dyte-livestream-indicator", { meeting: this.meeting, size: "sm", t: this.t }), h("dyte-viewer-count", { meeting: this.meeting, variant: "embedded" })));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "screenShareParticipants": ["screenShareParticipantsChanged"],
    "plugins": ["pluginsChanged"],
    "pinnedParticipants": ["pinnedParticipantsChanged"],
    "meeting": ["meetingChanged"]
  }; }
};
DyteGrid.style = dyteGridCss;

var dyteGrid_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_grid: DyteGrid
});

const dyteGridPaginationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;font-size:16px}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}:host([size='sm']) .center{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host([size='sm']) dyte-button{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}:host([size='sm']) dyte-button dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}dyte-button{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.center{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.center .page{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.center .slash{margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-0\\.5, 2px)}.center .pages{align-self:flex-end;font-size:12px}:host([variant='rounded']){overflow:hidden;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([variant='rounded']) dyte-button{border-radius:9999px;border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}:host([variant='rounded']) dyte-button:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='rounded']) dyte-button:not([disabled]):focus{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='grid']){margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host([variant='grid']) dyte-button{position:absolute;top:50%;height:var(--dyte-space-20, 80px);width:var(--dyte-space-20, 80px);opacity:0.2;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}:host([variant='grid']) dyte-button:hover{opacity:1}:host([variant='grid']) dyte-button{transform:translateY(-50%)}:host([variant='grid']) dyte-button.prev{left:var(--dyte-space-0, 0px);border-top-right-radius:9999px;border-bottom-right-radius:9999px}:host([variant='grid']) dyte-button.next{right:var(--dyte-space-0, 0px);border-top-left-radius:9999px;border-bottom-left-radius:9999px}:host([variant='grid']) dyte-button.auto{left:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);border-top-right-radius:9999px;border-bottom-right-radius:9999px}:host([variant='grid']) .dots{position:absolute;left:50%;bottom:var(--dyte-space-3, 12px);display:flex;align-items:center;transform:translateX(-50%)}:host([variant='grid']) .dots .dot{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-2, 8px);width:var(--dyte-space-2, 8px);cursor:pointer;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([variant='grid']) .dots .dot:last-child{margin-right:var(--dyte-space-0, 0px)}:host([variant='grid']) .dots .dot.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host([variant='grid'][size='sm']) dyte-button{height:var(--dyte-space-14, 56px);width:var(--dyte-space-14, 56px);opacity:0.1}";

const DyteGridPagination = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onPageChanged = ({ currentPage, pageCount, }) => {
      this.pageCount = pageCount;
      this.page = currentPage;
    };
    this.toggleGridPagination = () => {
      var _a;
      const { self, participants } = this.meeting;
      const { mobile, desktop } = (_a = self.config) === null || _a === void 0 ? void 0 : _a.maxVideoStreams;
      const maxCount = this.size === 'sm' ? mobile : desktop;
      if (participants.joined.size < maxCount)
        this.showPagination = false;
      else
        this.showPagination = true;
    };
    this.onParticipantJoin = () => {
      this.pageCount = this.meeting.participants.pageCount;
      this.toggleGridPagination();
    };
    this.onParticipantLeave = () => {
      this.pageCount = this.meeting.participants.pageCount;
      this.toggleGridPagination();
    };
    this.prevPage = () => {
      if (this.meeting == null)
        return;
      const { participants } = this.meeting;
      if (this.page > 1) {
        participants.setPage((this.page -= 1));
      }
      else if (participants.viewMode === 'PAGINATED') {
        participants.setViewMode('ACTIVE_GRID');
      }
    };
    this.nextPage = () => {
      if (this.meeting == null)
        return;
      const { participants } = this.meeting;
      if (this.page > 0 && this.page < this.pageCount) {
        participants.setPage((this.page += 1));
      }
      else if (participants.count > 0 && this.pageCount === 0) {
        participants.setViewMode('PAGINATED');
      }
    };
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.variant = 'rounded';
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.page = 1;
    this.pageCount = 0;
    this.activeCount = 0;
    this.activeComputedCount = 0;
    this.showPagination = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.sizeChanged();
  }
  disconnectedCallback() {
    if (this.meeting == null)
      return;
    const { participants } = this.meeting;
    participants.removeListener('pageChanged', this.onPageChanged);
    participants.removeListener('viewModeChanged', this.onPageChanged);
    participants.joined.removeListener('participantJoined', this.onParticipantJoin);
    participants.joined.removeListener('participantLeft', this.onParticipantLeave);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      const { participants } = meeting;
      this.page = participants.currentPage;
      this.pageCount = participants.pageCount;
      participants.addListener('viewModeChanged', this.onPageChanged);
      participants.addListener('pageChanged', this.onPageChanged);
      participants.joined.addListener('participantJoined', this.onParticipantJoin);
      participants.joined.addListener('participantLeft', this.onParticipantLeave);
      this.activeCount = this.meeting.participants.joined.size;
      this.activeComputedCount = this.meeting.participants.joined.size;
      this.toggleGridPagination();
    }
  }
  sizeChanged() {
    this.toggleGridPagination();
  }
  render() {
    const isWebinar = this.meeting.meta.viewType === 'WEBINAR';
    if (isWebinar || !this.showPagination) {
      return;
    }
    return (h(Host, null, h("dyte-button", { class: "prev", variant: "secondary", kind: "icon", disabled: this.pageCount === 0, onClick: this.prevPage, "aria-label": this.t('page.prev'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), this.variant !== 'grid' && (h("div", { class: "center" }, h("span", { class: "page" }, this.pageCount === 0 ? (h("dyte-tooltip", { label: this.t('layout.auto'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { kind: "icon", class: "auto", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.wand, iconPack: this.iconPack, t: this.t })))) : (this.page)), this.pageCount !== 0 && [
      h("span", { class: "slash" }, "/"),
      h("span", { class: "pages" }, this.pageCount),
    ])), this.variant === 'grid' && this.pageCount > 0 && (h("div", { class: "dots" }, [...Array(this.pageCount)].map((_, index) => (h("div", { key: `dot-${index}`, class: { dot: true, active: index + 1 === this.page } }))))), h("dyte-button", { class: "next", variant: "secondary", kind: "icon", disabled: this.page !== 0 && this.page === this.pageCount, onClick: this.nextPage, "aria-label": this.t('page.next'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_right, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "size": ["sizeChanged"]
  }; }
};
DyteGridPagination.style = dyteGridPaginationCss;

var dyteGridPagination_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_grid_pagination: DyteGridPagination
});

const dyteHeaderCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:var(--dyte-space-12, 48px);align-items:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{display:none !important}}";

const DyteHeader = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.variant = 'solid';
    this.disableRender = false;
    this.meeting = undefined;
    this.config = defaultConfig;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.size = undefined;
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states,
      t: this.t,
      iconPack: this.iconPack,
      size: this.size,
    };
    return (h(Host, null, !this.disableRender && h(Render, { element: "dyte-header", defaults: defaults, onlyChildren: true }), h("slot", null)));
  }
};
DyteHeader.style = dyteHeaderCss;

var dyteHeader_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_header: DyteHeader
});

const dyteIdleScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.ctr{display:flex;flex-direction:column;align-items:center}dyte-logo{margin-bottom:var(--dyte-space-10, 40px);height:var(--dyte-space-12, 48px)}dyte-spinner{height:var(--dyte-space-12, 48px);width:var(--dyte-space-12, 48px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

const DyteIdleScreen = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("slot", null, h("div", { class: "ctr", part: "container" }, h("dyte-logo", { meeting: this.meeting, config: this.config, t: this.t, part: "logo" }), h("dyte-spinner", { "aria-label": "Idle, waiting for meeting data", part: "spinner", iconPack: this.iconPack, t: this.t })))));
  }
};
DyteIdleScreen.style = dyteIdleScreenCss;

var dyteIdleScreen_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_idle_screen: DyteIdleScreen
});

const getExtension = (name) => {
  // split query and hash from url, then get the filename
  return name.split(/[#?]/)[0].split('.').pop().trim();
};
/**
 * Formats size in bytes to human readable formats
 * @param size Size in bytes
 * @returns Human readable file size
 */
const getFileSize = (size) => {
  if (!size)
    return '0 B';
  const i = Math.floor(Math.log(size) / Math.log(1024));
  return `${(size / 1024 ** i).toFixed(2)} ${['B', 'kB', 'MB', 'GB', 'TB'][i]}`;
};
/**
 * Extracts the file name from a URL.
 * @param link The URL of the file
 * @param fallback Fallback filename
 * @returns File name
 */
const getFileName = (link, fallback = 'file') => {
  try {
    const url = new URL(link);
    const name = url.pathname.split('/').pop();
    return name !== '/' ? name : fallback;
  }
  catch (_) {
    return fallback;
  }
};
/**
 * Downloads file from a given URL without leaving the current page
 * @param link URL of the file to download
 * @param options Optional Options for file download - `name` and `fallbackName`
 */
const downloadFile = async (link, options) => {
  link = sanitizeLink(link);
  let name = options === null || options === void 0 ? void 0 : options.name;
  const res = await fetch(link);
  if (!res.ok) {
    // if unable to download file (CORS or some other error)
    // open the URL in new tab
    window.open(link, '_blank');
    return;
  }
  const blobURL = URL.createObjectURL(await res.blob());
  // Creates an anchor tag and simulates download
  const a = document.createElement('a');
  a.href = blobURL;
  a.download = name !== null && name !== void 0 ? name : getFileName(link, options === null || options === void 0 ? void 0 : options.fallbackName);
  a.click();
};

const dyteImageViewerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{width:1140px;max-width:100%;box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-6, 24px);padding-top:var(--dyte-space-5, 20px);overflow-y:auto;color:rgb(var(--dyte-colors-text-1000, 255 255 255));z-index:40;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.displayName{font-weight:700}.image-ctr{margin-top:var(--dyte-space-2, 8px);box-sizing:border-box;display:flex;justify-content:center;overflow:hidden}.actions{display:flex;align-items:center;justify-content:flex-end;gap:var(--dyte-space-2, 8px)}img{box-sizing:border-box;display:block;max-height:100%;max-width:100%;-o-object-fit:contain;object-fit:contain}.header{display:flex;align-items:center;justify-content:space-between;padding-bottom:var(--dyte-space-4, 16px)}.shared-by-user{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}:host([size='sm']) .header{flex-direction:column}:host([size='sm']) .header .actions{margin-top:var(--dyte-space-4, 16px)}";

const DyteImageViewer = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.close = createEvent(this, "close", 7);
    this.keypressListener = (e) => {
      if (e.key === 'Escape') {
        this.close.emit();
      }
    };
    this.handleOutsideClick = () => this.close.emit();
    this.image = undefined;
    this.size = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
  }
  connectedCallback() {
    document.addEventListener('keydown', this.keypressListener);
    document.addEventListener('click', this.handleOutsideClick);
  }
  disconnectedCallback() {
    document.removeEventListener('keydown', this.keypressListener);
    document.removeEventListener('click', this.handleOutsideClick);
  }
  render() {
    return (h(Host, { class: "scrollbar", onClick: (e) => e.stopPropagation() }, h("div", { class: "header" }, h("div", { class: "shared-by-user" }, this.t('chat.img.shared_by'), ' ', h("span", { class: "displayName" }, formatName(shorten(this.image.displayName)))), h("div", { class: "actions" }, h("dyte-button", { kind: "icon", variant: "secondary", onClick: () => this.close.emit(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.full_screen_minimize, iconPack: this.iconPack, t: this.t })), h("dyte-button", { onClick: () => downloadFile(this.image.link, { fallbackName: 'image' }), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.download, slot: "start", iconPack: this.iconPack, t: this.t }), "Download"))), h("div", { class: "image-ctr" }, h("img", { src: this.image.link }))));
  }
};
DyteImageViewer.style = dyteImageViewerCss;

var dyteImageViewer_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_image_viewer: DyteImageViewer
});

const dyteLeaveButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteLeaveButton = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.leave = () => {
      this.stateUpdate.emit({ activeLeaveConfirmation: true });
      state.activeLeaveConfirmation = true;
    };
    this.variant = 'button';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    const text = this.t('leave');
    return (h(Host, { label: text }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, class: "leave", onClick: this.leave, icon: this.iconPack.call_end, label: text, variant: this.variant })));
  }
};
DyteLeaveButton.style = dyteLeaveButtonCss;

var dyteLeaveButton_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_leave_button: DyteLeaveButton
});

const dyteLeaveMeetingCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.leave-modal{width:var(--dyte-space-72, 288px)}@media (min-width: 768px){.leave-modal{width:var(--dyte-space-96, 384px)}}.leave-modal{position:relative;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding:var(--dyte-space-8, 32px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}.leave-modal .message{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.leave-modal .content{margin-top:var(--dyte-space-4, 16px);font-size:14px;display:flex;flex-wrap:wrap;gap:var(--dyte-space-4, 16px)}.leave-modal .content dyte-button{height:var(--dyte-space-9, 36px);min-width:var(--dyte-space-44, 176px);flex-grow:1}.leave-modal .content .secondary-btn{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.leave-modal .content .secondary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.leave-modal .content .secondary-danger-btn{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DyteLeaveMeeting = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.keyPressListener = (e) => {
      if (e.key === 'Escape') {
        this.close();
      }
    };
    this.isBreakoutRoomsActive = false;
    this.isChildMeeting = false;
    this.canJoinMainRoom = false;
    this.close = () => {
      this.stateUpdate.emit({ activeLeaveConfirmation: false });
      state.activeLeaveConfirmation = false;
    };
    this.handleLeave = () => {
      var _a;
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.leaveRoom();
      this.close();
    };
    this.handleJoinMainRoom = () => {
      this.meeting.connectedMeetings.moveParticipants(this.meeting.meta.roomName, this.meeting.connectedMeetings.parentMeeting.id, [this.meeting.self.userId]);
      this.close();
    };
    this.handleEndMeeting = () => {
      var _a;
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.participants.kickAll();
      this.close();
    };
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.canEndMeeting = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    document.addEventListener('keydown', this.keyPressListener);
  }
  componentDidLoad() { }
  disconnectedCallback() {
    document.removeEventListener('keydown', this.keyPressListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.canEndMeeting = meeting.self.permissions.kickParticipant;
      this.isBreakoutRoomsActive =
        this.meeting.connectedMeetings.supportsConnectedMeetings &&
          this.meeting.connectedMeetings.isActive;
      this.isChildMeeting =
        this.meeting.connectedMeetings.supportsConnectedMeetings &&
          this.meeting.connectedMeetings.meetings.some((cMeet) => cMeet.id === meeting.meta.roomName);
      this.canJoinMainRoom =
        this.meeting.self.permissions.connectedMeetings.canSwitchToParentMeeting;
    }
  }
  render() {
    return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, this.t('leave'))), h("p", { class: "message" }, this.isBreakoutRoomsActive && this.isChildMeeting
      ? this.t('breakout_rooms.leave_confirmation')
      : this.t('leave_confirmation')), h("div", { class: "content" }, h("dyte-button", { variant: "secondary", onClick: this.close, iconPack: this.iconPack, class: "secondary-btn", t: this.t }, this.t('cancel')), this.isBreakoutRoomsActive && this.isChildMeeting && this.canJoinMainRoom && (h("dyte-button", { variant: "secondary", onClick: this.handleJoinMainRoom, iconPack: this.iconPack, class: "secondary-btn", t: this.t }, this.t('breakout_rooms.leave_confirmation.main_room_btn'))), h("dyte-button", { variant: this.canEndMeeting ? 'secondary' : 'danger', title: this.t('leave'), onClick: this.handleLeave, iconPack: this.iconPack, class: {
        'secondary-btn': this.canEndMeeting,
        'secondary-danger-btn': this.canEndMeeting,
      }, t: this.t }, this.t('leave')), this.canEndMeeting && (h("dyte-button", { variant: "danger", onClick: this.handleEndMeeting, iconPack: this.iconPack, t: this.t }, this.t('end.all')))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteLeaveMeeting.style = dyteLeaveMeetingCss;

var dyteLeaveMeeting_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_leave_meeting: DyteLeaveMeeting
});

const dyteLivestreamToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteLivestreamToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
    this.livestreamStateListener = (state$1) => {
      this.livestreamState = state$1;
      if (state$1 === 'LIVESTREAMING' || state$1 === 'IDLE') {
        this.stateUpdate.emit({ activeMoreMenu: false });
        state.activeMoreMenu = false;
      }
    };
    this.isLoading = () => {
      return (this.meeting == null ||
        this.livestreamState === 'STARTING' ||
        this.livestreamState === 'STOPPING');
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.livestreamState = 'IDLE';
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    this.clearListeners();
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting == null)
      return;
    this.livestreamState = (_a = this.meeting.livestream) === null || _a === void 0 ? void 0 : _a.state;
    (_b = this.meeting.livestream) === null || _b === void 0 ? void 0 : _b.on('livestreamUpdate', this.livestreamStateListener);
  }
  async toggleLivestream() {
    var _a, _b;
    if (this.livestreamState === 'LIVESTREAMING') {
      try {
        await ((_a = this.meeting.livestream) === null || _a === void 0 ? void 0 : _a.stop());
      }
      catch (_c) {
        this.dyteAPIError.emit({
          trace: this.t('livestream.stop'),
          message: this.t('livestream.error.stop'),
        });
      }
    }
    else {
      try {
        await ((_b = this.meeting.livestream) === null || _b === void 0 ? void 0 : _b.start());
      }
      catch (_d) {
        this.dyteAPIError.emit({
          trace: this.t('livestream.start'),
          message: this.t('livestream.error.start'),
        });
      }
    }
  }
  clearListeners() {
    var _a;
    (_a = this.meeting.livestream) === null || _a === void 0 ? void 0 : _a.removeListener('livestreamUpdate', this.livestreamStateListener);
  }
  getLivestreamLabel() {
    switch (this.livestreamState) {
      case 'IDLE':
        return this.t('livestream.go_live');
      case 'LIVESTREAMING':
        return this.t('livestream.end_live');
      case 'STARTING':
        return this.t('livestream.starting');
      case 'STOPPING':
        return this.t('livestream.stopping');
      default:
        return this.t('livestream.error');
    }
  }
  getLivestreamIcon() {
    switch (this.livestreamState) {
      case 'IDLE':
        return this.iconPack.start_livestream;
      case 'LIVESTREAMING':
        return this.iconPack.stop_livestream;
      case 'STARTING':
      case 'STOPPING':
      default:
        return this.iconPack.stop_livestream;
    }
  }
  render() {
    if (!isLiveStreamHost(this.meeting))
      return;
    return (h(Host, null, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, isLoading: this.isLoading(), class: { 'active-livestream': this.livestreamState === 'LIVESTREAMING' }, onClick: () => this.toggleLivestream(), icon: this.getLivestreamIcon(), disabled: this.isLoading(), label: this.t(this.getLivestreamLabel()), variant: this.variant })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteLivestreamToggle.style = dyteLivestreamToggleCss;

var dyteLivestreamToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_livestream_toggle: DyteLivestreamToggle
});

const dyteMeetingTitleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:16px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.title{text-align:center;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}:host([size='sm']){font-size:12px}";

const DyteMeetingTitle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    var _a;
    const title = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta.meetingTitle;
    if (title == null)
      return null;
    return (h(Host, { tabIndex: 0, role: "banner", "aria-label": title }, h("dyte-tooltip", { label: title, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("div", { class: "title", part: "title" }, title))));
  }
};
DyteMeetingTitle.style = dyteMeetingTitleCss;

var dyteMeetingTitle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_meeting_title: DyteMeetingTitle
});

const dyteMicToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}:host(.audioDisabled) :slotted(dyte-icon){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DyteMicToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.audioUpdateListener = ({ audioEnabled }) => {
      this.audioEnabled = audioEnabled;
    };
    this.selfJoinStateListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.selfStageLeftListener = () => {
      this.canProduceAudio = false;
    };
    this.selfJoinStateRejectedListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.mediaPermissionUpdateListener = ({ kind, message }) => {
      if (kind === 'audio') {
        this.micPermission = message;
      }
    };
    this.toggleMic = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__.logger.info('dyteMicToggle::toggleMic', {
        media: {
          audio: {
            enabled: Boolean((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self) === null || _c === void 0 ? void 0 : _c.audioEnabled),
            permission: this.micPermission,
            canProduce: (_f = (_e = (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self) === null || _e === void 0 ? void 0 : _e.permissions) === null || _f === void 0 ? void 0 : _f.canProduceAudio,
          },
        },
        webinar: {
          stageStatus: (_h = (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self) === null || _h === void 0 ? void 0 : _h.webinarStageStatus,
        },
        livestream: {
          stageStatus: (_k = (_j = this.meeting) === null || _j === void 0 ? void 0 : _j.stage) === null || _k === void 0 ? void 0 : _k.status,
        },
        moduleExists: {
          self: Boolean((_l = this.meeting) === null || _l === void 0 ? void 0 : _l.self),
        },
      });
      if (this.hasPermissionError()) {
        const permissionModalSettings = {
          enabled: true,
          kind: 'audio',
        };
        this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
        state.activePermissionsMessage = permissionModalSettings;
        return false;
      }
      const self = (_m = this.meeting) === null || _m === void 0 ? void 0 : _m.self;
      if (self == null || !this.canProduceAudio) {
        return;
      }
      if (self.audioEnabled) {
        self.disableAudio();
      }
      else {
        self.enableAudio();
      }
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.audioEnabled = false;
    this.canProduceAudio = false;
    this.micPermission = 'NOT_REQUESTED';
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.removeListener('audioUpdate', this.audioUpdateListener);
    (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('joinStageRequestAccepted', this.selfJoinStateListener);
    (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self.removeListener('joinStageRequestRejected', this.selfJoinStateRejectedListener);
    (_e = this.meeting) === null || _e === void 0 ? void 0 : _e.self.removeListener('stageJoined', this.selfJoinStateListener);
    (_f = this.meeting) === null || _f === void 0 ? void 0 : _f.self.removeListener('stageLeft', this.selfStageLeftListener);
    (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self.removeListener('removedFromStage', this.selfJoinStateListener);
    (_j = (_h = this.meeting) === null || _h === void 0 ? void 0 : _h.stage) === null || _j === void 0 ? void 0 : _j.removeListener('stageStatusUpdate', this.selfJoinStateListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      const { self, stage } = meeting;
      this.updateCanProduce(meeting);
      this.micPermission = meeting.self.mediaPermissions.audio || 'NOT_REQUESTED';
      this.audioEnabled = self.audioEnabled;
      self.addListener('audioUpdate', this.audioUpdateListener);
      self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      self.addListener('joinStageRequestAccepted', this.selfJoinStateListener);
      self.addListener('joinStageRequestRejected', this.selfJoinStateRejectedListener);
      self.addListener('stageJoined', this.selfJoinStateListener);
      self.addListener('stageLeft', this.selfStageLeftListener);
      self.addListener('removedFromStage', this.selfJoinStateListener);
      stage === null || stage === void 0 ? void 0 : stage.addListener('stageStatusUpdate', this.selfJoinStateListener);
    }
  }
  updateCanProduce(meeting) {
    const { self, meta, stage } = meeting;
    const canProduceAudio = self.permissions.canProduceAudio === 'ALLOWED';
    const isWebinar = meta.viewType === 'WEBINAR';
    const isLiveStream = meta.viewType === 'LIVESTREAM';
    this.canProduceAudio = false;
    if (canProduceAudio && !isLiveStream) {
      this.canProduceAudio = true;
    }
    else if (isWebinar || isLiveStream) {
      if (canProduceAudio &&
        stage.status !== 'OFF_STAGE' &&
        stage.status !== 'REQUESTED_TO_JOIN_STAGE')
        this.canProduceAudio = true;
      const canRequestAudio = self.permissions.canProduceAudio === 'CAN_REQUEST';
      // If the peer can present or has approved request to present
      if (canRequestAudio &&
        ((isWebinar &&
          (self.webinarStageStatus === 'ON_STAGE' ||
            self.webinarStageStatus === 'ACCEPTED_TO_JOIN_STAGE')) ||
          (isLiveStream &&
            (stage.status === 'ON_STAGE' || stage.status === 'ACCEPTED_TO_JOIN_STAGE')))) {
        this.canProduceAudio = true;
      }
    }
  }
  hasPermissionError() {
    return this.micPermission === 'DENIED' || this.micPermission === 'SYSTEM_DENIED';
  }
  getState() {
    let tooltipLabel = '';
    let label = '';
    let icon = '';
    let classList = {};
    let hasError = this.hasPermissionError();
    let couldNotStart = this.micPermission === 'COULD_NOT_START';
    if (this.audioEnabled && !hasError) {
      label = this.t('mic_on');
      icon = this.iconPack.mic_on;
    }
    else {
      label = this.t('mic_off');
      icon = this.iconPack.mic_off;
      classList['red-icon'] = true;
    }
    if (couldNotStart) {
      tooltipLabel = this.t('perm_could_not_start.audio');
    }
    else if (this.micPermission === 'SYSTEM_DENIED') {
      tooltipLabel = this.t('perm_sys_denied.audio');
    }
    else if (this.micPermission === 'DENIED') {
      tooltipLabel = this.t('perm_denied.audio');
    }
    else {
      tooltipLabel = this.audioEnabled ? this.t('disable_mic') : this.t('enable_mic');
    }
    return {
      tooltipLabel,
      label,
      icon,
      classList,
      showWarning: hasError || couldNotStart,
      disable: hasError,
    };
  }
  render() {
    if (!this.canProduceAudio) {
      return null;
    }
    const { tooltipLabel, label, icon, classList, showWarning, disable } = this.getState();
    return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: tooltipLabel, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", icon: icon, label: label, size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, class: classList, onClick: this.toggleMic, showWarning: showWarning, disabled: disable }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteMicToggle.style = dyteMicToggleCss;

var dyteMicToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_mic_toggle: DyteMicToggle
});

const dyteMixedGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:100%;width:100%;display:flex}main{display:flex;flex:1 1 0%;padding-left:var(--dyte-space-4, 16px)}:host([layout='column']) main{padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}main dyte-tab-bar{margin-right:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;height:100%;width:var(--dyte-space-16, 64px);flex-direction:column}main #tabs{height:100%;flex:1 1 0%}dyte-button{z-index:10}.grid-width-sm{width:25%}.grid-width-md{width:50%}.grid-width-lg{width:66.666667%}.col{display:flex;flex-direction:column;align-items:center}.tab{display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center;margin-bottom:var(--dyte-space-2, 8px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.tab.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}.tab img{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);border-radius:var(--dyte-border-radius-sm, 4px)}:host([size='sm']){flex-direction:column}:host([size='sm']) .grid-width-lg,:host([size='sm']) .grid-width-md{height:50%;width:100%;max-width:100%}:host([size='sm']) .grid-width-sm{height:33.333333%;width:100%;max-width:100%}:host([size='sm']) main{display:flex;flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='sm']) dyte-tab-bar{height:var(--dyte-space-12, 48px);width:100%;flex-direction:row}:host([size='sm']) #tabs{flex:1 1 0%}:host([size='sm']) .tab{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-2, 8px)}:host([layout='column']){flex-direction:column}:host([layout='column']) main{display:flex;flex:1 1 0%}:host([layout='column']) .grid-width-lg,:host([layout='column']) .grid-width-md{height:50%;max-width:100%;width:100%}:host([layout='column']) .grid-width-sm{height:33.333333%;max-width:100%;width:100%}@media (orientation: portrait){:host{flex-direction:column}:host .grid-width-lg{height:50%;width:100%;max-width:100%}:host .grid-width-md{height:33.333333%;width:100%;max-width:100%}:host .grid-width-sm{height:25%;width:100%;max-width:100%}:host main{flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='md']) main{flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host dyte-tab-bar{height:var(--dyte-space-16, 64px);width:100%;flex-direction:row}:host #tabs{flex:1 1 0%}:host .tab{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-2, 8px)}}";

const DyteMixedGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.layout = 'row';
    this.participants = [];
    this.pinnedParticipants = [];
    this.screenShareParticipants = [];
    this.plugins = [];
    this.aspectRatio = '16:9';
    this.gap = 8;
    this.size = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.gridSize = defaultGridSize;
    this.activeTab = undefined;
    this.initialised = undefined;
  }
  componentWillLoad() {
    // initialise states
    this.initialised = false;
    this.screenShareParticipantsChanged(this.screenShareParticipants);
    this.pluginsChanged(this.plugins);
    this.initialised = true;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.meeting.spotlight) === null || _a === void 0 ? void 0 : _a.removeListener('activeTabUpdate', this.spotlightTabUpdateListener);
  }
  meetingChanged(meeting) {
    var _a, _b, _c, _d;
    if (meeting != null) {
      if (((_a = meeting.spotlight) === null || _a === void 0 ? void 0 : _a.selfActiveTab) != undefined) {
        this.onSpotlightTabUpdate((_b = meeting.spotlight.selfActiveTab) === null || _b === void 0 ? void 0 : _b.type, (_c = meeting.spotlight.selfActiveTab) === null || _c === void 0 ? void 0 : _c.id);
      }
      this.spotlightTabUpdateListener = (spotlightTab) => {
        this.onSpotlightTabUpdate(spotlightTab === null || spotlightTab === void 0 ? void 0 : spotlightTab.type, spotlightTab === null || spotlightTab === void 0 ? void 0 : spotlightTab.id);
      };
      (_d = meeting.spotlight) === null || _d === void 0 ? void 0 : _d.addListener('activeTabUpdate', this.spotlightTabUpdateListener);
    }
  }
  screenShareParticipantsChanged(participants = []) {
    // If active tab has already been initialised by spotlight then don't change tab.
    if (!this.initialised && this.activeTab != null)
      return;
    if (this.activeTab == null && participants.length > 0) {
      this.setActiveTab({ type: 'screenshare', participant: participants[0] });
    }
    else {
      this.revalidateActiveTab();
    }
  }
  pluginsChanged(plugins) {
    // If active tab has already been initialised by spotlight then don't change tab.
    if (!this.initialised && this.activeTab != null)
      return;
    if (plugins.length > 0) {
      const lastIndex = plugins.length - 1;
      this.setActiveTab({ type: 'plugin', plugin: plugins[lastIndex] });
    }
    else {
      this.revalidateActiveTab();
    }
  }
  revalidateActiveTab() {
    if (this.activeTab != null) {
      if (this.activeTab.type === 'screenshare') {
        const { participant } = this.activeTab;
        if (!this.screenShareParticipants.some((p) => p.id === participant.id)) {
          this.reassignActiveTab();
        }
      }
      else {
        const { plugin } = this.activeTab;
        if (!this.plugins.some((p) => p.id === plugin.id)) {
          this.reassignActiveTab();
        }
      }
    }
  }
  setActiveTab(activeTab, shouldUpdateSelfActiveTab = true) {
    var _a;
    this.activeTab = activeTab;
    const id = activeTab.type === 'screenshare' ? activeTab.participant.id : activeTab.plugin.id;
    if (shouldUpdateSelfActiveTab)
      (_a = this.meeting.spotlight) === null || _a === void 0 ? void 0 : _a.setSelfActiveTab({ type: activeTab.type, id }, 0);
  }
  reassignActiveTab() {
    if (this.screenShareParticipants.length > 0) {
      this.setActiveTab({ type: 'screenshare', participant: this.screenShareParticipants[0] });
    }
    else if (this.plugins.length > 0) {
      const lastIndex = this.plugins.length - 1;
      this.setActiveTab({ type: 'plugin', plugin: this.plugins[lastIndex] });
    }
  }
  onSpotlightTabUpdate(type, id) {
    if (type == undefined)
      return;
    if (id == undefined)
      return;
    switch (type) {
      case 'plugin':
        const plugin = this.plugins.find((p) => p.id === id);
        if (plugin != undefined)
          this.setActiveTab({ type: 'plugin', plugin }, false);
        break;
      case 'screenshare':
        const participant = this.screenShareParticipants.find((ssp) => ssp.id === id);
        if (participant != undefined)
          this.setActiveTab({ type: 'screenshare', participant }, false);
    }
  }
  getTabs() {
    const screenshares = this.screenShareParticipants.map((participant) => ({
      type: 'screenshare',
      participant,
    }));
    const plugins = this.plugins.map((plugin) => ({ type: 'plugin', plugin }));
    return screenshares.concat(plugins);
  }
  render() {
    var _a;
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    return (h(Host, null, h("main", { id: "main-view", part: "main-view" }, ((_a = this.getTabs()) === null || _a === void 0 ? void 0 : _a.length) > 1 && (h("dyte-tab-bar", Object.assign({ activeTab: this.activeTab, tabs: this.getTabs(), onTabChange: (e) => this.setActiveTab(e.detail) }, defaults))), h("div", { id: "tabs", key: "tabs" }, this.screenShareParticipants.map((participant) => {
      var _a, _b;
      return (h(Render, { element: "dyte-screenshare-view", defaults: defaults, props: {
          participant,
          key: participant.id,
          style: {
            display: ((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.type) === 'screenshare' &&
              ((_b = this.activeTab) === null || _b === void 0 ? void 0 : _b.participant.id) === participant.id
              ? 'flex'
              : 'none',
          },
        }, childProps: { participant, isScreenShare: true }, deepProps: true }));
    }), this.plugins.map((plugin) => {
      var _a, _b;
      return (h(Render, { element: "dyte-plugin-main", defaults: defaults, props: {
          plugin,
          key: plugin.id,
          style: {
            display: ((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.type) === 'plugin' && ((_b = this.activeTab) === null || _b === void 0 ? void 0 : _b.plugin.id) === plugin.id
              ? 'flex'
              : 'none',
          },
        } }));
    }))), h(Render, { element: "dyte-mixed-grid", defaults: defaults, childProps: {
        part: 'participants-grid',
        class: this.gridSize.mixed ? `grid-width-${this.gridSize.mixed}` : 'grid-width-lg',
        participants: this.participants,
        pinnedParticipants: this.pinnedParticipants,
        screenShareParticipants: this.screenShareParticipants,
        plugins: this.plugins,
        aspectRatio: this.aspectRatio,
        gap: this.gap,
        size: 'sm',
        layout: 'row',
      }, onlyChildren: true })));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "screenShareParticipants": ["screenShareParticipantsChanged"],
    "plugins": ["pluginsChanged"]
  }; }
};
DyteMixedGrid.style = dyteMixedGridCss;

var dyteMixedGrid_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_mixed_grid: DyteMixedGrid
});

const dyteMoreToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:visible}.more-menu{position:absolute;right:calc(var(--dyte-space-24, 96px) * -1);bottom:var(--dyte-space-16, 64px);z-index:50;margin-bottom:var(--dyte-space-3, 12px);box-sizing:border-box;max-height:60vh;width:var(--dyte-space-64, 256px);overflow:auto;border-radius:var(--dyte-border-radius-md, 8px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));outline:2px solid transparent;outline-offset:2px}:host([size='sm']) .more-menu{bottom:var(--dyte-space-10, 40px)}.more-menu::-webkit-scrollbar{height:var(--dyte-space-0, 0px);width:var(--dyte-space-1\\.5, 6px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.more-menu::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

const DyteMoreToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.handleKeyDown = ({ key }) => {
      if (key === 'Escape' && this.states.activeMoreMenu) {
        this.stateUpdate.emit({ activeMoreMenu: false });
        state.activeMoreMenu = !state.activeMoreMenu;
      }
    };
    this.handleOnClick = (e) => {
      if (!e.composedPath().includes(this.host) && this.states.activeMoreMenu) {
        this.stateUpdate.emit({ activeMoreMenu: false });
        state.activeMoreMenu = !state.activeMoreMenu;
      }
    };
    this.toggleMoreMenu = () => {
      this.stateUpdate.emit({ activeMoreMenu: !state.activeMoreMenu });
      state.activeMoreMenu = !state.activeMoreMenu;
    };
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    /** A11y */
    window.addEventListener('keydown', this.handleKeyDown);
    window.addEventListener('click', this.handleOnClick);
    // };
  }
  disconnectedCallback() {
    window.removeEventListener('keydown', this.handleKeyDown);
    window.removeEventListener('click', this.handleOnClick);
  }
  render() {
    const text = this.t('more');
    return (h(Host, { title: text }, this.states.activeMoreMenu && (h("div", { class: "more-menu" }, h("slot", { name: "more-elements" }))), h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: (e) => {
        e.stopPropagation();
        this.toggleMoreMenu();
      }, icon: this.iconPack.horizontal_dots, label: text, part: "controlbar-button" }), h("slot", { name: "expanded" })));
  }
  get host() { return getElement(this); }
};
DyteMoreToggle.style = dyteMoreToggleCss;

var dyteMoreToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_more_toggle: DyteMoreToggle
});

const dyteMuteAllButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteMuteAllButton = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onMuteAll = () => {
      this.stateUpdate.emit({ activeMuteAllConfirmation: true });
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    var _a;
    if (!((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.permissions.canDisableParticipantAudio)) {
      return null;
    }
    const label = this.t('mute_all');
    return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: label, part: "tooltip" }, h("dyte-controlbar-button", { part: "controlbar-button", icon: this.iconPack.speaker_off, label: label, size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, onClick: this.onMuteAll }))));
  }
};
DyteMuteAllButton.style = dyteMuteAllButtonCss;

var dyteMuteAllButton_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_mute_all_button: DyteMuteAllButton
});

const dyteMuteAllConfirmationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;-webkit-user-select:none;-moz-user-select:none;user-select:none}.leave-modal{position:relative;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));padding:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}.leave-modal .content{font-size:14px}.leave-message p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px)}.leave-meeting{display:flex;flex-direction:row;justify-content:space-between;gap:var(--dyte-space-2, 8px)}.leave-meeting dyte-button{flex:1 1 0%}.end-meeting{margin-top:var(--dyte-space-2, 8px)}.message{margin-bottom:var(--dyte-space-4, 16px)}label{display:flex;align-items:center}input[type='checkbox']{margin-right:var(--dyte-space-2, 8px);accent-color:rgb(var(--dyte-colors-brand-500, 33 96 253))}";

const DyteMuteAllConfirmation = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onClose = () => {
      this.stateUpdate.emit({ activeMuteAllConfirmation: false });
      state.activeMuteAllConfirmation = false;
    };
    this.onMuteAll = () => {
      var _a;
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.participants.disableAllAudio(this.allowUnmute);
      this.onClose();
    };
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.allowUnmute = true;
  }
  render() {
    return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, this.t('mute_all.header'))), h("p", { class: "message" }, this.t('mute_all.description')), h("div", { class: "content" }, h("div", { class: "leave-meeting" }, h("dyte-button", { variant: "secondary", title: this.t('close'), onClick: this.onClose, iconPack: this.iconPack, t: this.t }, this.t('cancel')), h("dyte-button", { variant: "danger", title: this.t('mute_all'), onClick: this.onMuteAll, iconPack: this.iconPack, t: this.t }, this.t('mute_all')))))));
  }
};
DyteMuteAllConfirmation.style = dyteMuteAllConfirmationCss;

var dyteMuteAllConfirmation_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_mute_all_confirmation: DyteMuteAllConfirmation
});

const dyteNameTagCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:inline-flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-1\\.5, 6px);font-size:14px;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}span.name{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}::slotted(dyte-audio-visualizer[slot='start']){margin-right:var(--dyte-space-1\\.5, 6px)}::slotted(dyte-audio-visualizer[slot='end']){margin-left:var(--dyte-space-1\\.5, 6px)}:host([size='sm']){font-size:12px;--tw-bg-opacity:0.6}";

const DyteNameTag = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.participant = undefined;
    this.meeting = undefined;
    this.size = undefined;
    this.maxLength = 20;
    this.isScreenShare = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.length = 13;
  }
  sizeChanged(size) {
    this.length = size === 'sm' ? 8 : 13;
  }
  formatNameTag(name, isSelf) {
    return !this.isScreenShare
      ? isSelf
        ? `${shorten(name, this.length - 3)} (${this.t('you')})`
        : shorten(name, this.length)
      : isSelf
        ? `${this.t('screen')} - ${shorten(name, this.length - 3)} (${this.t('you')})`
        : `${this.t('screen')} - ${shorten(name, this.length)}`;
  }
  render() {
    var _a, _b, _c;
    const name = formatName(((_a = this.participant) === null || _a === void 0 ? void 0 : _a.name) || '');
    const isSelf = ((_b = this.participant) === null || _b === void 0 ? void 0 : _b.id) === ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.id);
    return (h(Host, { title: name }, h("slot", { name: "start" }), h("span", { class: "name" }, this.formatNameTag(name, isSelf)), h("slot", { name: "end" })));
  }
  static get watchers() { return {
    "size": ["sizeChanged"]
  }; }
};
DyteNameTag.style = dyteNameTagCss;

var dyteNameTag_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_name_tag: DyteNameTag
});

const dyteNetworkIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block;height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}dyte-icon{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:10;height:100%;width:100%;--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}dyte-icon.good{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}dyte-icon.poor{--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}dyte-icon.poorest{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([size='md']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.bg-signal{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:0;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}";

const DyteNetworkIndicator = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onMediaScoreUpdate = ({ kind, isScreenshare, score }) => {
      if (kind === 'video' || (this.isScreenShare && isScreenshare)) {
        this.score = score;
      }
    };
    this.participant = undefined;
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isScreenShare = false;
    this.score = 10;
  }
  connectedCallback() {
    this.participantChanged(this.participant);
  }
  participantChanged(participant) {
    if (!participant)
      return;
    participant.addListener('mediaScoreUpdate', this.onMediaScoreUpdate);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.participant) === null || _a === void 0 ? void 0 : _a.removeListener('mediaScoreUpdate', this.onMediaScoreUpdate);
  }
  render() {
    if (this.meeting && this.meeting.self.userId === this.participant.userId) {
      return null;
    }
    let signal_strength = Math.round(this.score / 2);
    let signal_status = 'good';
    // make sure signal strength is within bounds [1,3]
    // do not show if it is good
    if (signal_strength > 3) {
      return null;
    }
    else if (signal_strength < 1) {
      signal_strength = 1;
    }
    switch (signal_strength) {
      case 3:
      case 2:
        signal_status = 'poor';
        break;
      case 1:
        signal_status = 'poorest';
    }
    return (h(Host, null, h("dyte-icon", { icon: this.iconPack[`signal_${signal_strength}`], class: signal_status }), h("dyte-icon", { icon: this.iconPack.signal_5, class: "bg-signal" })));
  }
  static get watchers() { return {
    "participant": ["participantChanged"]
  }; }
};
DyteNetworkIndicator.style = dyteNetworkIndicatorCss;

var dyteNetworkIndicator_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_network_indicator: DyteNetworkIndicator
});

const dyteParticipantCountCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;height:var(--dyte-space-10, 40px);-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

const DyteParticipantCount = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.disconnectMeeting = (meeting) => {
      if (meeting != null && this.countListener != null) {
        meeting.participants.joined.removeListener('participantJoined', this.countListener);
        meeting.participants.joined.removeListener('participantLeft', this.countListener);
        (meeting === null || meeting === void 0 ? void 0 : meeting.stage) &&
          this.stageUpdateListener &&
          meeting.stage.removeListener('stageStatusUpdate', this.stageUpdateListener);
        meeting.self.removeListener('roomJoined', this.countListener);
      }
    };
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.participantCount = 0;
    this.isViewer = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    this.disconnectMeeting(this.meeting);
  }
  meetingChanged(meeting, oldMeeting) {
    this.disconnectMeeting(oldMeeting);
    if (meeting != null) {
      this.countListener = () => {
        this.participantCount =
          meeting.participants.joined.size + (meeting.self.roomJoined ? 1 : 0);
      };
      this.countListener();
      this.isViewer = isLiveStreamViewer(this.meeting);
      meeting.participants.joined.addListener('participantJoined', this.countListener);
      meeting.participants.joined.addListener('participantLeft', this.countListener);
      if (meeting === null || meeting === void 0 ? void 0 : meeting.stage) {
        this.stageUpdateListener = () => {
          this.isViewer = isLiveStreamViewer(this.meeting);
        };
        meeting === null || meeting === void 0 ? void 0 : meeting.stage.addListener('stageStatusUpdate', this.stageUpdateListener);
      }
      meeting.self.addListener('roomJoined', this.countListener);
    }
  }
  render() {
    if (this.isViewer)
      return null;
    return (h(Host, { tabIndex: 0, role: "log", "aria-label": `${this.participantCount} ${this.t('participants')}` }, h("dyte-icon", { icon: this.iconPack.people, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t }), this.participantCount));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteParticipantCount.style = dyteParticipantCountCss;

var dyteParticipantCount_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participant_count: DyteParticipantCount
});

const dyteParticipantSetupCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;align-items:center;justify-content:center;aspect-ratio:16 / 9;height:var(--dyte-space-56, 224px);overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));transition-property:var(--dyte-transition-property, all);transition-duration:150ms}@media (prefers-reduced-motion){:host{--dyte-transition-property:none}}:host([size='sm'][variant='solid']) ::slotted(dyte-name-tag){left:var(--dyte-space-2, 8px);bottom:var(--dyte-space-2, 8px);height:var(--dyte-space-4, 16px)}video{display:none;position:absolute;height:100%;width:100%;border-radius:var(--dyte-border-radius-lg, 12px)}video.contain{-o-object-fit:contain;object-fit:contain}video.cover{-o-object-fit:cover;object-fit:cover}video.visible{display:block}video::-webkit-media-controls{display:none !important}:host([variant='gradient']) ::slotted(dyte-audio-visualizer){position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px)}:host([variant='gradient']) ::slotted(dyte-name-tag){bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);display:flex;width:100%;align-items:center;justify-content:center;text-align:center;background-color:transparent;background-image:linear-gradient(to top, var(--tw-gradient-stops));--tw-gradient-from:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-gradient-to:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to);--tw-gradient-to:transparent}video.mirror{transform:scaleX(-1)}@media (orientation: portrait){:host{height:var(--dyte-space-44, 176px)}}";

const DyteParticipantSetup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onVideoUpdate = (videoState) => {
      this.videoState = videoState;
    };
    this.onPinned = ({ isPinned }) => {
      this.isPinned = isPinned;
    };
    this.videoState = undefined;
    this.isPinned = false;
    this.nameTagPosition = 'bottom-left';
    this.isPreview = false;
    this.participant = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.variant = 'solid';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    // set videoState before initial render and initialize listeners
    this.participantsChanged(this.participant);
  }
  componentDidLoad() {
    // load videoState into video element after first render
    this.videoStateChanged(this.videoState);
  }
  disconnectedCallback() {
    if (this.participant == null)
      return;
    this.participant.removeListener('videoUpdate', this.onVideoUpdate);
    this.participant.removeListener('pinned', this.onPinned);
    this.participant.removeListener('unpinned', this.onPinned);
  }
  async participantsChanged(participant) {
    if (participant != null) {
      this.videoState = {
        videoEnabled: participant.videoEnabled,
        videoTrack: participant.videoTrack,
      };
      this.isPinned = participant.isPinned;
      participant.addListener('videoUpdate', this.onVideoUpdate);
      participant.addListener('pinned', this.onPinned);
      participant.addListener('unpinned', this.onPinned);
    }
  }
  videoStateChanged(videoState) {
    if (videoState != null && this.videoEl != null) {
      if (videoState.videoEnabled) {
        const stream = new MediaStream();
        stream.addTrack(videoState.videoTrack);
        this.videoEl.srcObject = stream;
      }
      else {
        this.videoEl.srcObject = undefined;
      }
    }
  }
  isMirrored() {
    var _a;
    if (this.participant != null) {
      const isSelf = 'preview' in this.participant || this.isPreview;
      if (isSelf) {
        const states = this.states || state;
        const mirrorVideo = (_a = states === null || states === void 0 ? void 0 : states.prefs) === null || _a === void 0 ? void 0 : _a.mirrorVideo;
        if (typeof mirrorVideo === 'boolean') {
          return mirrorVideo;
        }
      }
    }
    return false;
  }
  render() {
    var _a, _b, _c, _d;
    return (h(Host, null, h("video", { ref: (el) => (this.videoEl = el), class: {
        visible: (_a = this.videoState) === null || _a === void 0 ? void 0 : _a.videoEnabled,
        mirror: this.isMirrored(),
        [(_d = (_c = (_b = this.config) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.videoFit) !== null && _d !== void 0 ? _d : 'cover']: true,
      }, autoPlay: true, playsInline: true, muted: true }), this.isPinned && (h("dyte-icon", { class: "pinned-icon", icon: this.iconPack.pin, "aria-label": this.t('pinned'), iconPack: this.iconPack, t: this.t })), h("slot", null)));
  }
  static get watchers() { return {
    "participant": ["participantsChanged"],
    "videoState": ["videoStateChanged"]
  }; }
};
DyteParticipantSetup.style = dyteParticipantSetupCss;

var dyteParticipantSetup_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participant_setup: DyteParticipantSetup
});

const logger = console;

/**
 * Handles audio from participants in a meeting
 */
class DyteAudio {
  constructor() {
    this.audio = document.createElement('audio');
    this.audio.autoplay = true;
    this.audioStream = new MediaStream();
    this.audio.srcObject = this.audioStream;
    this.audioTracks = [];
  }
  addTrack(id, track) {
    if (!this.audioTracks.some((a) => a.id === id)) {
      this.audioTracks.push({ id, track });
      this.audioStream.addTrack(track);
      this.play();
    }
  }
  removeTrack(id) {
    const track = this.audioTracks.find((a) => a.id === id);
    if (track != null) {
      this.audioStream.removeTrack(track.track);
      this.audioTracks = this.audioTracks.filter((a) => a.id !== id);
    }
  }
  async play() {
    var _a;
    this.audio.srcObject = this.audioStream;
    await ((_a = this.audio.play()) === null || _a === void 0 ? void 0 : _a.catch((err) => {
      if (err.name === 'NotAllowedError') {
        if (this._onError != null) {
          this._onError();
        }
      }
      else if (err.name !== 'AbortError') {
        logger.error('[dyte-audio] play() error\n', err);
      }
    }));
  }
  async setDevice(id) {
    var _a, _b, _c;
    await ((_c = (_b = (_a = this.audio).setSinkId) === null || _b === void 0 ? void 0 : _b.call(_a, id)) === null || _c === void 0 ? void 0 : _c.catch((err) => {
      logger.error('[dyte-audio] setSinkId() error\n', err);
    }));
  }
  onError(onError) {
    this._onError = onError;
  }
}

const dyteParticipantsAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.modal{box-sizing:border-box;width:100%;max-width:var(--dyte-space-96, 384px);padding:var(--dyte-space-4, 16px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.modal h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:24px;font-weight:500}.modal p{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-6, 24px)}.modal dyte-button{width:100%}";

const DyteParticipantsAudio = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dialogClose = createEvent(this, "dialogClose", 7);
    this.onDyteDialogClose = () => {
      this.showPlayDialog = false;
      this.dialogClose.emit();
    };
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showPlayDialog = false;
  }
  componentDidLoad() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    if (this.meeting == null)
      return;
    this.audioUpdateListener &&
      this.meeting.participants.joined.removeListener('audioUpdate', this.audioUpdateListener);
    this.screenShareUpdateListener &&
      this.meeting.participants.joined.removeListener('screenShareUpdate', this.screenShareUpdateListener);
    this.participantLeftListener &&
      this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
    this.deviceUpdateListener &&
      this.meeting.self.removeListener('deviceUpdate', this.deviceUpdateListener);
    this.stageStatusUpdateListener &&
      ((_a = this.meeting.stage) === null || _a === void 0 ? void 0 : _a.removeListener('stageStatusUpdate', this.stageStatusUpdateListener));
  }
  setupAudio() {
    this.audio = new DyteAudio();
  }
  async handleAutoPlayError() {
    if (!this.audio) {
      this.setupAudio();
    }
    this.audio.onError(() => {
      this.showPlayDialog = true;
    });
    this.audio.play();
    return;
  }
  async handleEvents(meeting) {
    const currentDevices = meeting.self.getCurrentDevices();
    if (currentDevices.speaker != null) {
      await this.audio.setDevice(currentDevices.speaker.deviceId);
    }
    this.audioUpdateListener = ({ id, audioEnabled, audioTrack }) => {
      const audioId = `audio-${id}`;
      if (audioEnabled && audioTrack != null) {
        this.audio.addTrack(audioId, audioTrack);
      }
      else {
        this.audio.removeTrack(audioId);
      }
    };
    const participants = meeting.participants.joined.toArray();
    for (const participant of participants) {
      this.audioUpdateListener(participant);
    }
    this.participantLeftListener = ({ id }) => {
      this.audio.removeTrack(`audio-${id}`);
      this.audio.removeTrack(`screenshare-${id}`);
    };
    this.screenShareUpdateListener = ({ id, screenShareEnabled, screenShareTracks }) => {
      const audioId = `screenshare-${id}`;
      if (screenShareEnabled && screenShareTracks.audio != null) {
        this.audio.addTrack(audioId, screenShareTracks.audio);
      }
      else {
        this.audio.removeTrack(audioId);
      }
    };
    this.deviceUpdateListener = ({ device, preview }) => {
      if (preview)
        return;
      if (device.kind === 'audiooutput') {
        this.audio.setDevice(device.deviceId);
      }
    };
    meeting.participants.joined.addListener('audioUpdate', this.audioUpdateListener);
    meeting.participants.joined.addListener('screenShareUpdate', this.screenShareUpdateListener);
    meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
    meeting.self.addListener('deviceUpdate', this.deviceUpdateListener);
  }
  async meetingChanged(meeting) {
    var _a;
    if (meeting != null) {
      this.setupAudio();
      if (meeting.meta.viewType === 'LIVESTREAM' && meeting.stage.status !== 'ON_STAGE') {
        this.stageStatusUpdateListener = async (status) => {
          if (status === 'ON_STAGE') {
            // NOTE(@madhugb): When someone joins stage handle autoplay and also handle events
            await this.handleAutoPlayError();
            await this.handleEvents(this.meeting);
          }
        };
        (_a = meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageStatusUpdate', this.stageStatusUpdateListener);
        if (meeting.self.permissions.canProduceAudio === 'ALLOWED' ||
          meeting.self.permissions.canProduceVideo === 'ALLOWED' ||
          meeting.self.permissions.canProduceScreenshare === 'ALLOWED') {
          await this.handleAutoPlayError();
        }
      }
      else {
        await this.handleAutoPlayError();
      }
    }
    await this.handleEvents(meeting);
  }
  render() {
    return (h(Host, null, this.showPlayDialog && (h("dyte-dialog", { open: true, onDyteDialogClose: this.onDyteDialogClose, hideCloseButton: true, iconPack: this.iconPack, t: this.t }, h("div", { class: "modal" }, h("h3", null, this.t('audio_playback.title')), h("p", null, this.t('audio_playback.description')), h("dyte-button", { kind: "wide", onClick: () => {
        this.audio.play();
        this.onDyteDialogClose();
      }, title: this.t('audio_playback'), iconPack: this.iconPack, t: this.t }, this.t('audio_playback')))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteParticipantsAudio.style = dyteParticipantsAudioCss;

var dyteParticipantsAudio_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_audio: DyteParticipantsAudio
});

const dyteParticipantsStageListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:100%;flex-direction:column;font-size:14px}.participants-container{margin-bottom:var(--dyte-space-4, 16px);width:100%}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.empty-message{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}dyte-participant{width:100%}";

const DyteParticipants$1 = class DyteParticipants {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.updateParticipants = () => {
      this.getParticipants(this.search);
    };
    this.shouldShowStageList = () => {
      var _a, _b, _c;
      if (((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta.viewType) === 'LIVESTREAM') {
        this.showStageList = ((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.stage) === null || _c === void 0 ? void 0 : _c.status) === 'ON_STAGE';
      }
      else
        this.showStageList = true;
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.view = 'sidebar';
    this.t = useLanguage();
    this.search = '';
    this.participants = [];
    this.showStageList = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.searchChanged(this.search);
  }
  disconnectedCallback() {
    var _a, _b;
    const { participants, self } = this.meeting;
    if (this.meeting == null)
      return;
    this.participantJoinedListener &&
      this.meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
    this.participantLeftListener &&
      this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
    participants.joined.removeListener('peerStartedPresenting', this.updateParticipants);
    participants.joined.removeListener('peerStoppedPresenting', this.updateParticipants);
    self.removeListener('stageJoined', this.updateParticipants);
    self.removeListener('stageLeft', this.updateParticipants);
    self.removeListener('removedFromStage', this.updateParticipants);
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', this.shouldShowStageList);
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting == null)
      return;
    this.participantJoinedListener = (participant) => {
      if (this.meeting.meta.viewType === 'WEBINAR' && participant.webinarStageStatus !== 'ON_STAGE')
        return;
      // Do not append if participant name or id does not match search query
      const lowerCaseSearch = this.search.toLowerCase();
      if (!participant.name.toLowerCase().includes(lowerCaseSearch) ||
        !participant.id.toLowerCase().includes(lowerCaseSearch))
        return;
      this.participants = [
        ...this.participants.filter((p) => p.id !== participant.id),
        participant,
      ];
    };
    this.participantLeftListener = (participant) => {
      this.participants = this.participants.filter((p) => p.id !== participant.id);
    };
    meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
    meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
    meeting.participants.joined.addListener('peerStartedPresenting', this.updateParticipants);
    meeting.participants.joined.addListener('peerStoppedPresenting', this.updateParticipants);
    meeting.self.addListener('stageJoined', this.updateParticipants);
    meeting.self.addListener('stageLeft', this.updateParticipants);
    meeting.self.addListener('removedFromStage', this.updateParticipants);
    this.shouldShowStageList();
    (_a = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageStatusUpdate', this.shouldShowStageList);
  }
  searchChanged(search) {
    this.getParticipants(search);
  }
  getParticipants(search) {
    let list = [this.meeting.self, ...this.meeting.participants.joined.toArray()];
    if (this.meeting.meta.viewType === 'WEBINAR') {
      list = list.filter((p) => p.webinarStageStatus === 'ON_STAGE');
    }
    if (search === '')
      this.participants = list;
    else {
      this.participants = list.filter((p) => { var _a; return ((_a = p.name) !== null && _a !== void 0 ? _a : p.id).toLowerCase().includes(search.toLowerCase()); });
    }
  }
  render() {
    if (!this.showStageList)
      return;
    return (h(Host, null, h("div", { class: "participants-container" }, h("div", { class: "heading-count", part: "heading-count" }, this.t('participants'), " (", this.participants.length, ")"), h("ul", { class: "participants", part: "participants" }, this.participants.map((participant) => (h("dyte-participant", { role: "listitem", key: participant.id, meeting: this.meeting, participant: participant, view: this.view, t: this.t, iconPack: this.iconPack }))), this.participants.length === 0 && (h("div", { class: "empty-message", part: "empty-message" }, this.search.length > 0 ? this.t('search.could_not_find') : this.t('search.empty')))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "search": ["searchChanged"]
  }; }
};
DyteParticipants$1.style = dyteParticipantsStageListCss;

var dyteParticipantsStageList_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_stage_list: DyteParticipants$1
});

const dyteParticipantsStageQueueCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-top:var(--dyte-space-2, 8px);display:flex;width:100%;flex-direction:column;font-size:14px}.stage-requested-participants{margin-bottom:var(--dyte-space-8, 32px)}.stage-requested-participants .bulk-actions{display:flex;gap:var(--dyte-space-2, 8px)}.stage-requested-participants .bulk-actions .accept-all-button{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.stage-requested-participants .bulk-actions dyte-button{flex:1 1 0%}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.waiting-participant{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;align-items:center}.waiting-participant .participant-details{margin-right:auto;display:flex;align-items:center}.waiting-participant .participant-details dyte-avatar{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);flex-shrink:0;font-size:14px}.waiting-participant .participant-details .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}@media (min-width: 1080px){.waiting-participant .participant-details .name{max-width:var(--dyte-space-40, 160px)}}.waiting-participant .waitlist-controls{display:flex}.waiting-participant .waitlist-controls dyte-button{margin-left:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}.waiting-participant .waitlist-controls dyte-icon.accept{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.waiting-participant .waitlist-controls dyte-icon.deny{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DyteParticipantsStaged = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.peerPresentingUpdateListener = () => {
      this.stageRequestedParticipants = [
        this.meeting.self,
        ...this.meeting.participants.joined.toArray(),
      ].filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE');
    };
    this.updateStageRequestedParticipants = () => {
      this.stageRequestedParticipants = this.meeting.participants.joined
        .toArray()
        .filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE');
    };
    this.acceptStageRequest = async (p) => {
      if (this.meeting.meta.viewType === 'WEBINAR') {
        const { id } = p;
        const participant = this.meeting.participants.joined.get(id);
        if (participant !== undefined)
          await participant.acceptJoinStageRequest();
        this.updateStageRequestedParticipants();
      }
      else if (this.meeting.meta.viewType === 'LIVESTREAM') {
        const { userId } = p;
        await this.meeting.stage.grantAccess([userId]);
      }
    };
    this.rejectStageRequest = async (p) => {
      if (this.meeting.meta.viewType === 'WEBINAR') {
        const { id } = p;
        const participant = this.meeting.participants.joined.get(id);
        if (participant !== undefined)
          await participant.rejectRequestToJoinStage();
        this.updateStageRequestedParticipants();
      }
      else if (this.meeting.meta.viewType === 'LIVESTREAM') {
        const { userId } = p;
        await this.meeting.stage.denyAccess([userId]);
      }
    };
    this.acceptAllStageRequest = async () => {
      if (this.meeting.meta.viewType === 'WEBINAR') {
        const payload = this.meeting.participants.joined
          .toArray()
          .filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE')
          .map((p) => ({
          id: p.id,
          requestToJoinType: 'REQUEST_TO_PRESENT',
        }));
        await this.meeting.participants.acceptAllRequestToJoinStageRequests(payload);
        this.updateStageRequestedParticipants();
      }
      else if (this.meeting.meta.viewType === 'LIVESTREAM') {
        await this.meeting.stage.grantAccess(this.stageRequestedParticipants.map((p) => p.userId));
      }
    };
    this.denyAllStageRequest = async () => {
      var _a;
      if (this.meeting.meta.viewType === 'WEBINAR') {
        const participants = this.meeting.participants.joined
          .toArray()
          .filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE');
        // TODO (@madhugb): move this to single call once backend supports it
        await Promise.all(participants.map(async (p) => await p.rejectRequestToJoinStage()));
        this.updateStageRequestedParticipants();
      }
      else if (this.meeting.meta.viewType === 'LIVESTREAM') {
        await ((_a = this.meeting.stage) === null || _a === void 0 ? void 0 : _a.denyAccess(this.stageRequestedParticipants.map((p) => p.userId)));
      }
    };
    this.shouldShowStageRequests = () => {
      return (this.meeting.self.permissions.acceptPresentRequests &&
        this.stageRequestedParticipants.length > 0);
    };
    this.updateRequestList = async (stageRequests) => {
      var _a, _b, _c, _d;
      if (this.meeting.meta.viewType === 'WEBINAR') {
        this.stageRequestedParticipants = (_a = [
          this.meeting.self,
          ...this.meeting.participants.joined.toArray(),
        ]) === null || _a === void 0 ? void 0 : _a.filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE');
      }
      else if (this.meeting.meta.viewType === 'LIVESTREAM' &&
        this.meeting.self.permissions.acceptPresentRequests) {
        if (!stageRequests) {
          stageRequests = (_d = (_c = (await ((_b = this.meeting.stage) === null || _b === void 0 ? void 0 : _b.getAccessRequests()))) === null || _c === void 0 ? void 0 : _c.stageRequests) !== null && _d !== void 0 ? _d : [];
        }
        /**
         * NOTE(ishita1805): Temporarily mapping `displayName` to `name` till socket service sends the correct key.
         */
        this.stageRequestedParticipants = stageRequests.map((p) => {
          return Object.assign(Object.assign({}, p), { name: p.displayName });
        });
      }
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.view = 'sidebar';
    this.t = useLanguage();
    this.stageRequestedParticipants = [];
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    const { participants, self } = this.meeting;
    this.participantLeftListener &&
      participants.joined.removeListener('participantLeft', this.participantLeftListener);
    this.peerRequestToJoinStageListener &&
      participants.joined.removeListener('peerRequestToJoinStage', this.peerRequestToJoinStageListener);
    this.peerAcceptedToJoinStageListener &&
      participants.joined.removeListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
    this.peerRejectedToJoinStageListener &&
      participants.joined.removeListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
    participants.joined.removeListener('peerStartedPresenting', this.peerPresentingUpdateListener);
    participants.joined.removeListener('peerStoppedPresenting', this.peerPresentingUpdateListener);
    self.removeListener('stageJoined', this.peerPresentingUpdateListener);
    self.removeListener('stageLeft', this.peerPresentingUpdateListener);
    self.removeListener('removedFromStage', this.peerPresentingUpdateListener);
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting == null)
      return;
    this.participantLeftListener = (participant) => {
      this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id !== participant.id);
    };
    this.peerRequestToJoinStageListener = ({ id }) => {
      this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
      const participant = meeting.participants.joined.get(id);
      if (participant !== undefined)
        this.stageRequestedParticipants = [...this.stageRequestedParticipants, participant];
    };
    this.peerAcceptedToJoinStageListener = ({ id }) => {
      this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
    };
    this.peerRejectedToJoinStageListener = ({ id }) => {
      this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
    };
    this.updateRequestList();
    meeting.participants.joined.addListener('peerRequestToJoinStage', this.peerRequestToJoinStageListener);
    meeting.participants.joined.addListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
    meeting.participants.joined.addListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
    meeting.participants.joined.addListener('peerStartedPresenting', this.peerPresentingUpdateListener);
    meeting.participants.joined.addListener('peerStoppedPresenting', this.peerPresentingUpdateListener);
    (_a = meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageAccessRequestUpdate', this.updateRequestList);
    meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
    meeting.self.addListener('stageJoined', this.peerPresentingUpdateListener);
    meeting.self.addListener('stageLeft', this.peerPresentingUpdateListener);
    meeting.self.addListener('removedFromStage', this.peerPresentingUpdateListener);
  }
  render() {
    if (this.view !== 'sidebar' || !this.shouldShowStageRequests())
      return;
    return (h("div", { class: "stage-requested-participants" }, h("div", { class: "heading-count", part: "staged-heading-count" }, this.t('stage_request.header_title'), " (", this.stageRequestedParticipants.length, ")"), h("ul", { class: "participants", part: "staged-participants" }, this.stageRequestedParticipants.map((participant) => (h("li", { class: "waiting-participant", key: participant.id }, h("div", { class: "participant-details" }, h("dyte-avatar", { participant: participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: participant.name }, participant.name)), h("div", { class: "waitlist-controls" }, h("dyte-tooltip", { label: this.t('stage_request.deny_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", onClick: () => this.rejectStageRequest(participant), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { class: "deny", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("dyte-tooltip", { label: this.t('stage_request.accept_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.acceptStageRequest(participant) }, h("dyte-icon", { class: "accept", icon: this.iconPack.checkmark })))))))), h("div", { class: "bulk-actions" }, h("dyte-button", { class: "accept-all-button", variant: "secondary", iconPack: this.iconPack, t: this.t, onClick: this.acceptAllStageRequest }, this.t('stage_request.accept_all')), h("dyte-button", { class: "deny-all-button", variant: "danger", iconPack: this.iconPack, t: this.t, onClick: this.denyAllStageRequest }, this.t('stage_request.deny_all')))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteParticipantsStaged.style = dyteParticipantsStageQueueCss;

var dyteParticipantsStageQueue_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_stage_queue: DyteParticipantsStaged
});

const dyteParticipantsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.waiting-participants-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .waiting-participants-count{right:var(--dyte-space-4, 16px);top:auto}";

const DyteParticipantsToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.updateStageRequests = async (stageRequests) => {
      var _a, _b, _c;
      if (!stageRequests) {
        stageRequests = (_c = (_b = (await ((_a = this.meeting.stage) === null || _a === void 0 ? void 0 : _a.getAccessRequests()))) === null || _b === void 0 ? void 0 : _b.stageRequests) !== null && _c !== void 0 ? _c : [];
      }
      this.stageRequestedParticipants = stageRequests;
    };
    this.updateCanView = () => {
      this.canViewParticipants = canViewParticipants(this.meeting);
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.participantsActive = false;
    this.waitlistedParticipants = [];
    this.stageRequestedParticipants = [];
    this.canViewParticipants = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.statesChanged(this.states);
    onChange('sidebar', () => this.statesChanged());
  }
  disconnectedCallback() {
    var _a, _b, _c;
    if (this.meeting == null)
      return;
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', this.updateCanView);
    this.waitlistedParticipantJoinedListener &&
      this.meeting.participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
    this.waitlistedParticipantLeftListener &&
      this.meeting.participants.waitlisted.removeListener('participantLeft', this.waitlistedParticipantLeftListener);
    this.peerRequestToJoinStateListener &&
      this.meeting.participants.joined.removeListener('peerRequestToJoinStage', this.peerRequestToJoinStateListener);
    this.peerAcceptedToJoinStageListener &&
      this.meeting.participants.joined.removeListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
    this.peerRejectedToJoinStageListener &&
      this.meeting.participants.joined.removeListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
    this.peerRejectedToJoinStageListener &&
      this.meeting.participants.joined.addListener('peerStoppedPresenting', this.peerRejectedToJoinStageListener);
    (_c = this.meeting.stage) === null || _c === void 0 ? void 0 : _c.removeListener('stageAccessRequestUpdate', this.updateStageRequests);
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting == null)
      return;
    this.canViewParticipants = canViewParticipants(meeting);
    (_a = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageStatusUpdate', this.updateCanView);
    if (meeting.self.permissions.acceptWaitingRequests) {
      this.waitlistedParticipants = meeting.participants.waitlisted.toArray();
      this.waitlistedParticipantJoinedListener = (participant) => {
        if (!this.waitlistedParticipants.some((p) => p.id === participant.id)) {
          this.waitlistedParticipants = [...this.waitlistedParticipants, participant];
        }
      };
      this.waitlistedParticipantLeftListener = (participant) => {
        this.waitlistedParticipants = this.waitlistedParticipants.filter((p) => p.id !== participant.id);
      };
      meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
      meeting.participants.waitlisted.addListener('participantLeft', this.waitlistedParticipantLeftListener);
    }
    if (this.meeting.self.permissions.acceptPresentRequests) {
      if (this.meeting.meta.viewType === 'WEBINAR') {
        this.peerRequestToJoinStateListener = ({ id }) => {
          // Dedupe
          this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
          const participant = meeting.participants.joined.get(id);
          if (participant !== undefined)
            this.stageRequestedParticipants.push(participant);
        };
        this.peerAcceptedToJoinStageListener = ({ id }) => {
          this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
        };
        this.peerRejectedToJoinStageListener = ({ id }) => {
          this.stageRequestedParticipants = this.stageRequestedParticipants.filter((p) => p.id != id);
        };
        this.stageRequestedParticipants = this.meeting.participants.joined
          .toArray()
          .filter((p) => p.webinarStageStatus === 'REQUESTED_TO_JOIN_STAGE');
        meeting.participants.joined.addListener('peerRequestToJoinStage', this.peerRequestToJoinStateListener);
        meeting.participants.joined.addListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
        meeting.participants.joined.addListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
        meeting.participants.joined.addListener('peerStoppedPresenting', this.peerRejectedToJoinStageListener);
      }
      if (this.meeting.meta.viewType === 'LIVESTREAM') {
        this.updateStageRequests();
        meeting === null || meeting === void 0 ? void 0 : meeting.stage.on('stageAccessRequestUpdate', this.updateStageRequests);
      }
    }
  }
  statesChanged(s) {
    const states = s || state;
    if (states != null) {
      this.participantsActive = states.activeSidebar === true && states.sidebar === 'participants';
    }
  }
  toggleParticipantsTab() {
    const states = this.states || state;
    this.participantsActive = !((states === null || states === void 0 ? void 0 : states.activeSidebar) && (states === null || states === void 0 ? void 0 : states.sidebar) === 'participants');
    state.activeSidebar = this.participantsActive;
    state.sidebar = this.participantsActive ? 'participants' : undefined;
    this.stateUpdate.emit({
      activeSidebar: this.participantsActive,
      sidebar: this.participantsActive ? 'participants' : undefined,
      activeMoreMenu: false,
      activeAI: false,
    });
    state.activeMoreMenu = false;
  }
  render() {
    if (!this.canViewParticipants)
      return;
    const text = this.t('participants');
    const badgeCount = this.waitlistedParticipants.length + this.stageRequestedParticipants.length;
    return (h(Host, { title: text }, badgeCount !== 0 && !this.participantsActive && (h("div", { class: "waiting-participants-count", part: "waiting-participants-count" }, h("span", null, badgeCount <= 100 ? badgeCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.participantsActive }, onClick: () => this.toggleParticipantsTab(), icon: this.iconPack.participants, label: text, variant: this.variant })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "states": ["statesChanged"]
  }; }
};
DyteParticipantsToggle.style = dyteParticipantsToggleCss;

var dyteParticipantsToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_toggle: DyteParticipantsToggle
});

const dyteParticipantsViewerListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:100%;flex-direction:column;font-size:14px}.list{margin-bottom:var(--dyte-space-4, 16px);display:flex;flex-direction:column}h3,.heading-count{margin:var(--dyte-space-0, 0px);align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.empty-message{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}";

const DyteParticipantsViewers = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.updateStageViewers = () => {
      this.getViewers(this.search);
    };
    this.shouldShowViewers = () => {
      return this.meeting.meta.viewType === 'WEBINAR';
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.view = 'sidebar';
    this.search = '';
    this.t = useLanguage();
    this.stageViewers = [];
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.searchChanged(this.search);
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
    this.participantJoinedListener = (participant) => {
      if (participant.webinarStageStatus === 'ON_STAGE')
        return;
      // Do not append if participant name or id does not match search query
      const lowerCaseSearch = this.search.toLowerCase();
      if (!participant.name.toLowerCase().includes(lowerCaseSearch) ||
        !participant.id.toLowerCase().includes(lowerCaseSearch))
        return;
      this.stageViewers = [
        ...this.stageViewers.filter((p) => p.id !== participant.id),
        participant,
      ];
    };
    this.participantLeftListener = (participant) => {
      this.stageViewers = this.stageViewers.filter((p) => p.id !== participant.id);
    };
    meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
    meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
    meeting.participants.joined.addListener('peerStartedPresenting', this.updateStageViewers);
    meeting.participants.joined.addListener('peerStoppedPresenting', this.updateStageViewers);
    meeting.self.addListener('stageJoined', this.updateStageViewers);
    meeting.self.addListener('stageLeft', this.updateStageViewers);
    meeting.self.addListener('removedFromStage', this.updateStageViewers);
  }
  searchChanged(search) {
    this.getViewers(search);
  }
  disconnectedCallback() {
    const { participants, self } = this.meeting;
    this.participantJoinedListener &&
      this.meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
    this.participantLeftListener &&
      this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
    participants.joined.removeListener('peerStartedPresenting', this.updateStageViewers);
    participants.joined.removeListener('peerStoppedPresenting', this.updateStageViewers);
    self.removeListener('stageJoined', this.updateStageViewers);
    self.removeListener('stageLeft', this.updateStageViewers);
    self.removeListener('removedFromStage', this.updateStageViewers);
  }
  getViewers(search) {
    let list = [this.meeting.self, ...this.meeting.participants.joined.toArray()].filter((p) => p.webinarStageStatus !== 'ON_STAGE');
    if (search === '')
      this.stageViewers = list;
    else {
      this.stageViewers = list.filter((p) => { var _a; return ((_a = p.name) !== null && _a !== void 0 ? _a : p.id).toLowerCase().includes(search.toLowerCase()); });
    }
  }
  render() {
    if (this.view !== 'sidebar' || !this.shouldShowViewers())
      return;
    return (h("div", { class: "list" }, h("div", { class: "heading-count", part: "heading-count" }, this.t('viewers'), " (", this.stageViewers.length, ")"), h("ul", { class: "participants", part: "participants" }, this.stageViewers.map((participant) => {
      if (participant.webinarStageStatus === 'ON_STAGE')
        return;
      return (h("dyte-participant", { role: "listitem", key: participant.id, meeting: this.meeting, participant: participant, view: this.view, iconPack: this.iconPack, t: this.t }));
    }), this.stageViewers.length === 0 && (h("div", { class: "empty-message", part: "empty-message" }, this.search.length > 0
      ? this.t('participants.errors.empty_results')
      : this.t('participants.empty_list'))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "search": ["searchChanged"]
  }; }
};
DyteParticipantsViewers.style = dyteParticipantsViewerListCss;

var dyteParticipantsViewerList_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_viewer_list: DyteParticipantsViewers
});

const dyteParticipantsWaitingListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-top:var(--dyte-space-4, 16px);margin-bottom:calc(var(--dyte-space-2, 8px) * -1);display:flex;width:100%;flex-direction:column;font-size:14px}.waiting-participants{margin-bottom:var(--dyte-space-8, 32px)}.waiting-participants .accept-all-button{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.waiting-participant{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;align-items:center}.waiting-participant .participant-details{margin-right:auto;display:flex;align-items:center}.waiting-participant .participant-details dyte-avatar{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);flex-shrink:0;font-size:14px}.waiting-participant .participant-details .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media (min-width: 1080px){.waiting-participant .participant-details .name{max-width:var(--dyte-space-40, 160px)}}.waiting-participant .waitlist-controls{display:flex}.waiting-participant .waitlist-controls dyte-button{margin-left:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}.waiting-participant .waitlist-controls dyte-icon.accept{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.waiting-participant .waitlist-controls dyte-icon.deny{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DyteParticipantsWaitlisted = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.acceptWaitingRoomRequest = async (id) => {
      await this.meeting.participants.acceptWaitingRoomRequest(id);
    };
    this.acceptAllWaitingRoomRequests = async () => {
      const requestPromises = this.waitlistedParticipants.map((participant) => this.meeting.participants.acceptWaitingRoomRequest(participant.id));
      await Promise.all(requestPromises);
    };
    this.rejectWaitingRoomRequest = async (id) => {
      await this.meeting.participants.rejectWaitingRoomRequest(id);
    };
    this.shouldShowWaitlist = () => {
      if (this.meeting.meta.viewType === 'LIVESTREAM')
        return false;
      return (this.meeting.self.permissions.acceptWaitingRequests &&
        this.waitlistedParticipants.length !== 0);
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.view = 'sidebar';
    this.t = useLanguage();
    this.waitlistedParticipants = [];
  }
  disconnectedCallback() {
    const { participants } = this.meeting;
    this.waitlistedParticipantJoinedListener &&
      participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
    this.waitlistedParticipantLeftListener &&
      participants.waitlisted.removeListener('participantLeft', this.waitlistedParticipantLeftListener);
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
    this.waitlistedParticipants = meeting.participants.waitlisted.toArray();
    this.waitlistedParticipantJoinedListener = (participant) => {
      if (!this.waitlistedParticipants.some((p) => p.id === participant.id)) {
        this.waitlistedParticipants = [...this.waitlistedParticipants, participant];
      }
    };
    this.waitlistedParticipantLeftListener = (participant) => {
      this.waitlistedParticipants = this.waitlistedParticipants.filter((p) => p.id !== participant.id);
    };
    meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
    meeting.participants.waitlisted.addListener('participantLeft', this.waitlistedParticipantLeftListener);
  }
  render() {
    if (this.view !== 'sidebar' || !this.shouldShowWaitlist())
      return;
    return (h("div", { class: "waiting-participants" }, h("div", { class: "heading-count", part: "waitlisted-heading-count" }, this.t('waitlist.header_title'), " (", this.waitlistedParticipants.length, ")"), h("ul", { class: "participants", part: "waitlisted-participants" }, this.waitlistedParticipants.map((participant) => (h("li", { class: "waiting-participant", key: participant.id }, h("div", { class: "participant-details" }, h("dyte-avatar", { participant: participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: participant.name }, participant.name)), h("div", { class: "waitlist-controls" }, h("dyte-tooltip", { label: this.t('waitlist.deny_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.rejectWaitingRoomRequest(participant.id) }, h("dyte-icon", { class: "deny", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("dyte-tooltip", { label: this.t('waitlist.accept_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.acceptWaitingRoomRequest(participant.id) }, h("dyte-icon", { class: "accept", icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t })))))))), h("dyte-button", { class: "accept-all-button", variant: "secondary", kind: "wide", iconPack: this.iconPack, t: this.t, onClick: this.acceptAllWaitingRoomRequests }, this.t('waitlist.accept_all'))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteParticipantsWaitlisted.style = dyteParticipantsWaitingListCss;

var dyteParticipantsWaitingList_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participants_waiting_list: DyteParticipantsWaitlisted
});

const dytePermissionsMessageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:block;width:560px;padding:var(--dyte-space-6, 24px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.actions{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.text-icon{display:inline-block;vertical-align:middle}h2{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-4, 16px)}h2 .text-icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-4, 16px)}.need-help-link{display:inline-block;text-underline-offset:2px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-400, 53 110 253) / var(--tw-text-opacity))}.need-help-link:hover{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-text-opacity))}a dyte-icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) .actions{flex-direction:column;align-items:flex-start;justify-content:center}:host([size='sm']) .action{width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.actions{margin-top:var(--dyte-space-6, 24px)}.actions dyte-button{flex:1 1 0%}";

const DytePermissionsMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.continue = () => {
      this.stateUpdate.emit({
        activePermissionsMessage: { enabled: false },
      });
      state.activePermissionsMessage = { enabled: false };
    };
    this.reload = () => {
      if (typeof window !== 'undefined') {
        window.location.reload();
      }
    };
    this.meeting = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.states = undefined;
    this.device = undefined;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.device = meeting.self.device;
    }
  }
  getLink(media) {
    let kind;
    switch (media) {
      case 'audio':
        kind = 'microphone';
        break;
      case 'video':
        kind = 'camera';
        break;
      default:
        kind = 'screenshare';
        break;
    }
    const GOOGLE_SEARCH_BASE = 'https://www.google.com/search?q=';
    let query = `Allow+${kind}+access`;
    if (this.device != null) {
      const { browserName, isMobile } = this.device;
      query += '+' + browserName;
      if (isMobile) {
        query += '+mobile';
      }
    }
    return GOOGLE_SEARCH_BASE + query;
  }
  isDeniedBySystem() {
    var _a;
    const permissionsMessage = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.mediaPermissions;
    if (permissionsMessage == null)
      return false;
    if (Object.values(permissionsMessage).includes('SYSTEM_DENIED')) {
      return true;
    }
    return false;
  }
  getTitle() {
    var _a, _b, _c;
    const isDeniedBySystem = this.isDeniedBySystem();
    const media = (_c = (_b = (_a = this.states) === null || _a === void 0 ? void 0 : _a.activePermissionsMessage) === null || _b === void 0 ? void 0 : _b.kind) !== null && _c !== void 0 ? _c : 'audio';
    if (isDeniedBySystem) {
      return this.t(`perm_sys_denied.${media}`);
    }
    return this.t(`perm_denied.${media}`);
  }
  getMessage() {
    var _a, _b, _c, _d;
    const { browserName, osName } = this.meeting.self.device;
    const isDeniedBySystem = this.isDeniedBySystem();
    const browser = (_a = browserName.toLowerCase()) !== null && _a !== void 0 ? _a : 'others';
    const os = osName !== null && osName !== void 0 ? osName : 'others';
    const media = (_d = (_c = (_b = this.states) === null || _b === void 0 ? void 0 : _b.activePermissionsMessage) === null || _c === void 0 ? void 0 : _c.kind) !== null && _d !== void 0 ? _d : 'audio';
    if (isDeniedBySystem) {
      return this.t(`perm_sys_denied.${media}.${os}.message`);
    }
    return this.t(`perm_denied.${media}.${browser}.message`);
  }
  render() {
    var _a, _b, _c;
    const isDeniedBySystem = this.isDeniedBySystem();
    return (h(Host, null, h("h2", null, h("dyte-icon", { class: "text-icon", icon: this.iconPack.warning, iconPack: this.iconPack, t: this.t }), this.getTitle()), h("p", null, this.getMessage()), !isDeniedBySystem && (h("a", { class: "need-help-link", href: this.getLink((_c = (_b = (_a = this.states) === null || _a === void 0 ? void 0 : _a.activePermissionsMessage) === null || _b === void 0 ? void 0 : _b.kind) !== null && _c !== void 0 ? _c : 'audio'), target: "_blank", rel: "noreferrer external noreferrer noopener" }, h("dyte-icon", { class: "text-icon", icon: this.iconPack.attach, iconPack: this.iconPack, t: this.t }), this.t('cta.help'))), h("div", { class: "actions" }, h("dyte-button", { size: "lg", kind: "wide", variant: "secondary", onClick: this.continue, iconPack: this.iconPack, t: this.t }, this.t('cta.continue')), h("dyte-button", { size: "lg", kind: "wide", onClick: this.reload, iconPack: this.iconPack, t: this.t }, this.t('cta.reload'))), h("slot", null)));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DytePermissionsMessage.style = dytePermissionsMessageCss;

var dytePermissionsMessage_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_permissions_message: DytePermissionsMessage
});

const dytePipToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DytePipToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.size = undefined;
    this.t = useLanguage();
    this.pipEnabled = false;
    this.pipSupported = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() { }
  statesChanged(s) {
    const states = s || state;
    if ((states === null || states === void 0 ? void 0 : states.activePipMode) != null) {
      this.pipEnabled = states.activePipMode;
    }
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting === null)
      return;
    // Check if PiP is supported and enabled
    this.pipSupported =
      store.isSupported() &&
        ((_a = meeting.self.config) === null || _a === void 0 ? void 0 : _a.pipMode) &&
        ((_b = meeting.self.config) === null || _b === void 0 ? void 0 : _b.viewType) !== 'LIVESTREAM';
    const localState = this.states || state;
    this.pipEnabled = localState.activePipMode;
  }
  togglePip() {
    const localState = this.states || state;
    const { activePipMode } = localState;
    // Not active, activate
    if (activePipMode !== true) {
      store.updateMediaSession(PiPEvents.CAMERA, this.meeting.self.videoEnabled);
      store.updateMediaSession(PiPEvents.MIC, this.meeting.self.audioEnabled);
      store.enable();
      this.stateUpdate.emit({ activePipMode: true });
    }
    else {
      store.disable();
      this.stateUpdate.emit({ activePipMode: false });
    }
    this.stateUpdate.emit({ activeMoreMenu: false });
    state.activeMoreMenu = false;
  }
  render() {
    if (!this.pipSupported)
      return;
    return (h(Host, { tabIndex: 0, role: "log", "aria-label": `Picture-in-Picture mode` }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.togglePip(), icon: this.pipEnabled ? this.iconPack.pip_on : this.iconPack.pip_off, label: this.pipEnabled ? this.t('pip_off') : this.t('pip_on'), variant: this.variant })));
  }
  static get watchers() { return {
    "states": ["statesChanged"],
    "meeting": ["meetingChanged"]
  }; }
};
DytePipToggle.style = dytePipToggleCss;

var dytePipToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_pip_toggle: DytePipToggle
});

const dytePluginMainCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{display:flex;height:var(--dyte-space-8, 32px);align-items:center;justify-content:space-between;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}header>div{display:flex;align-items:center}dyte-button{display:flex;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);flex-direction:column;align-items:center;border-radius:9999px}dyte-button dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px)}iframe{display:block;flex:1 1 0%;margin:var(--dyte-space-0, 0px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-0, 0px);outline:2px solid transparent;outline-offset:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity))}.iframe-container{position:relative;height:100%;width:100%}.block-inputs{position:absolute;z-index:10;height:100%;width:100%;border-left-width:var(--dyte-border-width-none, 0);border-top-width:var(--dyte-border-width-lg, 4px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-border-opacity))}iframe{height:100%;width:100%}";

const DytePluginMain = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.plugin = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.canClosePlugin = false;
    this.canControl = true;
    this.viewModeEnabled = false;
  }
  componentDidLoad() {
    this.meetingChanged(this.meeting);
    this.pluginChanged(this.plugin);
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting != null) {
      const permissions = meeting.self.permissions;
      const canEditACL = permissions.isV2
        ? permissions.plugins.canEditConfig
        : permissions.plugins.canEditAcl;
      if (permissions.plugins.config !== undefined) {
        // camelcase ts normalizer in webcore also normalize uuid
        // temp hack
        Object.keys(permissions.plugins.config || {}).forEach((k) => {
          permissions.plugins.config[k.toLowerCase()] = permissions.plugins.config[k];
        });
        const whitelistedControl = (((_a = permissions.plugins.config[this.plugin.id]) === null || _a === void 0 ? void 0 : _a.defaultAccess) || 'blacklist') ===
          'whitelist';
        if (this.plugin.enabledBy === meeting.self.userId || canEditACL) {
          this.canControl = true;
        }
        else if (whitelistedControl) {
          this.canControl = false;
        }
        this.viewModeEnabled = !this.canControl;
      }
      writeTask(() => {
        this.canClosePlugin = meeting.self.permissions.plugins.canClose;
      });
    }
  }
  pluginChanged(plugin) {
    this.toggleViewModeListener = (enable) => {
      this.viewModeEnabled = enable;
    };
    if (plugin != null) {
      plugin.addPluginView(this.iframeEl);
      plugin.addListener('toggleViewMode', this.toggleViewModeListener);
    }
  }
  disconnectedCallback() {
    var _a;
    (_a = this.plugin) === null || _a === void 0 ? void 0 : _a.removeListener('toggleViewMode', this.toggleViewModeListener);
  }
  render() {
    if (this.plugin == null)
      return null;
    return (h(Host, null, h("header", { part: "header" }, h("div", null, this.plugin.name), this.canClosePlugin && (h("div", null, h("dyte-button", { kind: "icon", onClick: () => this.plugin.deactivate(), part: "button", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))), h("div", { class: 'iframe-container' }, !this.canControl && (this.viewModeEnabled ? h("div", { class: "block-inputs" }) : null), h("iframe", { ref: (el) => (this.iframeEl = el), part: "iframe" }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "plugin": ["pluginChanged"]
  }; }
};
DytePluginMain.style = dytePluginMainCss;

var dytePluginMain_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_plugin_main: DytePluginMain
});

const dytePluginsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DytePluginsToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.updateCanView = () => {
      this.canViewPlugins = canViewPlugins(this.meeting);
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.pluginsActive = false;
    this.canViewPlugins = false;
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', this.updateCanView);
  }
  connectedCallback() {
    this.statesChanged(this.states);
    this.meetingChanged(this.meeting);
    onChange('sidebar', () => this.statesChanged());
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting == null)
      return;
    this.canViewPlugins = canViewPlugins(meeting);
    (_a = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageStatusUpdate', this.updateCanView);
  }
  statesChanged(s) {
    const states = s || state;
    if (states != null) {
      this.pluginsActive = states.activeSidebar === true && states.sidebar === 'plugins';
    }
  }
  togglePlugins() {
    const states = this.states || state;
    this.pluginsActive = !((states === null || states === void 0 ? void 0 : states.activeSidebar) && (states === null || states === void 0 ? void 0 : states.sidebar) === 'plugins');
    this.stateUpdate.emit({
      activeSidebar: this.pluginsActive,
      sidebar: this.pluginsActive ? 'plugins' : undefined,
      activeMoreMenu: false,
      activeAI: false,
    });
    state.activeSidebar = this.pluginsActive;
    state.sidebar = this.pluginsActive ? 'plugins' : undefined;
    state.activeMoreMenu = false;
  }
  render() {
    if (!this.canViewPlugins)
      return;
    const text = this.t('plugins');
    return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.pluginsActive }, onClick: () => this.togglePlugins(), icon: this.iconPack.rocket, label: text, variant: this.variant })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "states": ["statesChanged"]
  }; }
};
DytePluginsToggle.style = dytePluginsToggleCss;

var dytePluginsToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_plugins_toggle: DytePluginsToggle
});

const dytePollsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .unread-count{right:var(--dyte-space-4, 16px);top:auto}";

const DytePollsToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onPollsUpdate = ({ newPoll }) => {
      if (newPoll === true)
        this.unreadPollsCount += 1;
    };
    this.updateCanView = () => {
      this.canViewPolls = canViewPolls(this.meeting);
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.pollsActive = false;
    this.unreadPollsCount = 0;
    this.canViewPolls = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.statesChanged(this.states);
    onChange('sidebar', () => this.statesChanged());
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.meeting.polls) === null || _a === void 0 ? void 0 : _a.removeListener('pollsUpdate', this.onPollsUpdate);
    (_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.stage) === null || _c === void 0 ? void 0 : _c.removeListener('stageStatusUpdate', this.updateCanView);
  }
  meetingChanged(meeting) {
    var _a;
    if (meeting && meeting.polls) {
      this.unreadPollsCount = meeting.polls.items.length;
      this.meeting.polls.addListener('pollsUpdate', this.onPollsUpdate);
      this.canViewPolls = canViewPolls(meeting);
      (_a = meeting === null || meeting === void 0 ? void 0 : meeting.stage) === null || _a === void 0 ? void 0 : _a.on('stageStatusUpdate', this.updateCanView);
    }
  }
  statesChanged(s) {
    const states = s || state;
    if (states != null) {
      this.pollsActive = states.activeSidebar === true && states.sidebar === 'polls';
    }
  }
  togglePollsTab() {
    const states = this.states || state;
    this.unreadPollsCount = 0;
    this.pollsActive = !((states === null || states === void 0 ? void 0 : states.activeSidebar) && (states === null || states === void 0 ? void 0 : states.sidebar) === 'polls');
    this.stateUpdate.emit({
      activeSidebar: this.pollsActive,
      sidebar: this.pollsActive ? 'polls' : undefined,
      activeMoreMenu: false,
      activeAI: false,
    });
    state.activeSidebar = this.pollsActive;
    state.sidebar = this.pollsActive ? 'polls' : undefined;
    state.activeMoreMenu = false;
  }
  render() {
    if (!this.canViewPolls)
      return;
    const text = this.t('polls');
    // TODO(callmetarush): Just showing polls for all V2 users irrespective of themes
    // untill we get ui theme for V2.
    return (h(Host, { title: text }, this.unreadPollsCount !== 0 && !this.pollsActive && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadPollsCount <= 100 ? this.unreadPollsCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.pollsActive }, onClick: () => this.togglePollsTab(), icon: this.iconPack.poll, label: text, variant: this.variant })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "states": ["statesChanged"]
  }; }
};
DytePollsToggle.style = dytePollsToggleCss;

var dytePollsToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_polls_toggle: DytePollsToggle
});

const dyteRecordingIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:block}:host[size='sm']{margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px)}.indicator{display:flex;flex-direction:row;align-items:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);-webkit-animation:blink 4s linear infinite;animation:blink 4s linear infinite}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([size='sm']) .indicator span{display:none}@-webkit-keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}@keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}";

const DyteRecordingIndicator = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setIsRecording = (recordingState) => {
      this.isRecording = recordingState === 'RECORDING';
    };
    this.meeting = undefined;
    this.size = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.isRecording = undefined;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.recording.removeListener('recordingUpdate', this.updateRecordingStatus);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.setIsRecording(meeting.recording.recordingState);
      this.updateRecordingStatus = (recordingState) => {
        this.setIsRecording(recordingState);
      };
      meeting.recording.addListener('recordingUpdate', this.updateRecordingStatus);
    }
  }
  render() {
    return (h(Host, null, this.isRecording && (h("div", { class: "indicator", "aria-label": this.t('recording.indicator'), part: "indicator" }, h("dyte-icon", { icon: this.iconPack.recording, "aria-hidden": true, tabIndex: -1, part: "icon", iconPack: this.iconPack, t: this.t }), h("span", null, this.t('recording.label'))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteRecordingIndicator.style = dyteRecordingIndicatorCss;

var dyteRecordingIndicator_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_recording_indicator: DyteRecordingIndicator
});

const dyteRecordingToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteRecordingToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
    this.toggleRecording = async () => {
      var _a, _b;
      if (this.isLoading() || this.disabled)
        return;
      switch (this.recordingState) {
        case 'IDLE':
          try {
            await ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.recording.start());
            return;
          }
          catch (_c) {
            this.dyteAPIError.emit({
              trace: this.t('recording.start'),
              message: this.t('recording.error.start'),
            });
          }
          return;
        case 'RECORDING':
          try {
            await ((_b = this.meeting) === null || _b === void 0 ? void 0 : _b.recording.stop());
            return;
          }
          catch (_d) {
            this.dyteAPIError.emit({
              trace: this.t('recording.stop'),
              message: this.t('recording.error.stop'),
            });
          }
          return;
        case 'STARTING':
        case 'STOPPING':
        default:
          return;
      }
    };
    this.isLoading = () => {
      return (this.meeting == null ||
        this.recordingState === 'STARTING' ||
        this.recordingState === 'STOPPING');
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.size = undefined;
    this.disabled = false;
    this.recordingState = undefined;
    this.canRecord = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    this.recordingStateUpdateListener &&
      ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.recording.removeListener('recordingUpdate', this.recordingStateUpdateListener));
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.recordingState = meeting.recording.recordingState;
      this.canRecord = meeting.self.permissions.canRecord === true;
      this.recordingStateUpdateListener = (recordingState) => {
        this.recordingState = recordingState;
      };
      meeting.recording.addListener('recordingUpdate', this.recordingStateUpdateListener);
    }
  }
  getLabel() {
    switch (this.recordingState) {
      case 'IDLE':
        return this.t('recording.idle');
      case 'RECORDING':
        return this.t('recording.stop');
      case 'STARTING':
        return this.t('recording.starting');
      case 'STOPPING':
        return this.t('recording.stopping');
      default:
        return this.t('recording.loading');
    }
  }
  getIcon() {
    switch (this.recordingState) {
      case 'IDLE':
        return this.iconPack.recording;
      case 'RECORDING':
        return this.iconPack.stop_recording;
      case 'STARTING':
      case 'STOPPING':
      default:
        return this.iconPack.recording;
    }
  }
  render() {
    if (!this.canRecord)
      return;
    return (h(Host, { title: this.t('Record') }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.toggleRecording, icon: this.getIcon(), isLoading: this.isLoading(), label: this.t(this.getLabel()), variant: this.variant, disabled: this.disabled })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteRecordingToggle.style = dyteRecordingToggleCss;

var dyteRecordingToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_recording_toggle: DyteRecordingToggle
});

const dyteRemoteAccessManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{box-sizing:border-box;display:block;width:512px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-6, 24px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);line-height:1.25}.deny-access{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3,p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}h3{margin-bottom:var(--dyte-space-4, 16px);font-size:20px;line-height:1.5}p{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}p.empty-message{text-align:center;font-size:16px}label>input{margin-right:var(--dyte-space-2, 8px)}input{background-color:transparent;accent-color:rgb(var(--dyte-colors-brand-500, 33 96 253))}#allow-requests-label{display:flex;align-items:center;font-size:12px}#actions{margin-top:var(--dyte-space-4, 16px);display:flex;align-items:center}dyte-button{flex:1 1 0%;border-radius:var(--dyte-border-radius-sm, 4px);font-size:12px}#participants-list{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);border-radius:var(--dyte-border-radius-md, 8px);max-height:var(--dyte-space-56, 224px);overflow-y:auto}.participant{box-sizing:border-box;display:flex;height:var(--dyte-space-14, 56px);align-items:center;padding-left:var(--dyte-space-1, 4px);padding-right:var(--dyte-space-1, 4px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-700, 44 44 44))}.participant:last-child{border-bottom-width:var(--dyte-border-width-none, 0)}.participant{cursor:pointer;font-size:14px}.participant input{margin-right:var(--dyte-space-3, 12px)}dyte-avatar{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px)}";

const DyteRemoteAccessManager = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.acceptedRequestId = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  disconnectedCallback() { }
  meetingChanged(meeting) {
    var _a, _b, _c, _d, _e;
    if (meeting != null) {
      if (!Boolean(this.acceptedRequestId) && Boolean((_c = (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.active) === null || _c === void 0 ? void 0 : _c.id)) {
        this.acceptedRequestId = (_e = (_d = this.meeting.remote) === null || _d === void 0 ? void 0 : _d.active) === null || _e === void 0 ? void 0 : _e.id;
      }
    }
  }
  render() {
    var _a, _b, _c, _d;
    if (!Boolean((_b = (_a = this === null || this === void 0 ? void 0 : this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.incomingRequests.toArray().length)) {
      return (h(Host, null, h("p", { class: "empty-message" }, this.t('remote_access.empty'))));
    }
    return (h(Host, null, h("h3", null, this.t('remote_access.requests')), h("p", null, this.t('remote_access.allow')), h("div", { class: "scrollbar" }, (_d = (_c = this === null || this === void 0 ? void 0 : this.meeting) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.incomingRequests.toArray().map((incomingRequest) => {
      const requestPeer = this.meeting.participants.joined.get(incomingRequest.remotePeerId);
      return (
      // should use participant id for htmlFor instead
      h("label", { onClick: () => {
          this.acceptedRequestId = incomingRequest.id;
        }, class: "participant", htmlFor: requestPeer.id }, h("input", { type: "radio", checked: this.acceptedRequestId === incomingRequest.id, name: "remote-access-participant", value: incomingRequest.id }), h("dyte-avatar", { participant: requestPeer, size: "sm" }), requestPeer.name));
    })), h("div", { id: "actions" }, h("dyte-button", { disabled: !Boolean(this.acceptedRequestId), iconPack: this.iconPack, t: this.t, onClick: () => {
        var _a, _b;
        (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.acceptControl(this.acceptedRequestId);
        this.stateUpdate.emit({ activeRemoteAccessManager: false });
      } }, this.t('remote_access.grant')))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteRemoteAccessManager.style = dyteRemoteAccessManagerCss;

var dyteRemoteAccessManager_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_remote_access_manager: DyteRemoteAccessManager
});

const dyteScreenShareToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const deviceCanScreenShare = () => {
  return (typeof navigator !== 'undefined' &&
    typeof navigator.mediaDevices !== 'undefined' &&
    'getDisplayMedia' in navigator.mediaDevices);
};
const DyteScreenShareToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
    this.selfScreenShareListener = ({ screenShareEnabled }) => {
      this.screenShareEnabled = screenShareEnabled;
      const currentCount = this.screenShareCount + (screenShareEnabled ? 1 : -1);
      this.screenShareCount = Math.max(currentCount, 0);
      this.getState();
      this.meeting.__internals__.logger.info('dyteScreenShare::screenShareUpdate', {
        media: {
          screenshare: {
            enabled: this.screenShareEnabled,
            count: this.screenShareCount,
          },
        },
      });
    };
    this.screenShareListener = ({ screenShareEnabled }) => {
      const currentCount = this.screenShareCount + (screenShareEnabled ? 1 : -1);
      this.screenShareCount = Math.max(currentCount, 0);
      this.getState();
      this.meeting.__internals__.logger.info('dyteScreenShare::screenShareUpdate', {
        media: {
          screenshare: {
            enabled: this.screenShareEnabled,
            count: this.screenShareCount,
          },
        },
      });
    };
    this.participantLeftListener = ({ screenShareEnabled }) => {
      if (screenShareEnabled) {
        // decrement count if participant who left had screenShareEnabled
        // and don't let it go below 0 (just a failsafe)
        this.screenShareCount = Math.max(this.screenShareCount - 1, 0);
        this.getState();
        this.meeting.__internals__.logger.info('dyteScreenShare::screenShareUpdate', {
          media: {
            screenshare: {
              enabled: this.screenShareEnabled,
              count: this.screenShareCount,
            },
          },
        });
      }
    };
    this.selfJoinStateListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.selfStageLeftListener = () => {
      this.canScreenShare = false;
    };
    this.selfJoinStateRejectedListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.mediaPermissionUpdateListener = ({ kind, message }) => {
      if (kind === 'screenshare') {
        this.shareScreenPermission = message;
        this.getState();
        if (message === 'COULD_NOT_START') {
          this.dyteAPIError.emit({
            trace: this.t('screenshare.permissions'),
            message: this.t('screenshare.error.unknown'),
          });
        }
        if (this.hasPermissionError()) {
          const permissionModalSettings = {
            enabled: true,
            kind: 'screenshare',
          };
          this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
          state.activePermissionsMessage = permissionModalSettings;
        }
      }
    };
    this.reachedMaxScreenShares = () => {
      // checks if a limit exists, and if limit is reached
      return this.maxScreenShareCount > 0 && this.screenShareCount >= this.maxScreenShareCount;
    };
    this.toggleScreenShare = async () => {
      var _a;
      if (this.screenShareState.disable)
        return;
      if (this.hasPermissionError()) {
        const permissionModalSettings = {
          enabled: true,
          kind: 'screenshare',
        };
        this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
        state.activePermissionsMessage = permissionModalSettings;
        return false;
      }
      const self = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self;
      if (this.screenShareEnabled) {
        self.disableScreenShare();
        return;
      }
      if (self == null ||
        !this.canScreenShare ||
        this.reachedMaxScreenShares() ||
        this.hasPermissionError())
        return;
      this.screenShareState = Object.assign(Object.assign({}, this.screenShareState), { disable: true });
      await self.enableScreenShare();
      this.screenShareState = Object.assign(Object.assign({}, this.screenShareState), { disable: false });
      this.stateUpdate.emit({ activeMoreMenu: false });
      state.activeMoreMenu = false;
    };
    this.states = undefined;
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.maxScreenShareCount = -1;
    this.screenShareCount = 0;
    this.screenShareEnabled = false;
    this.canScreenShare = false;
    this.shareScreenPermission = 'NOT_REQUESTED';
    this.screenShareState = {
      tooltipLabel: this.t('screenshare.start'),
      label: this.t('screenshare.start'),
      icon: this.iconPack.share_screen_start,
      classList: {},
      showWarning: false,
      disable: false,
    };
  }
  connectedCallback() {
    if (!deviceCanScreenShare()) {
      logger.error('[dyte-screenshare-toggle] Device does not support screensharing.');
      return;
    }
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.participants.joined.removeListener('screenShareUpdate', this.screenShareListener);
    (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.participants.joined.removeListener('participantLeft', this.participantLeftListener);
    (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('screenShareUpdate', this.selfScreenShareListener);
    (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    (_e = this.meeting) === null || _e === void 0 ? void 0 : _e.self.removeListener('joinStageRequestAccepted', this.selfJoinStateListener);
    (_f = this.meeting) === null || _f === void 0 ? void 0 : _f.self.removeListener('joinStageRequestRejected', this.selfJoinStateRejectedListener);
    (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self.removeListener('stageJoined', this.selfJoinStateListener);
    (_h = this.meeting) === null || _h === void 0 ? void 0 : _h.self.removeListener('stageLeft', this.selfStageLeftListener);
    (_j = this.meeting) === null || _j === void 0 ? void 0 : _j.self.removeListener('removedFromStage', this.selfJoinStateListener);
    (_l = (_k = this.meeting) === null || _k === void 0 ? void 0 : _k.stage) === null || _l === void 0 ? void 0 : _l.removeListener('stageStatusUpdate', this.selfJoinStateListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      const { self, stage } = meeting;
      this.updateCanProduce(meeting);
      this.maxScreenShareCount = self.config.maxScreenShareCount;
      this.screenShareEnabled = self.screenShareEnabled;
      let screenShareCount = 0;
      for (const participant of meeting.participants.joined.toArray()) {
        if (participant.screenShareEnabled) {
          screenShareCount++;
        }
      }
      this.screenShareCount = screenShareCount;
      this.getState();
      meeting.__internals__.logger.info('dyteScreenShare::initialise', {
        media: {
          screenshare: {
            enabled: this.screenShareEnabled,
            count: this.screenShareCount,
            maxAllowedCount: this.maxScreenShareCount,
          },
        },
      });
      meeting.participants.joined.addListener('screenShareUpdate', this.screenShareListener);
      meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
      self.addListener('screenShareUpdate', this.selfScreenShareListener);
      self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      self.addListener('joinStageRequestAccepted', this.selfJoinStateListener);
      self.addListener('joinStageRequestRejected', this.selfJoinStateRejectedListener);
      self.addListener('stageJoined', this.selfJoinStateListener);
      self.addListener('stageLeft', this.selfStageLeftListener);
      self.addListener('removedFromStage', this.selfJoinStateListener);
      stage === null || stage === void 0 ? void 0 : stage.addListener('stageStatusUpdate', this.selfJoinStateListener);
    }
  }
  updateCanProduce(meeting) {
    const { self, meta, stage } = meeting;
    const canProduceScreenshare = self.permissions.canProduceScreenshare === 'ALLOWED';
    const isWebinar = meta.viewType === 'WEBINAR';
    const isLiveStream = meta.viewType === 'LIVESTREAM';
    this.canScreenShare = false;
    if (canProduceScreenshare && !isLiveStream) {
      this.canScreenShare = true;
    }
    else if (isWebinar || isLiveStream) {
      if (canProduceScreenshare &&
        stage.status !== 'OFF_STAGE' &&
        stage.status !== 'REQUESTED_TO_JOIN_STAGE')
        this.canScreenShare = true;
      const canRequestScreenshare = self.permissions.canProduceScreenshare === 'CAN_REQUEST';
      // If the peer has approved request to present
      if (canRequestScreenshare &&
        ((isWebinar &&
          (self.webinarStageStatus === 'ON_STAGE' ||
            self.webinarStageStatus === 'ACCEPTED_TO_JOIN_STAGE')) ||
          (isLiveStream &&
            (stage.status === 'ON_STAGE' || stage.status === 'ACCEPTED_TO_JOIN_STAGE')))) {
        this.canScreenShare = true;
      }
    }
  }
  hasPermissionError() {
    return (this.shareScreenPermission === 'SYSTEM_DENIED' || this.shareScreenPermission === 'DENIED');
  }
  getState() {
    let tooltipLabel = '';
    let label = '';
    let icon = '';
    let classList = {};
    const hasError = this.hasPermissionError() && !this.screenShareEnabled;
    const limitReached = this.reachedMaxScreenShares() && !this.screenShareEnabled;
    const couldNotStart = this.shareScreenPermission === 'COULD_NOT_START';
    if (this.screenShareEnabled && !hasError) {
      label = this.t('screenshare.stop');
      icon = this.iconPack.share_screen_stop;
      classList['red-icon'] = true;
    }
    else {
      label = this.t('screenshare.start');
      icon = this.iconPack.share_screen_start;
    }
    if (this.shareScreenPermission === 'SYSTEM_DENIED') {
      tooltipLabel = this.t('perm_sys_denied.screenshare');
      classList['red-icon'] = true;
    }
    else if (this.shareScreenPermission === 'DENIED') {
      tooltipLabel = this.t('perm_denied.screenshare');
      classList['red-icon'] = true;
    }
    else {
      tooltipLabel = label;
    }
    if (limitReached) {
      tooltipLabel = this.t('screenshare.error.max_count');
    }
    if (couldNotStart) {
      tooltipLabel = this.t('screenshare.error.unknown');
    }
    this.screenShareState = {
      tooltipLabel,
      label,
      icon,
      classList,
      disable: hasError || limitReached,
      showWarning: hasError || limitReached || couldNotStart,
    };
  }
  render() {
    if (!deviceCanScreenShare() || !this.canScreenShare) {
      return null;
    }
    return (h(Host, { title: this.screenShareState.label }, h("dyte-tooltip", { placement: "top", kind: "block", label: this.screenShareState.tooltipLabel, delay: 600, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, label: this.screenShareState.label, icon: this.screenShareState.icon, class: this.screenShareState.classList, onClick: this.toggleScreenShare, disabled: this.screenShareState.disable, showWarning: this.screenShareState.showWarning }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteScreenShareToggle.style = dyteScreenShareToggleCss;

var dyteScreenShareToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_screen_share_toggle: DyteScreenShareToggle
});

var RemoteUpdateType;
(function (RemoteUpdateType) {
  RemoteUpdateType["REQUEST_RECEIVED"] = "REQUEST_RECEIVED";
  RemoteUpdateType["REQUEST_SENT"] = "REQUEST_SENT";
  RemoteUpdateType["INCOMING_REQUEST_ACCEPTED"] = "INCOMING_REQUEST_ACCEPTED";
  RemoteUpdateType["OUTGOING_REQUEST_ACCEPTED"] = "OUTGOING_REQUEST_ACCEPTED";
  RemoteUpdateType["INCOMING_REQUEST_ENDED"] = "INCOMING_REQUEST_ENDED";
  RemoteUpdateType["OUTGOING_REQUEST_ENDED"] = "OUTGOING_REQUEST_ENDED";
})(RemoteUpdateType || (RemoteUpdateType = {}));

const dyteScreenshareViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity))}::slotted(dyte-name-tag){position:absolute;left:var(--dyte-space-3, 12px);bottom:var(--dyte-space-3, 12px);opacity:0.8}#video-container{position:absolute;display:block;height:100%;width:100%}#video-container .fit-in-container{-o-object-fit:fill;object-fit:fill}video{height:100%;width:100%;-o-object-fit:contain;object-fit:contain}:host([variant='gradient']) ::slotted(dyte-audio-visualizer){position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px)}:host([variant='gradient']) ::slotted(dyte-name-tag){bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);display:flex;width:100%;align-items:center;justify-content:center;text-align:center;background-color:transparent;background-image:linear-gradient(to top, var(--tw-gradient-stops));--tw-gradient-from:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-gradient-to:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to);--tw-gradient-to:transparent}:host([size='sm'][variant='gradient']) ::slotted(dyte-audio-visualizer){height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}video.visible{-webkit-animation:video-fadein 0.4s ease;animation:video-fadein 0.4s ease}#controls{display:none;position:absolute;top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);align-items:center;justify-content:flex-end;gap:var(--dyte-space-2, 8px)}:host(:hover) #controls,:host(:active) #controls,:host(:focus-visible) #controls{display:flex}#full-screen-btn{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3{margin-top:var(--dyte-space-10, 40px);margin-bottom:var(--dyte-space-6, 24px);text-align:center;font-size:20px;font-weight:500}:host([size='sm']) h3{font-size:16px}#self-message{padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host(.isSelf) #self-view{flex:1 1 0%}:host(.isSelf) #video-container{position:static;aspect-ratio:auto;height:auto;width:50%;max-width:var(--dyte-space-96, 384px);border-radius:var(--dyte-border-radius-md, 8px);transition:0.6s ease}:host(.isSelf) #video-container.expand{width:60%;max-width:100%}.actions{display:flex;align-items:center;justify-content:center;gap:var(--dyte-space-2, 8px)}:host([size='sm'].isSelf) #video-container,:host([size='md'].isSelf) #video-container,:host([size='sm'].isSelf) #expand-btn,:host([size='md'].isSelf) #expand-btn{display:none}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.remote-control{z-index:10;height:100%;max-height:100%;flex:0 1 auto}#remote-control-self{position:absolute;top:var(--dyte-space-0, 0px);left:50%;z-index:10;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;box-sizing:border-box;display:flex;height:var(--dyte-space-8, 32px);align-items:center;overflow:hidden;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-1000, 255 255 255));transform:translateX(-50%)}#remote-control-self p{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}#remote-control-self dyte-button{height:100%;border-radius:var(--dyte-border-radius-none, 0);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity));font-size:12px}:host([size='sm']) #remote-control-self{height:auto;flex-direction:column}:host([size='sm']) #remote-control-self dyte-button{width:100%;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px)}:host([name-tag-position='bottom-right']) ::slotted(dyte-name-tag){left:auto;right:var(--dyte-space-3, 12px)}:host([name-tag-position='bottom-center']) ::slotted(dyte-name-tag){left:auto;right:auto}:host([name-tag-position='top-left']) ::slotted(dyte-name-tag){top:var(--dyte-space-3, 12px);bottom:auto}:host([name-tag-position='top-right']) ::slotted(dyte-name-tag){top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);left:auto;bottom:auto}:host([name-tag-position='top-center']) ::slotted(dyte-name-tag){left:auto;right:auto;bottom:auto;top:var(--dyte-space-3, 12px)}@-webkit-keyframes video-fadein{0%{opacity:0;transform:scale(1.4) translateY(20px)}100%{opacity:1;transform:scale(1) translateY(0)}}@keyframes video-fadein{0%{opacity:0;transform:scale(1.4) translateY(20px)}100%{opacity:1;transform:scale(1) translateY(0)}}::slotted(dyte-network-indicator){position:absolute;right:var(--dyte-space-3, 12px);bottom:var(--dyte-space-3, 12px)}";

const DyteScreenshareView = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.fullScreenListener = () => {
      this.isFullScreen = isFullScreenEnabled();
    };
    this.onRemoteUpdate = ({ payload, type }) => {
      var _a, _b;
      let remoteControlInfo = '';
      if (type === RemoteUpdateType.INCOMING_REQUEST_ACCEPTED) {
        const remotePeer = this.meeting.participants.joined.get(payload.request.remotePeerId);
        remoteControlInfo = `${remotePeer.name} is controlling your screen.`;
      }
      if (type === RemoteUpdateType.OUTGOING_REQUEST_ACCEPTED) {
        const hostPeer = this.meeting.participants.joined.get(payload.request.hostPeerId);
        remoteControlInfo = `You are controlling ${hostPeer.name}'s screen.`;
      }
      if (type === RemoteUpdateType.INCOMING_REQUEST_ENDED ||
        type === RemoteUpdateType.OUTGOING_REQUEST_ENDED) {
        remoteControlInfo = '';
      }
      if (type === RemoteUpdateType.REQUEST_RECEIVED && !Boolean((_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.active)) {
        this.stateUpdate.emit({ activeRemoteAccessManager: true });
      }
      this.remoteControlInfo = remoteControlInfo;
    };
    this.onMouseEvent = (event) => {
      var _a, _b;
      if (this.shouldSkipEventTrigger()) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.mouseEvent(event, this.videoEl);
    };
    this.onKeyDown = (event) => {
      var _a, _b;
      if (this.shouldSkipEventTrigger()) {
        return;
      }
      (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.keyboardEvent(event);
    };
    this.toggleFullScreen = () => {
      if (!this.isFullScreen) {
        requestFullScreen(this.host);
        this.isFullScreen = true;
      }
      else {
        exitFullSreen();
        this.isFullScreen = false;
      }
    };
    this.hideFullScreenButton = false;
    this.nameTagPosition = 'bottom-left';
    this.participant = undefined;
    this.meeting = undefined;
    this.variant = 'solid';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.videoExpanded = false;
    this.screenShareEnabled = false;
    this.isFullScreen = false;
    this.remoteControlInfo = undefined;
  }
  participantScreenshareUpdate(p) {
    if (p.id !== this.participant.id)
      return;
    this.screenShareListener(p);
  }
  connectedCallback() {
    window === null || window === void 0 ? void 0 : window.addEventListener('fullscreenchange', this.fullScreenListener);
    window === null || window === void 0 ? void 0 : window.addEventListener('webkitfullscreenchange', this.fullScreenListener);
  }
  componentDidLoad() {
    this.participantChanged(this.participant);
  }
  disconnectedCallback() {
    var _a, _b;
    const { self } = this.meeting;
    if (this.participant.id === self.id && this.screenShareListener)
      this.participant.removeListener('screenShareUpdate', this.screenShareListener);
    else
      this.meeting.participants.joined.removeListener('screenShareUpdate', this.participantScreenshareUpdate);
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.removeListener('remoteUpdate', this.onRemoteUpdate);
    window === null || window === void 0 ? void 0 : window.removeEventListener('fullscreenchange', this.fullScreenListener);
    window === null || window === void 0 ? void 0 : window.removeEventListener('webkitfullscreenchange', this.fullScreenListener);
  }
  participantChanged(participant) {
    var _a, _b, _c, _d, _e;
    if (participant != null) {
      const { self } = this.meeting;
      this.screenShareListener = ({ screenShareEnabled, screenShareTracks }) => {
        const enabled = screenShareEnabled && screenShareTracks.video != null;
        writeTask(() => {
          this.screenShareEnabled = enabled;
        });
        if (enabled) {
          const stream = new MediaStream();
          stream.addTrack(screenShareTracks.video);
          if (this.videoEl != null) {
            this.videoEl.srcObject = stream;
            this.videoEl.play();
          }
        }
        else if (this.videoEl != null) {
          this.videoEl.srcObject = undefined;
        }
      };
      this.screenShareListener(participant);
      if (Boolean((_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.active) &&
        [this.meeting.remote.active.hostPeerId, this.meeting.remote.active.remotePeerId].includes(participant === null || participant === void 0 ? void 0 : participant.id)) {
        this.onRemoteUpdate({
          payload: { request: this.meeting.remote.active },
          type: ((_c = this.meeting.remote.active) === null || _c === void 0 ? void 0 : _c.hostPeerId) === this.meeting.self.id
            ? 'INCOMING_REQUEST_ACCEPTED'
            : 'OUTGOING_REQUEST_ACCEPTED',
        });
      }
      if (participant.id === self.id)
        participant.addListener('screenShareUpdate', this.screenShareListener);
      else
        this.meeting.participants.joined.addListener('screenShareUpdate', this.participantScreenshareUpdate.bind(this));
      (_e = (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.remote) === null || _e === void 0 ? void 0 : _e.addListener('remoteUpdate', this.onRemoteUpdate);
    }
  }
  shouldSkipEventTrigger() {
    var _a, _b, _c;
    if (this.meeting == null || this.participant == null)
      return true;
    return (!Boolean((_a = this.meeting.remote) === null || _a === void 0 ? void 0 : _a.active) ||
      // It is you, who is moving over your own shared screen
      !Boolean(this.meeting.participants.joined.get((_b = this.meeting.remote) === null || _b === void 0 ? void 0 : _b.active.hostPeerId)) ||
      // Skip nonactive screenshare events, Redundant check
      ((_c = this.meeting.remote) === null || _c === void 0 ? void 0 : _c.active.hostPeerId) != this.participant.id);
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const isSelf = ((_a = this.participant) === null || _a === void 0 ? void 0 : _a.id) === ((_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.id);
    const text = this.isFullScreen ? this.t('full_screen.exit') : this.t('full_screen');
    const icon = this.isFullScreen
      ? this.iconPack.full_screen_minimize
      : this.iconPack.full_screen_maximize;
    return (h(Host, { class: { isSelf } }, Boolean(((_d = (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.active) && this.remoteControlInfo) && (h("div", { id: "remote-control-self", key: "remote-control-self" }, h("p", { class: "remote-control-message" }, this.remoteControlInfo), h("dyte-button", { onClick: () => { var _a; return (_a = this.meeting.remote) === null || _a === void 0 ? void 0 : _a.endControl(); }, iconPack: this.iconPack, t: this.t }, ((_f = (_e = this.meeting.remote) === null || _e === void 0 ? void 0 : _e.active) === null || _f === void 0 ? void 0 : _f.hostPeerId) === this.meeting.self.id
      ? 'Revoke access'
      : 'Stop'))), h("div", { key: "video-container", id: "video-container", class: { expand: this.videoExpanded }, contentEditable: Boolean((_g = this.meeting.remote) === null || _g === void 0 ? void 0 : _g.active), onKeyDown: this.onKeyDown }, h("video", { ref: (el) => (this.videoEl = el), class: {
        visible: this.screenShareEnabled,
        'fit-in-container': this.participant.supportsRemoteControl,
      }, playsInline: true, autoPlay: true, muted: true, id: `screen-share-video-${this.participant.id}`, onMouseMove: this.onMouseEvent, onClick: this.onMouseEvent, onContextMenu: this.onMouseEvent })), h("div", { id: "controls", key: "controls" }, !this.hideFullScreenButton && !isSelf && isFullScreenSupported() && (h("dyte-tooltip", { label: text, iconPack: this.iconPack, t: this.t }, h("dyte-button", { id: "full-screen-btn", kind: "icon", onClick: this.toggleFullScreen, title: text, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: icon, "aria-hidden": true, tabIndex: -1, iconPack: this.iconPack, t: this.t })))), ((_h = this.participant) === null || _h === void 0 ? void 0 : _h.supportsRemoteControl) === true && (h("dyte-menu", { id: "menu", key: "menu", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", slot: "trigger", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.more_vertical, iconPack: this.iconPack, t: this.t })), h("dyte-menu-list", { iconPack: this.iconPack, t: this.t }, !isSelf && (h("dyte-menu-item", { style: {
        cursor: this.participant.supportsRemoteControl ? 'pointer' : 'not-allowed',
      }, iconPack: this.iconPack, t: this.t, onClick: () => {
        var _a, _b;
        if ((_a = this.participant) === null || _a === void 0 ? void 0 : _a.supportsRemoteControl) {
          (_b = this.meeting.remote) === null || _b === void 0 ? void 0 : _b.requestControl(this.participant.id);
        }
      } }, "Request remote control")), isSelf && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, onClick: () => this.stateUpdate.emit({ activeRemoteAccessManager: true }) }, "Manage remote control requests")))))), isSelf && (h("div", { id: "self-message", key: "self-message" }, h("h3", null, this.t('screenshare.shared')), h("div", { class: "actions" }, this.meeting != null && (h("dyte-button", { variant: "danger", onClick: () => {
        this.meeting.self.disableScreenShare();
      }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.share_screen_stop, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('screenshare.stop'))), h("dyte-button", { variant: "secondary", id: "expand-btn", iconPack: this.iconPack, t: this.t, onClick: () => {
        this.videoExpanded = !this.videoExpanded;
      } }, h("dyte-icon", { icon: this.videoExpanded
        ? this.iconPack.full_screen_minimize
        : this.iconPack.full_screen_maximize, slot: "start", iconPack: this.iconPack, t: this.t }), this.videoExpanded
      ? this.t('screenshare.min_preview')
      : this.t('screenshare.max_preview'))))), h("slot", null)));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "participant": ["participantChanged"]
  }; }
};
DyteScreenshareView.style = dyteScreenshareViewCss;

var dyteScreenshareView_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_screenshare_view: DyteScreenshareView
});

const dyteSettingsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{display:flex;align-items:center;justify-content:space-between;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}.title{font-size:20px;line-height:1}.back-btn,.dismiss-btn{border-radius:var(--dyte-border-radius-sm, 4px);background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.back-btn:hover,.dismiss-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside{box-sizing:border-box;display:flex;min-width:var(--dyte-space-56, 224px);flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px)}aside button{margin-top:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;width:100%;align-items:center;justify-content:space-between;border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);background-color:transparent;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));cursor:default;font-size:16px;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px}aside button .right{display:flex;align-items:center}aside button .right dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}aside button .right dyte-icon:last-child{margin-left:var(--dyte-space-4, 16px)}aside button[type='button']{cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}aside button[type='button']:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside button[type='button']{border-right:var(--dyte-border-width-md, 2px) solid transparent}aside button.active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}aside button.active:hover{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}dyte-icon.poor{--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}dyte-icon.poorest{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon.good{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}main{display:flex;flex:1 1 0%;align-items:center;justify-content:center;padding-left:var(--dyte-space-6, 24px);padding-right:var(--dyte-space-6, 24px);box-sizing:border-box;width:100%}.dismiss-btn{position:absolute;top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']) aside{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([size='sm']) .dismiss-btn{top:var(--dyte-space-5, 20px);right:var(--dyte-space-4, 16px)}:host([size='sm']) aside{width:100%;padding-left:var(--dyte-space-0, 0px)}:host([size='sm']) aside button{border-radius:var(--dyte-border-radius-none, 0)}:host([size='sm']) aside button.active{border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}:host([size='sm']) aside button.active:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) aside.hide{display:none}:host([size='sm']) main{display:none;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='sm']) main header{justify-content:center}:host([size='sm']) main header dyte-button{position:absolute;left:var(--dyte-space-4, 16px)}:host([size='sm']) main.active{display:block}";

const DyteSettings = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.keyPressListener = (e) => {
      if (e.key === 'Escape') {
        this.close();
      }
    };
    this.selfJoinStageListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.selfStageLeftListener = () => {
      this.canProduceVideo = false;
    };
    this.selfJoinStageRejectedListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.activeTab = 'connection';
    this.isMobileMainVisible = false;
    this.networkStatus = 'good';
    this.canProduceVideo = false;
  }
  connectedCallback() {
    document.addEventListener('keydown', this.keyPressListener);
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e, _f;
    // NOTE(ishita1805): hidden because preview was removed from self.
    // this.meeting?.self.disablePreview();
    this.keyPressListener && document.removeEventListener('keydown', this.keyPressListener);
    this.poorConnectionListener &&
      ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta.removeListener('poorConnection', this.poorConnectionListener));
    this.selfJoinStageListener &&
      ((_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.removeListener('joinStageRequestAccepted', this.selfJoinStageListener));
    this.selfJoinStageRejectedListener &&
      ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('joinStageRequestRejected', this.selfJoinStageRejectedListener));
    this.selfJoinStageListener &&
      ((_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self.removeListener('stageJoined', this.selfJoinStageListener));
    this.selfStageLeftListener &&
      ((_e = this.meeting) === null || _e === void 0 ? void 0 : _e.self.removeListener('stageLeft', this.selfStageLeftListener));
    this.selfJoinStageListener &&
      ((_f = this.meeting) === null || _f === void 0 ? void 0 : _f.self.removeListener('removedFromStage', this.selfJoinStageListener));
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.updateCanProduce(meeting);
      if (!this.canProduceVideo) {
        this.activeTab = 'audio';
      }
      else {
        this.activeTab = 'video';
      }
      this.poorConnectionListener = ({ score }) => {
        if (score < 7) {
          this.networkStatus = 'poor';
        }
        else if (score < 4) {
          this.networkStatus = 'poorest';
        }
        setTimeout(() => {
          // reset after 5 seconds
          this.networkStatus = 'good';
        }, 5000);
      };
      meeting.meta.addListener('poorConnection', this.poorConnectionListener);
      meeting.self.addListener('joinStageRequestAccepted', this.selfJoinStageListener);
      meeting.self.addListener('joinStageRequestRejected', this.selfJoinStageRejectedListener);
      meeting.self.addListener('stageJoined', this.selfJoinStageListener);
      meeting.self.addListener('stageLeft', this.selfStageLeftListener);
      meeting.self.addListener('removedFromStage', this.selfJoinStageListener);
    }
  }
  updateCanProduce(meeting) {
    const { self, meta, stage } = meeting;
    const canProduceVideo = self.permissions.canProduceVideo === 'ALLOWED';
    const isWebinar = meta.viewType === 'WEBINAR';
    const isLiveStream = meta.viewType === 'LIVESTREAM';
    if (!isWebinar && !isLiveStream) {
      this.canProduceVideo = canProduceVideo;
    }
    else {
      const canRequestVideo = self.permissions.canProduceVideo === 'CAN_REQUEST';
      // If the peer can join stage or is approved to join stage
      if (canProduceVideo ||
        (canRequestVideo &&
          ((isWebinar &&
            (self.webinarStageStatus === 'ON_STAGE' ||
              self.webinarStageStatus === 'ACCEPTED_TO_JOIN_STAGE')) ||
            (isLiveStream &&
              (stage.status === 'ON_STAGE' || stage.status === 'ACCEPTED_TO_JOIN_STAGE'))))) {
        this.canProduceVideo = true;
      }
    }
  }
  changeTab(tab) {
    this.activeTab = tab;
    if (this.size === 'sm') {
      if (!this.isMobileMainVisible) {
        this.isMobileMainVisible = true;
      }
    }
  }
  close() {
    this.stateUpdate.emit({ activeSettings: false });
    state.activeSettings = false;
  }
  render() {
    if (this.meeting == null)
      return null;
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      iconPack: this.iconPack,
      t: this.t,
    };
    return (h(Host, null, h("aside", { class: { hide: this.isMobileMainVisible }, part: "menu" }, h("header", null, h("h2", null, this.t('settings'))), h("button", { type: "button", class: { active: this.activeTab === 'audio' }, onClick: () => this.changeTab('audio') }, this.t('audio'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.mic_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), this.canProduceVideo && (h("button", { type: "button", class: { active: this.activeTab === 'video' }, onClick: () => this.changeTab('video') }, this.t('video'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.video_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t }))))), h("button", { type: "none", title: `Your network condition is ${this.networkStatus}` }, this.t('connection'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.wifi, class: this.networkStatus, iconPack: this.iconPack, t: this.t })))), h("main", { class: { active: this.isMobileMainVisible }, part: "main-content" }, this.size === 'sm' && (h("header", null, h("dyte-button", { kind: "icon", class: "back-btn", onClick: () => (this.isMobileMainVisible = false), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), h("h2", null, this.t(this.activeTab === 'audio' ? 'audio' : 'video')))), this.activeTab === 'audio' && h("dyte-settings-audio", Object.assign({}, defaults)), this.activeTab === 'video' && h("dyte-settings-video", Object.assign({}, defaults)))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteSettings.style = dyteSettingsCss;

var dyteSettings_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_settings: DyteSettings
});

const dyteSettingsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteSettingsToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.variant = 'button';
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  toggleSettings() {
    var _a;
    this.stateUpdate.emit({
      activeSettings: !((_a = this.states) === null || _a === void 0 ? void 0 : _a.activeSettings),
      activeMoreMenu: false,
    });
    state.activeSettings = !state.activeSettings;
    state.activeMoreMenu = false;
  }
  render() {
    const text = this.t('settings');
    return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleSettings(), icon: this.iconPack.settings, label: text, variant: this.variant })));
  }
};
DyteSettingsToggle.style = dyteSettingsToggleCss;

var dyteSettingsToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_settings_toggle: DyteSettingsToggle
});

const dyteSetupScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;padding:var(--dyte-space-4, 16px);height:100%;min-height:100%;width:100%;display:flex;place-items:center;justify-content:center;--dyte-controlbar-button-background-color:rgb(var(--dyte-colors-background-700, 44 44 44))}.container{width:100%;max-width:1080px;display:flex;align-items:center;justify-content:space-evenly}.metadata{width:100%;max-width:var(--dyte-space-80, 320px)}.label{display:flex;flex-direction:column;align-items:center}.label p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px}.name{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-6, 24px);text-align:center;font-size:28px;font-weight:500;letter-spacing:-0.025em;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}input{margin-bottom:var(--dyte-space-6, 24px);display:block;height:var(--dyte-space-10, 40px);width:100%;max-width:var(--dyte-space-80, 320px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255));box-sizing:border-box;font-size:16px;outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}input::placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}input{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}dyte-spinner{color:rgb(var(--dyte-colors-text-1000, 255 255 255));--icon-size:var(--dyte-space-8, 32px)}:host([size='sm']) .container,:host([size='md']) .container{height:100%;flex-direction:column;justify-content:space-evenly}dyte-camera-toggle{margin-left:var(--dyte-space-1\\.5, 6px)}dyte-participant-tile{height:auto;width:100%;max-width:var(--dyte-space-96, 384px)}";

const DyteSetupScreen = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.join = async () => {
      var _a, _b, _c;
      if (((_a = this.displayName) === null || _a === void 0 ? void 0 : _a.trim()) !== '' && !this.isJoining) {
        this.isJoining = true;
        (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.setName(this.displayName);
        gracefulStorage$1.setItem('dyte-display-name', this.displayName);
        await ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.joinRoom());
      }
    };
    this.meeting = undefined;
    this.states = state;
    this.size = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.displayName = undefined;
    this.isJoining = false;
    this.canEditName = true;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  componentDidLoad() {
    var _a;
    (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting != null) {
      this.canEditName = (_a = meeting.self.permissions.canEditDisplayName) !== null && _a !== void 0 ? _a : true;
      this.displayName = ((_b = meeting.self.name) === null || _b === void 0 ? void 0 : _b.trim()) || '';
      state.meeting = 'setup';
    }
  }
  render() {
    var _a, _b, _c, _d;
    const disabled = ((_a = this.displayName) === null || _a === void 0 ? void 0 : _a.trim()) === '';
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states || state,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    return (h(Host, null, h("div", { class: "container" }, h(Render, { element: "dyte-participant-tile", defaults: defaults, props: { participant: (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self, size: 'md' }, childProps: { participant: (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self, size: 'md' }, deepProps: true }), h("div", { class: "metadata" }, ((_d = this.displayName) === null || _d === void 0 ? void 0 : _d.trim()) === '' ? (h("div", { class: "name" }, this.t('setup_screen.join_in_as'))) : (h("div", { class: "label" }, h("p", null, this.t('setup_screen.joining_as')), h("div", { class: "name" }, shorten(this.displayName, 20)))), this.canEditName && (h("input", { placeholder: this.t('setup_screen.your_name'), value: this.displayName, autoFocus: true, ref: (el) => {
        this.inputEl = el;
      }, onInput: (e) => {
        this.displayName = e.target.value;
      }, onKeyDown: (e) => {
        if (e.key === 'Enter') {
          this.join();
        }
      } })), h("dyte-button", { size: "lg", kind: "wide", onClick: this.join, disabled: disabled, iconPack: this.iconPack, t: this.t }, this.isJoining ? (h("dyte-spinner", { iconPack: this.iconPack, t: this.t })) : (this.t('join')))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteSetupScreen.style = dyteSetupScreenCss;

var dyteSetupScreen_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_setup_screen: DyteSetupScreen
});

const dyteSidebarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;max-width:var(--dyte-space-80, 320px);box-sizing:border-box;display:flex;flex-direction:column;position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);left:auto;z-index:50;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-border-opacity))}:host([view='sidebar']){right:var(--dyte-space-2, 8px);overflow:clip;border-radius:var(--dyte-border-radius-lg, 12px);--tw-shadow:0 25px 50px -12px rgb(0 0 0 / 0.25);--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);--tw-shadow-color:rgb(var(--dyte-colors-background-900, 26 26 26));--tw-shadow:var(--tw-shadow-colored)}:host([view='full-screen']){top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);max-width:100%}";

const DyteSidebar = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.getTabs = () => {
      if (!this.meeting.self.config) {
        return this.enabledSections;
      }
      return this.enabledSections.filter((section) => this.meeting.self.config.controlBar.elements[section.id]);
    };
    this.close = () => {
      this.stateUpdate.emit({ activeSidebar: false, sidebar: this.defaultSection });
      state.sidebar = this.currentTab;
    };
    this.enabledSections = [];
    this.defaultSection = 'chat';
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.size = undefined;
    this.view = 'sidebar';
    this.currentTab = this.defaultSection;
  }
  connectedCallback() {
    this.viewChanged(this.view);
    this.statesChanged(this.states);
    this.meetingChanged(this.meeting);
    onChange('sidebar', () => this.statesChanged());
  }
  disconnectedCallback() {
    var _a, _b;
    document.removeEventListener('keydown', this.keydownListener);
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', this.updateEnabledSections);
  }
  meetingChanged(meeting) {
    var _a, _b;
    this.updateEnabledSections(meeting);
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.on('stageStatusUpdate', this.updateEnabledSections);
  }
  statesChanged(s) {
    const states = s || state;
    if (states === null || states === void 0 ? void 0 : states.sidebar) {
      this.currentTab = states.sidebar;
    }
  }
  viewChanged(view) {
    if (view === 'full-screen') {
      this.keydownListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      document.addEventListener('keydown', this.keydownListener);
    }
  }
  viewSection(section) {
    this.currentTab = section;
    this.stateUpdate.emit({ activeSidebar: true, sidebar: this.currentTab });
    state.activeSidebar = true;
    state.sidebar = this.currentTab;
  }
  updateEnabledSections(meeting = this.meeting) {
    const list = [];
    if (canViewChat(meeting)) {
      list.push({ id: 'chat', name: this.t('chat') });
    }
    if (canViewPolls(meeting)) {
      list.push({ id: 'polls', name: this.t('polls') });
    }
    if (canViewParticipants(meeting)) {
      list.push({ id: 'participants', name: this.t('participants') });
    }
    if (canViewPlugins(meeting)) {
      list.push({ id: 'plugins', name: this.t('plugins') });
    }
    this.enabledSections = list;
  }
  render() {
    var _a;
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states || state,
      size: this.size,
      t: this.t,
      iconPack: this.iconPack,
    };
    // NOTE(ishita1805): This makes it easier to use the sidebar component in isolation.
    if (((_a = this.states) === null || _a === void 0 ? void 0 : _a.activeSidebar) === false || !this.currentTab) {
      return null;
    }
    return (h(Host, null, h("dyte-sidebar-ui", { tabs: this.getTabs(), currentTab: this.currentTab, view: this.view, onTabChange: (e) => {
        this.viewSection(e.detail);
      }, onSidebarClose: this.close }, h("dyte-chat", Object.assign({}, defaults, { slot: "chat" })), h("dyte-polls", Object.assign({}, defaults, { slot: "polls" })), h("dyte-participants", Object.assign({}, defaults, { slot: "participants" })), h("dyte-plugins", Object.assign({}, defaults, { slot: "plugins" })))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "states": ["statesChanged"],
    "view": ["viewChanged"]
  }; }
};
DyteSidebar.style = dyteSidebarCss;

var dyteSidebar_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_sidebar: DyteSidebar
});

const dyteSimpleGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block;height:100%;width:100%}";

const DyteSimpleGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setHostDimensions = () => {
      const { clientWidth: width, clientHeight: height } = this.host;
      this.dimensions = { width, height };
    };
    this.participants = [];
    this.aspectRatio = '16:9';
    this.gap = 8;
    this.size = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.dimensions = { width: 0, height: 0 };
  }
  connectedCallback() {
    this.resizeObserver = new index(this.setHostDimensions);
    this.resizeObserver.observe(this.host);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    const { width, height, getPosition } = useGrid({
      dimensions: this.dimensions,
      count: this.participants.length,
      aspectRatio: this.aspectRatio,
      gap: this.gap,
    });
    return (h(Host, null, this.participants.map((participant, index) => {
      const { top, left } = getPosition(index);
      return (h(Render, { element: "dyte-participant-tile", defaults: defaults, props: {
          participant,
          style: {
            position: 'absolute',
            top: `${top}px`,
            left: `${left}px`,
            width: `${width}px`,
            height: `${height}px`,
          },
          key: participant.id,
          'data-participant': participant.id,
        }, childProps: { participant }, deepProps: true }));
    }), h("slot", null)));
  }
  get host() { return getElement(this); }
};
DyteSimpleGrid.style = dyteSimpleGridCss;

var dyteSimpleGrid_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_simple_grid: DyteSimpleGrid
});

const dyteSpotlightGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%}main{flex:1 1 0%}.grid-width-sm{width:25%}.grid-width-md{width:50%}.grid-width-lg{width:66.666667%}:host([size='sm']),:host([size='md']){flex-direction:column}:host([size='md']) aside{max-height:var(--dyte-space-96, 384px);width:100%;max-width:100%}:host([size='md']) .grid-width-sm{height:25%}:host([size='md']) .grid-width-md{height:50%}:host([size='md']) .grid-width-lg{height:66.666667%}:host([size='sm']) aside{max-height:var(--dyte-space-96, 384px);width:100%;max-width:100%}:host([size='sm']) .grid-width-sm,:host([size='sm']) .grid-width-md,:host([size='sm']) .grid-width-lg{height:50%}:host([size='xl']) .grid-width-sm,:host([size='xl']) .grid-width-md,:host([size='xl']) .grid-width-lg{width:400px}:host([layout='column']){flex-direction:column}:host([layout='column']) main{flex:4}:host([layout='column']) aside{flex:2;max-width:100%;width:100%}";

const DyteSpotlightGrid = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.getAdaptiveSize = (length) => {
      if (this.size === 'sm') {
        return 'sm';
      }
      if (length > 3) {
        return 'sm';
      }
      else {
        if (this.size === 'md') {
          return 'sm';
        }
        return 'md';
      }
    };
    this.layout = 'row';
    this.participants = [];
    this.pinnedParticipants = [];
    this.aspectRatio = '16:9';
    this.gap = 8;
    this.size = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.gridSize = defaultGridSize;
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      config: this.config,
      states: this.states,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    const nonPinnedParticipants = this.participants.filter((p) => this.pinnedParticipants.some((pt) => pt.id != p.id));
    return (h(Host, null, h("main", { part: "main" }, h(Render, { element: "dyte-simple-grid", defaults: defaults, props: {
        part: 'main-grid',
        participants: this.pinnedParticipants,
        aspectRatio: this.aspectRatio,
        gap: this.gap,
        size: this.getAdaptiveSize(this.pinnedParticipants.length),
      } })), nonPinnedParticipants.length > 0 && (h("aside", { part: "aside", class: this.gridSize.spotlight ? `grid-width-${this.gridSize.spotlight}` : 'grid-width-md' }, h(Render, { element: "dyte-simple-grid", defaults: defaults, props: {
        part: 'aside-grid',
        participants: nonPinnedParticipants,
        aspectRatio: this.aspectRatio,
        gap: this.gap,
        size: this.getAdaptiveSize(nonPinnedParticipants.length),
      } })))));
  }
  get host() { return getElement(this); }
};
DyteSpotlightGrid.style = dyteSpotlightGridCss;

var dyteSpotlightGrid_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_spotlight_grid: DyteSpotlightGrid
});

const dyteStageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;position:relative;overflow:hidden}";

const DyteStage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("slot", null)));
  }
};
DyteStage.style = dyteStageCss;

var dyteStage_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_stage: DyteStage
});

const dyteStageToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteStageToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.stageCallback = async () => {
      var _a, _b, _c, _d, _e, _f, _g;
      const stageStatus = (_a = this.meeting.stage) === null || _a === void 0 ? void 0 : _a.status;
      if (stageStatus === 'ON_STAGE') {
        await ((_c = (_b = this === null || this === void 0 ? void 0 : this.meeting) === null || _b === void 0 ? void 0 : _b.stage) === null || _c === void 0 ? void 0 : _c.leave());
      }
      if (stageStatus === 'OFF_STAGE') {
        (_e = (_d = this === null || this === void 0 ? void 0 : this.meeting) === null || _d === void 0 ? void 0 : _d.stage) === null || _e === void 0 ? void 0 : _e.requestAccess();
        if (canJoinStage(this.meeting)) {
          this.stateUpdate.emit({ activeJoinStage: true });
        }
      }
      if (stageStatus === 'REQUESTED_TO_JOIN_STAGE') {
        (_g = (_f = this === null || this === void 0 ? void 0 : this.meeting) === null || _f === void 0 ? void 0 : _f.stage) === null || _g === void 0 ? void 0 : _g.cancelRequestAccess();
      }
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.stageStatus = 'OFF_STAGE';
    this.state = {
      label: '',
      disabled: false,
      icon: '',
    };
    this.t = useLanguage();
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  stageStatusHandler(meeting, status) {
    this.stageStatus = status;
    if (status === 'ACCEPTED_TO_JOIN_STAGE') {
      meeting.self.setupTracks({ audio: false, video: false });
      this.stateUpdate.emit({ activeJoinStage: true });
    }
    this.state = this.getState();
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.stage) === null || _b === void 0 ? void 0 : _b.removeListener('stageStatusUpdate', (status) => this.stageStatusHandler(this.meeting, status));
  }
  meetingChanged(meeting) {
    var _a, _b, _c, _d;
    if (meeting == null)
      return;
    this.stageStatus = (_a = meeting.stage) === null || _a === void 0 ? void 0 : _a.status;
    this.stageStatusHandler(meeting, (_b = meeting.stage) === null || _b === void 0 ? void 0 : _b.status);
    (_d = (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.stage) === null || _d === void 0 ? void 0 : _d.on('stageStatusUpdate', (status) => this.stageStatusHandler(meeting, status));
  }
  getState() {
    let label = '';
    let icon = '';
    let disabled = false;
    switch (this.stageStatus) {
      case 'ON_STAGE': {
        icon = this.iconPack.leave_stage;
        label = 'Leave Livestream';
        disabled = false;
        break;
      }
      case 'ACCEPTED_TO_JOIN_STAGE': {
        icon = this.iconPack.join_stage;
        label = 'Join Livestream';
        disabled = true;
        break;
      }
      case 'REQUESTED_TO_JOIN_STAGE': {
        icon = this.iconPack.join_stage;
        label = 'Requested';
        disabled = false;
        break;
      }
      default: {
        icon = this.iconPack.join_stage;
        label = 'Join Livestream';
        disabled = false;
        break;
      }
    }
    return { label, disabled, icon };
  }
  render() {
    if (!canRequestToJoinStage(this.meeting))
      return;
    return (h(Host, { title: this.state.label }, h("dyte-tooltip", { placement: "top", kind: "block", label: this.state.label, delay: 600, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, label: this.state.label, icon: this.state.icon, onClick: this.stageCallback, disabled: this.state.disabled, showWarning: false }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteStageToggle.style = dyteStageToggleCss;

var dyteStageToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_stage_toggle: DyteStageToggle
});

const dyteTextFieldCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}input{display:block;height:var(--dyte-space-10, 40px);padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-size:14px;border-width:var(--dyte-border-width-md, 2px);border-style:solid;border-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input::placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input:focus{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}input{border-radius:var(--dyte-border-radius-sm, 4px);outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}input:disabled{cursor:not-allowed}";

const DyteTextField = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.type = 'text';
    this.placeholder = '';
    this.disabled = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.stateUpdate.emit({ abc: false });
    state.abc = false;
  }
  get value() {
    return this.input.value;
  }
  render() {
    return (h(Host, null, h("input", { ref: (el) => (this.input = el), type: this.type, placeholder: this.placeholder, disabled: this.disabled })));
  }
};
DyteTextField.style = dyteTextFieldCss;

var dyteTextField_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_text_field: DyteTextField
});

const DyteUiProvider = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.size = undefined;
    this.config = defaultConfig;
    this.t = useLanguage();
    this.iconPackUrl = undefined;
    this.loadConfigFromPreset = true;
    this.applyDesignSystem = true;
    this.joinRoom = true;
    this.isReady = false;
    this.iconPack = defaultIconPack;
  }
  async iconPackUrlChanged(url) {
    this.iconPack = await getIconPack(url);
  }
  async meetingChanged(meeting) {
    var _a;
    if (!meeting)
      return;
    if (!meeting.self.roomJoined && this.joinRoom) {
      this.isReady = false;
      await meeting.joinRoom();
      this.isReady = true;
    }
    if (this.loadConfigFromPreset && meeting.self.config != null) {
      const theme = meeting.self.config;
      const { config } = generateConfig(theme, meeting);
      if (this.config === defaultConfig) {
        // only override the config if the object is same as defaultConfig
        // which means it's a different object passed via prop
        this.config = Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { designTokens: Object.assign(Object.assign({}, defaultConfig.designTokens), config.designTokens) });
      }
    }
    if (this.applyDesignSystem &&
      ((_a = this.config) === null || _a === void 0 ? void 0 : _a.designTokens) != null &&
      typeof document !== 'undefined') {
      provideDyteDesignSystem(document.documentElement, this.config.designTokens);
    }
    Array.from(this.hostEl.children)
      .filter((element) => element.tagName.startsWith('DYTE-'))
      .forEach((element) => {
      element['meeting'] = meeting;
      element['config'] = this.config;
      element['size'] = this.size;
      element['iconPack'] = this.iconPack;
      element['t'] = this.t;
    });
  }
  connectedCallback() {
    this.resizeObserver = new ResizeObserver(() => this.handleResize());
    this.resizeObserver.observe(this.hostEl);
    this.meetingChanged(this.meeting);
    this.iconPackUrlChanged(this.iconPackUrl);
  }
  handleResize() {
    this.size = getSize(this.hostEl.clientWidth);
  }
  render() {
    if (!this.isReady)
      return null;
    return h("slot", null);
  }
  get hostEl() { return getElement(this); }
  static get watchers() { return {
    "iconPackUrl": ["iconPackUrlChanged"],
    "meeting": ["meetingChanged"]
  }; }
};

var dyteUiProvider_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_ui_provider: DyteUiProvider
});

const dyteWaitingScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.centered{display:flex;flex-direction:column;align-items:center}dyte-logo{margin-bottom:var(--dyte-space-8, 32px);height:var(--dyte-space-12, 48px)}p{font-size:16px;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

const DyteWaitingScreen = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.config = defaultConfig;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("slot", null, h("div", { class: "centered", part: "content" }, h("dyte-logo", { meeting: this.meeting, config: this.config, part: "logo", t: this.t }), h("p", null, this.t('waitlist.body_text'))))));
  }
};
DyteWaitingScreen.style = dyteWaitingScreenCss;

var dyteWaitingScreen_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_waiting_screen: DyteWaitingScreen
});

const dyteWebinarStageToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteWebinarStageToggle = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.requestToJoinAcceptedListener = () => {
      this.stageStatus = 'ACCEPTED';
    };
    this.requestToJoinRejectedListener = () => {
      this.stageStatus = 'DENIED';
    };
    this.stageJoinedListener = () => {
      this.stageStatus = 'ACCEPTED';
    };
    this.removeFromStageListener = () => {
      this.stageStatus = 'NOT_REQUESTED';
    };
    this.selfStageLeftListener = () => {
      this.stageStatus = 'NOT_REQUESTED';
    };
    this.requestStageListener = () => {
      this.stageStatus = 'PENDING';
    };
    this.stageCallback = async () => {
      var _a;
      const self = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self;
      if (self == null || (!this.requestProduce && !this.canPresent)) {
        return;
      }
      if (this.stageStatus === 'PENDING') {
        await self.withdrawRequestToJoinStage();
        return;
      }
      if (this.stageStatus === 'ACCEPTED') {
        await self.leaveStage();
        this.stageStatus = 'NOT_REQUESTED';
        return;
      }
      if (this.canPresent) {
        await self.joinStage();
        this.stageStatus = 'ACCEPTED';
      }
      else {
        await self.requestToJoinStage();
        this.stageStatus = 'PENDING';
      }
    };
    this.variant = 'button';
    this.meeting = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.stageStatus = 'NOT_REQUESTED';
    this.canPresent = false;
    this.requestProduce = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.meeting.self.addListener('joinStageRequestAccepted', this.requestToJoinAcceptedListener);
    this.meeting.self.addListener('joinStageRequestRejected', this.requestToJoinRejectedListener);
    this.meeting.self.addListener('stageJoined', this.stageJoinedListener);
    this.meeting.self.addListener('removedFromStage', this.removeFromStageListener);
    this.meeting.self.addListener('stageLeft', this.selfStageLeftListener);
    this.meeting.self.addListener('peerRequestToJoinStage', this.requestStageListener);
  }
  disconnectedCallback() {
    this.meeting.self.removeListener('joinStageRequestAccepted', this.requestToJoinAcceptedListener);
    this.meeting.self.removeListener('joinStageRequestRejected', this.requestToJoinRejectedListener);
    this.meeting.self.removeListener('removedFromStage', this.removeFromStageListener);
    this.meeting.self.removeListener('stageJoined', this.stageJoinedListener);
    this.meeting.self.removeListener('stageLeft', this.selfStageLeftListener);
    this.meeting.self.removeListener('peerRequestToJoinStage', this.requestStageListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.requestProduce = meeting.self.permissions.requestProduce;
      this.canPresent = meeting.self.permissions.canPresent;
      if (this.canPresent || meeting.self.webinarStageStatus === 'ON_STAGE') {
        this.stageStatus = 'ACCEPTED';
      }
    }
  }
  getState() {
    let tooltipLabel = '';
    let label = '';
    let icon = '';
    let classList = {};
    let disabled = false;
    if (this.stageStatus === 'PENDING') {
      label = this.t('stage_request.cancel_request');
      tooltipLabel = this.t('stage_request.pending_tip');
      icon = this.iconPack.leave_stage;
      classList['red-icon'] = false;
    }
    else if (this.stageStatus === 'ACCEPTED') {
      label = this.t('stage_request.leave_stage');
      tooltipLabel = this.t('stage_request.leave_tip');
      icon = this.iconPack.leave_stage;
      classList['red-icon'] = false;
      disabled = false;
    }
    else if (this.stageStatus === 'DENIED') {
      label = this.t('stage_request.denied');
      tooltipLabel = this.t('stage_request.denied_tip');
      icon = this.iconPack.join_stage;
      classList['red-icon'] = false;
      disabled = true;
    }
    else {
      label = this.t('stage_request.request');
      if (this.canPresent) {
        tooltipLabel = this.t('stage_request.request');
      }
      else {
        tooltipLabel = this.t('stage_request.request_tip');
      }
      icon = this.iconPack.join_stage;
      disabled = false;
    }
    return { tooltipLabel, label, icon, classList, disabled };
  }
  render() {
    if (!this.requestProduce && !this.canPresent) {
      return null;
    }
    if (this.meeting.self.config.viewType !== 'WEBINAR') {
      return null;
    }
    const { tooltipLabel, label, icon, classList, disabled } = this.getState();
    return (h(Host, { title: label }, h("dyte-tooltip", { placement: "top", kind: "block", label: tooltipLabel, delay: 600, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, label: label, icon: icon, class: classList, onClick: this.stageCallback, disabled: disabled, showWarning: false }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteWebinarStageToggle.style = dyteWebinarStageToggleCss;

var dyteWebinarStageToggle_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_webinar_stage_toggle: DyteWebinarStageToggle
});

const dyteBreakoutRoomManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px)}@-webkit-keyframes bg-glow{25%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}50%{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}75%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}}@keyframes bg-glow{25%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}50%{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}75%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}}.glowing-card{-webkit-animation:bg-glow 0.8s;animation:bg-glow 0.8s}.selector-mode,.assign-mode{display:flex;flex-direction:column;align-items:center;padding:var(--dyte-space-2, 8px);cursor:pointer}.selector:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.show-on-hover{display:none}.header{width:100%;display:flex;align-items:center}.header dyte-icon{margin-left:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);cursor:pointer}.header .danger{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.header .hide{display:none}.header .rooms-container{display:flex;flex-grow:1;flex-direction:row;align-items:center;justify-content:flex-end}.header input{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-1, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));max-width:var(--dyte-space-36, 144px);font-size:14px;font-weight:500;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}.header input:disabled{overflow-x:visible;border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}.header input:invalid{border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:dashed;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-border-opacity))}.header input.editing-enabled{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.header .participant-count{display:flex;align-items:center;font-size:14px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.header .participant-count dyte-icon{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0\\.5, 2px);width:var(--dyte-space-3, 12px)}.header .assign-button{height:var(--dyte-space-6, 24px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity));-webkit-text-decoration-line:underline;text-decoration-line:underline}.header .assign-button:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.participant-list{display:grid;flex-grow:1;grid-template-columns:repeat(2, minmax(0, 1fr));gap:var(--dyte-space-2, 8px);margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);width:100%;border-radius:var(--dyte-border-radius-sm, 4px)}.participant-list::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px)}.participant-list::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.participant-list::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.participant-item{display:flex;align-items:center;justify-content:space-between;margin-right:var(--dyte-space-2, 8px);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}.participant-item:hover{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.selector-mode:hover .show-on-hover{display:flex}.message-container{margin:var(--dyte-space-0, 0px);display:flex;width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.message-container p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-20, 80px);display:flex;width:100%;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));border-style:dashed;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity))}.message-container p:hover{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.25)}.message-container .drop-zone-active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.25)}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}.show-on-hover{margin-left:var(--dyte-space-4, 16px);height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);display:none}:host(:hover) .show-on-hover{display:flex}.peer-ui-container{position:relative;display:flex;align-items:center;gap:var(--dyte-space-2, 8px);height:var(--dyte-space-10, 40px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.peer-ui-container dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.peer-ui-container .name{font-size:14px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}";

const ROOM_TITLE_MIN_CHARS = 3;
const DyteBreakoutRoomManager = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onParticipantsAdd = createEvent(this, "participantsAdd", 7);
    this.onParticipantDelete = createEvent(this, "participantDelete", 7);
    this.onRoomJoin = createEvent(this, "roomJoin", 7);
    this.deleteRoom = createEvent(this, "delete", 7);
    this.updateRoom = createEvent(this, "update", 7);
    this.reset = () => {
      this.editingTitleRoomId = null;
      this.newTitle = null;
    };
    this.onEditClick = () => {
      if (this.editingTitleRoomId) {
        if (this.newTitle.length < ROOM_TITLE_MIN_CHARS)
          return;
        this.roomTitle = this.newTitle;
        this.updateRoom.emit({
          title: this.newTitle,
          id: this.editingTitleRoomId,
        });
        this.glowCard();
        this.reset();
      }
      else {
        this.editingTitleRoomId = this.room.id;
        writeTask(() => {
          this.inputTextEl.focus();
          this.inputTextEl.select();
        });
      }
    };
    this.onDrop = (e) => {
      if (e.currentTarget instanceof HTMLParagraphElement) {
        e.currentTarget.classList.remove('drop-zone-active');
        this.onAssign();
      }
    };
    this.onDragOver = (e) => {
      if (e.currentTarget instanceof HTMLParagraphElement) {
        e.currentTarget.classList.add('drop-zone-active');
        e.preventDefault();
      }
    };
    this.meeting = undefined;
    this.assigningParticipants = undefined;
    this.mode = undefined;
    this.states = undefined;
    this.allowDelete = true;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isDragMode = false;
    this.room = undefined;
    this.defaultExpanded = false;
    this.editingTitleRoomId = null;
    this.newTitle = null;
    this.showExpandedCard = false;
    this.glowingCard = false;
  }
  connectedCallback() {
    var _a;
    this.allParticipants = getAllConnectedParticipants(this.meeting);
    this.permissions = this.meeting.self.permissions.connectedMeetings;
    this.showExpandedCard = this.defaultExpanded;
    this.roomTitle = this.room.isParent ? this.t('breakout_rooms.main_room') : (_a = this.room) === null || _a === void 0 ? void 0 : _a.title;
    this.canEditMeetingTitle =
      this.permissions.canAlterConnectedMeetings &&
        !this.room.isParent &&
        !this.meeting.connectedMeetings.isActive; // TODO: remove this once socket supports update meetings
  }
  onDragLeave(e) {
    if (e.currentTarget instanceof HTMLParagraphElement) {
      e.currentTarget.classList.remove('drop-zone-active');
    }
  }
  getAssignmentHint() {
    if (this.assigningParticipants && this.isDragMode) {
      return this.t('breakout_rooms.drag_drop_participants');
    }
    if (this.assigningParticipants) {
      return this.t('breakout_rooms.click_drop_participants');
    }
    if (this.room.participants.length === 0) {
      return this.t('breakout_rooms.none_assigned');
    }
  }
  toggleCardDisplay() {
    this.showExpandedCard = !this.showExpandedCard;
  }
  glowCard() {
    this.glowingCard = true;
    setTimeout(() => {
      this.glowingCard = false;
    }, 2000);
  }
  onAssign() {
    this.onParticipantsAdd.emit();
    this.glowCard();
  }
  onJoin() {
    this.onRoomJoin.emit();
  }
  onTitleChanged(e) {
    if (e.key === 'Enter') {
      this.newTitle = e.target.value;
      this.onEditClick();
    }
  }
  renderPeer(participant) {
    const { displayPictureUrl: picture } = this.allParticipants.find((p) => participantIdentifier(p) === participantIdentifier(participant));
    const name = formatName(participant.displayName || '');
    return (h("div", { class: "peer-ui-container" }, h("dyte-avatar", { participant: { name, picture }, size: "sm" }), h("p", { class: "name", title: name }, shorten(name, 16), this.meeting.self.userId === participant.id && ` (${this.t('you')})`)));
  }
  renderExpandedCardMaybe() {
    if (!this.showExpandedCard)
      return;
    if (this.room.isParent)
      return;
    if (!this.getAssignmentHint())
      return;
    if (!this.permissions.canAlterConnectedMeetings)
      return;
    return (h("div", { class: "message-container" }, h("p", { class: { 'compact-height': this.room.participants.length !== 0 }, onClick: () => this.onAssign(), onDragOver: this.onDragOver, onDragLeave: this.onDragLeave, onDrop: this.onDrop }, this.getAssignmentHint())));
  }
  renderParticipantsMaybe() {
    if (!this.showExpandedCard)
      return;
    if (this.room.isParent)
      return;
    if (this.room.participants.length === 0)
      return;
    return (h("div", { class: "participant-list", onClick: () => {
        this.onAssign();
      } }, this.room.participants.map((participant) => (h("div", { class: "participant-item", role: "listitem", key: participant.id }, this.renderPeer(participant), this.permissions.canAlterConnectedMeetings && (h("dyte-icon", { class: "show-on-hover", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t, onClick: () => {
        this.onParticipantDelete.emit(participant);
      } })))))));
  }
  render() {
    var _a, _b, _c;
    return (h(Host, null, h("div", { class: {
        'assign-mode': this.assigningParticipants,
        'selector-mode': !this.assigningParticipants,
        'glowing-card': this.glowingCard,
      } }, h("div", { class: "header" }, h("input", { ref: (el) => (this.inputTextEl = el), placeholder: this.t('breakout_rooms.room_name'), disabled: !(this.editingTitleRoomId === this.room.id), value: this.roomTitle, minlength: ROOM_TITLE_MIN_CHARS, onChange: (e) => {
        this.newTitle = e.target.value;
      }, onKeyPress: (e) => this.onTitleChanged(e), class: { 'editing-enabled': this.editingTitleRoomId === this.room.id }, style: { width: `${this.roomTitle.length + 1}ch` } }), this.editingTitleRoomId !== this.room.id && (h("span", { class: "participant-count" }, "(", h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }), (_c = (_b = (_a = this.room) === null || _a === void 0 ? void 0 : _a.participants) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : '0', ")")), this.canEditMeetingTitle && (h("dyte-tooltip", { label: this.editingTitleRoomId === this.room.id
        ? this.t('breakout_rooms.save_room_name')
        : this.t('breakout_rooms.edit_room_name'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.editingTitleRoomId === this.room.id
        ? this.iconPack.checkmark
        : this.iconPack.edit, iconPack: this.iconPack, t: this.t, class: "show-on-hover", onClick: this.onEditClick }))), h("div", { class: "rooms-container" }, this.permissions.canAlterConnectedMeetings &&
      !this.room.isParent &&
      this.allowDelete && (h("dyte-tooltip", { label: this.t('breakout_rooms.delete'), class: "danger", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.delete, class: "show-on-hover", iconPack: this.iconPack, t: this.t, onClick: () => {
        this.deleteRoom.emit();
      } }))), this.assigningParticipants &&
      this.permissions.canAlterConnectedMeetings &&
      !this.room.isParent && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", class: "assign-button", size: "md", onClick: () => this.onAssign() }, this.t('breakout_rooms.assign'))), this.mode === 'edit' &&
      !this.assigningParticipants &&
      this.permissions.canSwitchConnectedMeetings && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", class: "assign-button", size: "md", disabled: this.room.id === this.meeting.meta.roomName, onClick: () => this.onJoin() }, this.room.id === this.meeting.meta.roomName
      ? this.t('joined')
      : this.t('join'))), !this.room.isParent && (h("dyte-icon", { icon: this.showExpandedCard ? this.iconPack.chevron_up : this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleCardDisplay() })))), this.renderExpandedCardMaybe(), this.renderParticipantsMaybe())));
  }
};
DyteBreakoutRoomManager.style = dyteBreakoutRoomManagerCss;

const dyteBreakoutRoomParticipantsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;height:100%;flex-direction:column;font-size:14px}:host input[type='checkbox']{margin:var(--dyte-space-0, 0px);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--dyte-border-radius-sm, 4px);position:relative;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;border-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}:host input[type='checkbox']:checked{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host input[type='checkbox']:checked::before{position:absolute;top:1px;left:1px;height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px);background-color:rgb(var(--dyte-colors-text-1000, 255 255 255));content:'';-webkit-clip-path:polygon(5% 60%, 35% 93%, 100% 19%, 86% 4%, 36% 62%, 19% 44%);clip-path:polygon(5% 60%, 35% 93%, 100% 19%, 86% 4%, 36% 62%, 19% 44%)}*{box-sizing:border-box}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.ctr{box-sizing:border-box;padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);overflow-y:auto;flex-grow:1;flex-basis:0}.empty-message{margin-top:var(--dyte-space-10, 40px);margin-bottom:var(--dyte-space-10, 40px);text-align:center;font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.empty-room{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--dyte-space-2, 8px);height:100%;text-align:center;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.empty-room dyte-icon{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}.empty-room p{font-size:16px;font-weight:500;margin:var(--dyte-space-0, 0px)}.empty-room span{font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search-wrapper{margin-bottom:var(--dyte-space-1, 4px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.search{position:-webkit-sticky;position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-8, 32px)}.search .search-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search input{box-sizing:border-box;width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:inherit;color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.header{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-1\\.5, 6px);height:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-0\\.5, 2px);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));display:flex;align-items:center;justify-content:space-between}.title-wrapper{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.participant-count{display:flex;align-items:center;font-size:14px}.participant-count dyte-icon{margin-right:var(--dyte-space-0\\.5, 2px);width:var(--dyte-space-3, 12px)}.participant-item{display:flex;align-items:center;justify-content:space-between;margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);cursor:pointer}.participant-item input.hide-checkbox{display:none}.participant-item input:checked{display:inline-block}.dragging input{display:none}.participant-item:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.participant-item:hover input{display:inline-block}.peer-ui-container{position:relative;display:flex;align-items:center;gap:var(--dyte-space-2, 8px);height:var(--dyte-space-10, 40px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.peer-ui-container dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.peer-ui-container .name{font-size:14px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}";

const DyteBreakoutRoomParticipants = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onSelectedParticipantsUpdate = createEvent(this, "selectedParticipantsUpdate", 7);
    this.onAllToggled = createEvent(this, "allParticipantsToggleUpdate", 7);
    this.onParticipantsDragging = createEvent(this, "participantsDragging", 7);
    this.onSearchInput = (e) => {
      this.search = e.target.value;
    };
    this.onDragStart = (participant) => {
      this.isDragging = true;
      this.onParticipantsDragging.emit(true);
      this.updateSelectedParticipants(participant, true);
    };
    this.onDragEnd = (participant) => {
      this.isDragging = false;
      this.onParticipantsDragging.emit(false);
      this.updateSelectedParticipants(participant, false);
    };
    this.onClick = (participant) => {
      const selected = this.selectedParticipantIds.includes(participantIdentifier(participant));
      this.updateSelectedParticipants(participant, !selected);
    };
    this.onToggleAll = (checked) => {
      const selectedParticipants = checked ? this.participantsToShow.map(participantIdentifier) : [];
      this.onAllToggled.emit(selectedParticipants);
    };
    this.meeting = undefined;
    this.participantIds = [];
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.search = '';
    this.participantsToShow = [];
    this.selectedParticipantIds = [];
    this.isDragging = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.searchChanged(this.search);
  }
  disconnectedCallback() {
    if (this.meeting == null)
      return;
  }
  updateSelectedParticipants(participant, selected) {
    const id = participantIdentifier(participant);
    let selectedParticipants = [];
    if (selected && !this.selectedParticipantIds.includes(id)) {
      selectedParticipants = [...this.selectedParticipantIds, id];
    }
    else {
      selectedParticipants = [...this.selectedParticipantIds.filter((x) => x !== id)];
    }
    this.onSelectedParticipantsUpdate.emit(selectedParticipants);
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
    this.getParticipants(this.search);
  }
  participantsChanged() {
    this.getParticipants(this.search);
  }
  searchChanged(search) {
    this.getParticipants(search);
  }
  getParticipants(search) {
    const allParticipants = getAllConnectedParticipants(this.meeting);
    this.participantsToShow = allParticipants.filter((participant) => {
      var _a;
      return (this.participantIds.includes(participantIdentifier(participant)) &&
        ((_a = participant.displayName) !== null && _a !== void 0 ? _a : '').toLowerCase().includes(search.toLowerCase()));
    });
  }
  renderPeer(participant) {
    const name = formatName(participant.displayName || '');
    return (h("div", { class: "peer-ui-container" }, h("dyte-avatar", { participant: {
        name: participant.displayName,
        picture: participant.displayPictureUrl,
      }, size: "sm" }), h("p", { class: "name", title: name }, shorten(name, 16), this.meeting.self.userId === participant.id && ` (${this.t('you')})`)));
  }
  render() {
    return (h(Host, null, h("div", { class: "search-wrapper" }, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon", iconPack: this.iconPack, t: this.t, class: "search-icon" }), h("input", { type: "search", autocomplete: "off", placeholder: "Search", onInput: this.onSearchInput, part: "search-input" })), h("slot", { name: "shuffle-button" })), h("div", { class: "header" }, h("div", { class: "title-wrapper" }, h("span", null, this.t('breakout_rooms.main_room')), h("span", { class: "participant-count" }, "(", h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }), this.participantsToShow.length, ")")), this.selectedParticipantIds.length !== 0 && (h("dyte-tooltip", { label: this.t('breakout_rooms.select_all'), iconPack: this.iconPack, t: this.t }, h("input", { type: "checkbox", checked: this.selectedParticipantIds.length === this.participantsToShow.length, onChange: (e) => this.onToggleAll(!!e.target.checked) })))), h("div", { class: "ctr scrollbar", part: "container" }, this.participantsToShow.length > 0 && (h("ul", { class: "participants", part: "participants" }, this.participantsToShow.map((participant) => (h("li", { class: { 'participant-item': true, dragging: this.isDragging }, onClick: () => this.onClick(participant), onDragStart: () => this.onDragStart(participant), onDragEnd: () => this.onDragEnd(participant), draggable: this.selectedParticipantIds.length === 0, role: "listitem", key: participant.id }, this.renderPeer(participant), !this.isDragging && (h("input", { type: "checkbox", class: {
        'hide-checkbox': this.selectedParticipantIds.length === 0,
      }, checked: this.selectedParticipantIds.includes(participantIdentifier(participant)) }))))))), this.participantsToShow.length === 0 && this.search.length > 0 && (h("div", { class: "empty-message" }, this.t('participants.errors.empty_results'))), this.participantsToShow.length === 0 && this.search.length === 0 && (h("div", { class: "empty-room" }, h("dyte-icon", { icon: this.iconPack.people_checked, part: "search-icon", iconPack: this.iconPack, t: this.t, class: "search-icon" }), h("p", null, this.t('breakout_rooms.all_assigned')), h("span", null, this.t('breakout_rooms.empty_main_room')))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "participantIds": ["participantsChanged"],
    "search": ["searchChanged"]
  }; }
};
DyteBreakoutRoomParticipants.style = dyteBreakoutRoomParticipantsCss;

const dyteCounterCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;flex-direction:row;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-1, 4px)}p{margin:var(--dyte-space-0, 0px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}input{margin:var(--dyte-space-0, 0px);width:var(--dyte-space-6, 24px);padding:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;border-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));text-align:center;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));border-radius:var(--dyte-border-radius-sm, 4px);font-size:16px;outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{margin:var(--dyte-space-0, 0px);appearance:none;-webkit-appearance:none}input[type='number']{-moz-appearance:textfield}";

const DyteCounter = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onChange = createEvent(this, "valueChange", 7);
    this.input = '1';
    this.size = undefined;
    this.value = undefined;
    this.minValue = 0;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.watchStateHandler(this.input);
    this.input = this.value.toString();
  }
  watchStateHandler(input) {
    this.onChange.emit(input);
  }
  increment() {
    this.input = Math.max(parseInt(this.input) + 1, this.minValue).toString();
  }
  decrement() {
    this.input = Math.max(this.minValue, parseInt(this.input) - 1).toString();
  }
  render() {
    return (h(Host, null, h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.decrement(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.subtract, iconPack: this.iconPack, t: this.t })), h("input", { type: "number", value: this.input, min: this.minValue, onInput: (e) => {
        const val = parseInt(e.target.value, 10);
        if (isNaN(val) || val < this.minValue) {
          this.input = this.minValue.toString();
        }
        else {
          this.input = val.toString();
        }
      } }), h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.increment(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }))));
  }
  static get watchers() { return {
    "input": ["watchStateHandler"]
  }; }
};
DyteCounter.style = dyteCounterCss;

var dyteBreakoutRoomManager_3_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_breakout_room_manager: DyteBreakoutRoomManager,
    dyte_breakout_room_participants: DyteBreakoutRoomParticipants,
    dyte_counter: DyteCounter
});

const parseMessageForTarget = (message) => {
  let parsedMessage = null;
  try {
    const parsed = JSON.parse(message.message);
    const { target, message: m } = parsed;
    if (target === undefined || m === undefined) {
      parsedMessage = message;
    }
    else {
      parsedMessage = Object.assign(Object.assign({}, message), { targetUserIds: target, message: m });
    }
  }
  catch (error) {
    parsedMessage = message;
  }
  return parsedMessage;
};
function alphabeticalSorter(a, b) {
  return a.localeCompare(b);
}
/**
 * Generate a unique chat group key used in `<dyte-chat-messages-ui />`
 * @param ids An array of user ids
 * @returns A unique key from the user ids
 */
function generateChatGroupKey(ids) {
  return ids.sort((a, b) => a.localeCompare(b)).join('_');
}
function handleFilesDataTransfer(items, callback) {
  if (items == null)
    return;
  for (const item of items) {
    if (item.kind === 'file') {
      const file = item.getAsFile();
      if (item.type.startsWith('image/')) {
        callback('image', file);
      }
      else {
        callback('file', file);
      }
    }
  }
}
const TEMPORARY_CHANNEL_PREFIX = 'dm__';
function isDirectMessageChannel(channel) {
  return channel.isDirectMessage;
}
function getDMComparator(memberIds) {
  const uniqueMemberIds = [...new Set(memberIds)];
  return uniqueMemberIds.sort(alphabeticalSorter).join('<>');
}
function reverse(str) {
  return str.split('').reverse().join('');
}
const emailPattern = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
const boldPattern = /\*([^*]*)\*/g;
const italicsPattern = /_([^_]*)_/g;
const strikethroughPattern = /~([^~]*)~/g;
// Source: https://stackoverflow.com/a/8234912/2013580
const linkPattern = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w-]*))?)/;
const replyBlockPattern = /<blockquote>[.\s\S]*<\/blockquote>\n\n/m;
function extractReplyBlock(message, excludeTags = false) {
  if (!replyBlockPattern.test(message)) {
    return '';
  }
  let startOffset = 0;
  let endOffset = '</blockquote>'.length;
  if (excludeTags) {
    startOffset = '<blockquote>'.length;
    endOffset = 0;
  }
  return message.substring(message.indexOf('<blockquote>') + startOffset, message.indexOf('</blockquote>') + endOffset);
}
function stripOutReplyBlock(message) {
  return message.replace(replyBlockPattern, '');
}

const KNOWN_TAGS = ['<a>', '<b>', '<i>', '<q>', '<s>'];
function parseRichText(text) {
  let boldText = boldPattern.exec(text);
  while (boldText) {
    text = text.replace(boldText[0], `<b>${boldText[1]}</b>`);
    boldText = boldPattern.exec(text);
  }
  let italicsText = italicsPattern.exec(text);
  while (italicsText) {
    text = text.replace(italicsText[0], `<i>${italicsText[1]}</i>`);
    italicsText = italicsPattern.exec(text);
  }
  let strikethroughText = strikethroughPattern.exec(text);
  while (strikethroughText) {
    text = text.replace(strikethroughText[0], `<s>${strikethroughText[1]}</s>`);
    strikethroughText = strikethroughPattern.exec(text);
  }
  text = text
    .split(' ')
    .map((word) => {
    if (linkPattern.test(word)) {
      const res = linkPattern.exec(word);
      return word.replace(res[0], `<a>${res[0]}</a>`);
    }
    return word;
  })
    .join(' ');
  text = text
    .split(' ')
    .map((word, idx) => {
    if (word === '>' && (idx === 0 || word[idx - 1] === '>')) {
      return `<q></q>`;
    }
    return word;
  })
    .join(' ');
  const [tokens] = generateTokens(text);
  return tokens;
}
const generateTokens = (text, endTag = '') => {
  const tokens = [];
  if (text.length === 0) {
    return [tokens, 0];
  }
  let i = 0;
  while (i < text.length) {
    if (endTag.length && endTag === text.substring(i, i + endTag.length)) {
      return [tokens, i + endTag.length];
    }
    if (KNOWN_TAGS.includes(text.substring(i, i + 3))) {
      const [subtokens, pos] = generateTokens(text.substring(i + 3), `</${text[i + 1]}>`);
      tokens.push({
        type: text[i + 1],
        content: subtokens.length === 1 && subtokens[0].type === 'plain_text'
          ? subtokens[0].content
          : subtokens,
      });
      i += pos + 3;
    }
    else {
      let top = tokens[tokens.length - 1];
      if (!top || top.type !== 'plain_text') {
        tokens.push({ type: 'plain_text', content: '' });
        top = tokens[tokens.length - 1];
      }
      top.content += text[i];
      i++;
    }
  }
  return [tokens, i];
};
const restoreEmpty = (content, tag, renderCallback) => {
  return content.trim().length === 0 ? `${tag}${content}${tag}` : renderCallback(content);
};
const renderLink = (content) => {
  let link = content;
  if (emailPattern.test(link)) {
    link = `mailto:${link}`;
  }
  else if (/^(?![A-Za-z]{3,9}?:\/\/)/.test(link)) {
    // if link does not have protocol
    link = `https://${link}`;
  }
  return (h("a", { class: "link", href: link, target: "_blank", rel: "noopener noreferrer" }, content));
};
const renderBold = (content) => {
  if (typeof content === 'string') {
    return restoreEmpty(content, '*', (c) => h("b", null, c));
  }
  return h("b", null, renderTokens(content));
};
const renderItalic = (content) => {
  if (typeof content === 'string') {
    return restoreEmpty(content, '_', (c) => h("i", null, c));
  }
  return h("i", null, renderTokens(content));
};
const renderStrikethrough = (content) => {
  if (typeof content === 'string') {
    return restoreEmpty(content, '~', (c) => h("s", null, c));
  }
  return h("b", null, renderTokens(content));
};
const renderPlainText = (content) => {
  if (typeof content === 'string') {
    return content;
  }
  return h("p", null, renderTokens(content));
};
const renderTokens = (tokens) => {
  return tokens.map((token) => {
    switch (token.type) {
      case 'a':
        if (typeof token.content === 'string') {
          return renderLink(token.content);
        }
      case 'b':
        return renderBold(token.content);
      case 'i':
        return renderItalic(token.content);
      case 's':
        return renderStrikethrough(token.content);
      case 'q':
        return h("span", { class: "block-quote" });
      case 'plain_text':
      default:
        return renderPlainText(token.content);
    }
  });
};
const TextMessageView = ({ message }) => {
  const withReply = extractReplyBlock(message, true);
  const withoutReply = stripOutReplyBlock(message);
  return (h("p", null,
    withReply.length !== 0 && (h("blockquote", null, withReply.split('\n').map((line) => {
      const tokens = parseRichText(line);
      return h("p", null, renderTokens(tokens));
    }))),
    withoutReply.split('\n').map((line) => {
      const tokens = parseRichText(line);
      return h("p", null, renderTokens(tokens));
    })));
};

const dyteChatCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;height:100%;width:100%;flex-direction:column;font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin:var(--dyte-space-0, 0px);display:flex;height:var(--dyte-space-12, 48px);align-items:center;justify-content:center;font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}#dropzone{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:10;display:none;flex-direction:column;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}#dropzone.active{display:flex;-webkit-animation:0.2s slide-up ease-in;animation:0.2s slide-up ease-in}dyte-chat-messages-ui,dyte-chat-messages-ui-paginated{flex:1 0 0}.chat-container{display:flex;height:100%;width:100%;flex-direction:row}.chat{display:flex;flex:1 1 0%;flex-direction:column}.banner{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.banner .welcome-new-channel{width:var(--dyte-space-48, 192px)}.banner .create-channel-illustration{height:var(--dyte-space-40, 160px);width:var(--dyte-space-40, 160px)}.quoted-message-container{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);margin-top:var(--dyte-space-2, 8px);display:flex;justify-content:space-between;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-radius:var(--dyte-border-radius-md, 8px);border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}.quoted-message-container .quoted-message{flex:1 1 0%;padding:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);max-height:var(--dyte-space-24, 96px);overflow-y:auto;word-break:break-all}.quoted-message-container .quoted-message blockquote{display:none}.quoted-message-container dyte-icon.dismiss{margin-left:auto;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);padding:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.quoted-message-container dyte-icon.dismiss:hover{cursor:pointer;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.quoted-message-container dyte-icon.dismiss{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.channel-selector-header{box-sizing:border-box;height:var(--dyte-space-16, 64px);padding:var(--dyte-space-4, 16px);display:flex;justify-content:space-between;border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}.channel-selector-header .channel-create-btn{width:var(--dyte-space-8, 32px);justify-content:center}.channel-selector-header .channel-create-btn:hover{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}";

const DyteChat = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.channelMap = new Map();
    this.disconnectMeeting = (meeting) => {
      var _a, _b, _c, _d, _e, _f;
      if (this.isPrivateChatSupported()) {
        meeting === null || meeting === void 0 ? void 0 : meeting.participants.joined.removeListener('participantsUpdate', this.onParticipantUpdate);
        meeting === null || meeting === void 0 ? void 0 : meeting.participants.joined.removeListener('participantLeft', this.onParticipantUpdate);
      }
      (_a = meeting === null || meeting === void 0 ? void 0 : meeting.chat) === null || _a === void 0 ? void 0 : _a.removeListener('chatUpdate', this.chatUpdateListener);
      (_b = meeting === null || meeting === void 0 ? void 0 : meeting.chat) === null || _b === void 0 ? void 0 : _b.removeListener('channelCreate', this.onChannelCreateOrUpdate);
      (_c = meeting === null || meeting === void 0 ? void 0 : meeting.chat) === null || _c === void 0 ? void 0 : _c.removeListener('channelUpdate', this.onChannelCreateOrUpdate);
      (_d = meeting === null || meeting === void 0 ? void 0 : meeting.chat) === null || _d === void 0 ? void 0 : _d.removeListener('channelMessageUpdate', this.onChannelCreateOrUpdate);
      (_f = (_e = meeting === null || meeting === void 0 ? void 0 : meeting.participants) === null || _e === void 0 ? void 0 : _e.all) === null || _f === void 0 ? void 0 : _f.removeListener('participantsUpdate', this.onChannelCreateOrUpdate);
    };
    this.onParticipantUpdate = () => {
      this.participants = this.meeting.participants.joined
        .toArray()
        .filter((p) => this.privatePresetFilter.length === 0 || this.privatePresetFilter.includes(p.presetName));
      // if selected participant leaves, reset state to everyone
      if (this.selectedParticipant && !this.participants.includes(this.selectedParticipant)) {
        this.selectedParticipant = null;
        this.chatRecipientId = this.selectedGroup = 'everyone';
      }
    };
    this.usePaginatedChat = () => usePaginatedChat(this.meeting);
    this.updateUnreadCountGroups = (obj) => {
      this.unreadCountGroups = Object.assign(Object.assign({}, this.unreadCountGroups), obj);
    };
    this.isPrivateChatSupported = () => {
      var _a, _b, _c;
      return (!usePaginatedChat(this.meeting) &&
        this.canPrivateMessage &&
        !this.disablePrivateChat &&
        ((_c = (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__) === null || _b === void 0 ? void 0 : _b.features) === null || _c === void 0 ? void 0 : _c.getFeatureValue('chat_socket_server')) ===
          'socket-service');
    };
    this.updateRecipients = (event) => {
      if (typeof event.detail === 'string') {
        this.chatRecipientId = 'everyone';
        this.selectedParticipant = null;
      }
      else {
        const { userId } = event.detail;
        this.chatRecipientId = userId;
        this.selectedParticipant = this.participants.find((p) => p.userId === userId);
      }
      if (this.chatRecipientId !== 'everyone') {
        const allParticipants = [this.chatRecipientId, this.meeting.self.userId];
        const targetKey = generateChatGroupKey(allParticipants);
        this.selectedGroup = targetKey;
      }
      else {
        this.selectedGroup = 'everyone';
      }
      this.updateUnreadCountGroups({ [this.selectedGroup]: 0 });
    };
    this.isTextMessagingAllowed = () => {
      if (this.chatRecipientId === 'everyone') {
        // public chat
        return this.canSend && this.canSendTextMessage;
      }
      // private chat
      return this.canPrivateMessage && this.canSendPrivateTexts;
    };
    this.isFileMessagingAllowed = () => {
      if (this.chatRecipientId === 'everyone') {
        // public chat
        return this.canSend && this.canSendFiles;
      }
      // private chat
      return this.canPrivateMessage && this.canSendPrivateFiles;
    };
    this.onChannelChanged = (e) => {
      if (e.detail.includes(TEMPORARY_CHANNEL_PREFIX)) {
        this.createDMChannel(e.detail.replace(TEMPORARY_CHANNEL_PREFIX, ''));
      }
      else {
        this.selectedChannelId = e.detail;
      }
      this.cleanup();
    };
    this.createDMChannel = async (memberId) => {
      this.creatingChannel = true;
      const newChannel = await this.meeting.chat.createChannel('Direct Message', [memberId], {
        visibility: 'private',
        isDirectMessage: true,
      });
      this.creatingChannel = false;
      this.selectedChannelId = newChannel.id;
    };
    this.cleanup = () => {
      this.editingMessage = null;
      this.replyMessage = null;
      this.searchQuery = '';
    };
    this.onChannelCreateOrUpdate = (channel) => {
      if (channel) {
        this.channelMap.set(channel.id, channel);
      }
      else {
        this.meeting.chat.channels.forEach((chan) => this.channelMap.set(chan.id, chan));
      }
      const channels = Array.from(this.channelMap.values())
        .filter((channel) => !isDirectMessageChannel(channel))
        .sort((a, b) => alphabeticalSorter(a.displayName, b.displayName));
      const membersWithChannel = Array.from(this.channelMap.values())
        .filter(isDirectMessageChannel)
        .map((channel) => {
        return Object.assign(Object.assign({}, channel), { displayName: this.getMemberDisplayName(channel) });
      });
      const membersWithoutChannel = this.meeting.participants.all
        .toArray()
        .filter((member) => {
        if (member.userId === this.meeting.self.userId)
          return false;
        const matcher = getDMComparator([this.meeting.self.userId, member.userId]);
        return membersWithChannel.every((channel) => getDMComparator(channel.memberIds) !== matcher);
      })
        .map((member) => {
        return {
          id: `${TEMPORARY_CHANNEL_PREFIX}${member.userId}`,
          displayName: member.name,
          displayPictureUrl: member.picture,
          isDirectMessage: true,
          unreadCount: 0,
        };
      });
      const dms = [...membersWithChannel, ...membersWithoutChannel].sort((a, b) => alphabeticalSorter(a.displayName, b.displayName));
      this.channels = [...channels, ...dms];
    };
    this.getMemberDisplayName = (channel) => {
      var _a;
      let id;
      if (channel.memberIds.length === 1) {
        // channel with self
        id = channel.memberIds[0];
      }
      else {
        id =
          channel.memberIds[0] === this.meeting.self.userId
            ? channel.memberIds[1]
            : channel.memberIds[0];
      }
      const member = this.meeting.participants.all.toArray().find((member) => member.userId === id);
      return (_a = member === null || member === void 0 ? void 0 : member.name) !== null && _a !== void 0 ? _a : id;
    };
    this.onNewMessageHandler = async (e) => {
      const message = e.detail;
      if (this.isChatViewType) {
        await this.meeting.chat.sendMessageToChannel(message, this.selectedChannelId, this.replyMessage
          ? {
            replyTo: this.replyMessage,
          }
          : {});
        this.replyMessage = null;
      }
      else {
        this.meeting.chat.sendMessage(message, this.getRecipientPeerIds());
      }
    };
    this.onEditMessageHandler = async (e) => {
      var _a, _b;
      await ((_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.chat) === null || _b === void 0 ? void 0 : _b.editTextMessage(e.detail.id, e.detail.message, e.detail.channelId));
      this.editingMessage = null;
    };
    this.onSearchHandler = async (e) => {
      this.searchQuery = e.detail;
    };
    this.onSearchDismissed = () => {
      this.searchQuery = '';
    };
    this.onChannelCreateClicked = () => {
      this.stateUpdate.emit({ activeChannelCreator: true });
      state.activeChannelCreator = true;
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.disablePrivateChat = false;
    this.privatePresetFilter = [];
    this.unreadCountGroups = {};
    this.chatGroups = { everyone: [] };
    this.selectedGroup = 'everyone';
    this.now = new Date();
    this.dropzoneActivated = false;
    this.showLatestMessageButton = false;
    this.canSend = false;
    this.canSendTextMessage = false;
    this.canSendFiles = false;
    this.canPrivateMessage = false;
    this.canSendPrivateTexts = false;
    this.canSendPrivateFiles = false;
    this.emojiPickerEnabled = false;
    this.chatRecipientId = 'everyone';
    this.participants = [];
    this.selectedParticipant = undefined;
    this.channels = [];
    this.selectedChannelId = undefined;
    this.editingMessage = null;
    this.replyMessage = null;
    this.searchQuery = '';
    this.creatingChannel = false;
  }
  connectedCallback() {
    if (!this.meeting)
      return;
    this.meetingChanged(this.meeting);
    if (this.meeting && !this.meeting.chat) {
      return;
    }
    if (this.isFileMessagingAllowed()) {
      this.host.addEventListener('dragover', (e) => {
        e.preventDefault();
        this.dropzoneActivated = true;
      });
      this.host.addEventListener('dragleave', () => {
        this.dropzoneActivated = false;
      });
      this.host.addEventListener('drop', (e) => {
        e.preventDefault();
        this.dropzoneActivated = false;
        handleFilesDataTransfer(e.dataTransfer.items, (type, file) => {
          var _a, _b, _c, _d;
          switch (type) {
            case 'image':
              if (this.isFileMessagingAllowed()) {
                (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.chat) === null || _b === void 0 ? void 0 : _b.sendImageMessage(file, this.getRecipientPeerIds());
              }
              break;
            case 'file':
              if (this.isFileMessagingAllowed()) {
                (_d = (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.chat) === null || _d === void 0 ? void 0 : _d.sendFileMessage(file, this.getRecipientPeerIds());
              }
              break;
          }
        });
      });
    }
  }
  onEditMessageInit(event) {
    if (event.detail.flags.isReply) {
      this.replyMessage = event.detail.payload;
    }
    else if (event.detail.flags.isEdit) {
      this.editingMessage = event.detail.payload;
    }
  }
  disconnectedCallback() {
    this.disconnectMeeting(this.meeting);
  }
  meetingChanged(meeting, oldMeeting) {
    var _a, _b, _c, _d, _e;
    if (oldMeeting != undefined)
      this.disconnectMeeting(oldMeeting);
    if (meeting && !meeting.chat)
      return;
    if (meeting != null) {
      this.canSend = meeting.self.permissions.chatPublic.canSend;
      this.canSendTextMessage = meeting.self.permissions.chatPublic.text;
      this.canSendFiles = meeting.self.permissions.chatPublic.files;
      this.canPrivateMessage = !!(((_a = meeting.self.permissions.chatPrivate) === null || _a === void 0 ? void 0 : _a.canSend) ||
        ((_b = meeting.self.permissions.chatPrivate) === null || _b === void 0 ? void 0 : _b.canReceive));
      this.canSendPrivateTexts = !!((_c = meeting.self.permissions.chatPrivate) === null || _c === void 0 ? void 0 : _c.text);
      this.canSendPrivateFiles = !!((_d = meeting.self.permissions.chatPrivate) === null || _d === void 0 ? void 0 : _d.files);
      this.isChatViewType = meeting.meta.viewType === 'CHAT';
      if (this.isChatViewType) {
        this.onChannelCreateOrUpdate();
        const validChannels = this.channels.filter((channel) => !channel.id.includes(TEMPORARY_CHANNEL_PREFIX));
        if (validChannels.length) {
          this.selectedChannelId = this.channels[0].id;
        }
      }
      this.initializeChatGroups();
      // shallow copy to trigger render
      this.chatGroups = Object.assign({}, this.chatGroups);
      this.chatUpdateListener = ({ message }) => {
        if (message.channelId)
          return;
        this.addToChatGroup(message);
        // shallow copy to trigger render
        this.chatGroups = Object.assign({}, this.chatGroups);
      };
      this.onParticipantUpdate();
      if (!this.usePaginatedChat()) {
        (_e = meeting.chat) === null || _e === void 0 ? void 0 : _e.addListener('chatUpdate', this.chatUpdateListener);
      }
      if (this.isPrivateChatSupported()) {
        meeting.participants.joined.addListener('participantJoined', this.onParticipantUpdate);
        meeting.participants.joined.addListener('participantLeft', this.onParticipantUpdate);
      }
      if (this.isChatViewType) {
        meeting.chat.addListener('channelCreate', this.onChannelCreateOrUpdate);
        meeting.chat.addListener('channelUpdate', this.onChannelCreateOrUpdate);
        meeting.chat.addListener('channelMessageUpdate', this.onChannelCreateOrUpdate);
        meeting.participants.all.addListener('participantsUpdate', this.onChannelCreateOrUpdate);
      }
    }
  }
  chatGroupsChanged(chatGroups) {
    var _a, _b;
    if (!this.isPrivateChatSupported()) {
      return;
    }
    const unreadCounts = {};
    for (const key in chatGroups) {
      const lastReadTimestamp = (_a = chatUnreadTimestamps[key]) !== null && _a !== void 0 ? _a : 0;
      unreadCounts[key] = chatGroups[key].filter((c) => c.type == 'chat' &&
        c.message.time > lastReadTimestamp &&
        c.message.userId !== this.meeting.self.userId).length;
      if (key ===
        generateChatGroupKey([this.meeting.self.userId, (_b = this.selectedParticipant) === null || _b === void 0 ? void 0 : _b.userId]) ||
        (key === 'everyone' && this.selectedParticipant === null)) {
        unreadCounts[key] = 0;
        chatUnreadTimestamps[key] = new Date();
      }
    }
    this.updateUnreadCountGroups(unreadCounts);
  }
  initializeChatGroups() {
    var _a;
    (_a = this.meeting.chat) === null || _a === void 0 ? void 0 : _a.messages.forEach((message) => {
      this.addToChatGroup(message);
    });
  }
  addToChatGroup(message) {
    var _a;
    const parsedMessage = parseMessageForTarget(message);
    let key = 'everyone';
    if (((_a = parsedMessage.targetUserIds) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      const allParticipants = new Set([
        parsedMessage.userId,
        ...parsedMessage.targetUserIds,
      ]);
      key = generateChatGroupKey(Array.from(allParticipants));
    }
    if (this.chatGroups[key] === undefined)
      this.chatGroups[key] = [];
    this.chatGroups[key] = [
      ...this.chatGroups[key],
      { type: 'chat', message: parsedMessage },
    ];
  }
  getRecipientPeerIds() {
    let peerIds = [];
    if (this.chatRecipientId !== 'everyone') {
      peerIds = [this.selectedParticipant.id];
    }
    return peerIds;
  }
  channelSwitchListener(e) {
    this.onChannelChanged(e);
  }
  renderHeadlessComponents() {
    return (h(Fragment, null, h("dyte-dialog-manager", { meeting: this.meeting }), h("dyte-notifications", { meeting: this.meeting })));
  }
  renderComposerUI() {
    var _a, _b;
    if (this.isChatViewType && this.channels.length === 0)
      return null;
    if (this.isChatViewType && this.searchQuery !== '')
      return null;
    if (this.isChatViewType && !this.selectedChannelId)
      return null;
    const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
    const prefill = {};
    if (this.editingMessage) {
      prefill.editMessage = this.editingMessage;
    }
    else if (this.replyMessage) {
      prefill.replyMessage = this.replyMessage;
    }
    return (h("dyte-chat-composer-ui", Object.assign({ canSendTextMessage: this.isTextMessagingAllowed(), canSendFiles: this.isFileMessagingAllowed(), disableEmojiPicker: !!((_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__) === null || _b === void 0 ? void 0 : _b.features.hasFeature(FlagsmithFeatureFlags.DISABLE_EMOJI_PICKER)), members: this.meeting.participants.all.toArray(), prefill: prefill, channelId: this.selectedChannelId, onDyteNewMessage: this.onNewMessageHandler, onDyteEditMessage: this.onEditMessageHandler, onDyteEditCancelled: () => (this.editingMessage = null) }, uiProps), this.replyMessage && (h("div", { class: "quoted-message-container", slot: "chat-addon" }, h("div", { class: "quoted-message scrollbar" }, h(TextMessageView, { message: this.replyMessage.message })), h("div", null, h("dyte-icon", { "aria-label": this.t('dismiss'), class: "dismiss", icon: this.iconPack.dismiss, onClick: () => (this.replyMessage = null), iconPack: this.iconPack, t: this.t }))))));
  }
  renderFullChat() {
    if (this.creatingChannel) {
      return (h("div", { class: "banner" }, h("dyte-spinner", { size: "lg" })));
    }
    if (this.channels.length === 0 || !this.selectedChannelId) {
      return (h("div", { class: "banner" }, h("dyte-icon", { icon: this.iconPack.create_channel_illustration, iconPack: this.iconPack, t: this.t, slot: "start", class: 'create-channel-illustration' }), h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "wide", variant: "primary", size: "md", onClick: this.onChannelCreateClicked, class: "welcome-new-channel" }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t, slot: "start" }), h("span", null, this.t('chat.new_channel')))));
    }
    const selectedChannel = this.channels.find((channel) => channel.id === this.selectedChannelId);
    return (h("div", { class: "chat" }, h("dyte-channel-header", { slot: "header", meeting: this.meeting, channel: selectedChannel, onSearch: this.onSearchHandler, onSearchDismissed: this.onSearchDismissed }), this.searchQuery !== '' && (h("dyte-chat-search-results", { meeting: this.meeting, query: this.searchQuery, channelId: this.selectedChannelId })), this.searchQuery === '' && (h("dyte-chat-messages-ui-paginated", { meeting: this.meeting, size: this.size, iconPack: this.iconPack, t: this.t, selectedChannelId: this.selectedChannelId, selectedChannel: selectedChannel }))));
  }
  render() {
    var _a, _b;
    if (!this.meeting)
      return null;
    const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
    const selfUserId = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.userId;
    const chatMessages = this.chatGroups[this.selectedGroup] || [];
    return (h(Host, null, this.isChatViewType && this.renderHeadlessComponents(), h("div", { class: "chat-container" }, this.isChatViewType && (h("dyte-channel-selector-ui", { channels: this.channels, onChannelChanged: this.onChannelChanged, selectedChannelId: this.selectedChannelId, showRecentMessage: true }, h("div", { class: "channel-selector-header", slot: "header" }, h("dyte-logo", { meeting: this.meeting, config: this.config, t: this.t }), h("dyte-tooltip", { label: this.t('chat.new_channel'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", size: "md", onClick: this.onChannelCreateClicked, class: "channel-create-btn" }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t })))))), h("div", { class: "chat" }, this.isFileMessagingAllowed() && (h("div", { id: "dropzone", class: { active: this.dropzoneActivated }, part: "dropzone" }, h("dyte-icon", { icon: this.iconPack.attach, iconPack: this.iconPack, t: this.t }), h("p", null, this.t('chat.send_attachment')))), this.isPrivateChatSupported() && (h("dyte-chat-selector-ui", Object.assign({ selfUserId: selfUserId, groups: this.participants, selectedGroupId: (_b = this.selectedParticipant) === null || _b === void 0 ? void 0 : _b.userId, unreadCounts: this.unreadCountGroups, onDyteChatGroupChanged: this.updateRecipients }, uiProps))), this.isChatViewType ? (this.renderFullChat()) : this.usePaginatedChat() ? (h("dyte-chat-messages-ui-paginated", { meeting: this.meeting, size: this.size, iconPack: this.iconPack, t: this.t })) : (h("dyte-chat-messages-ui", Object.assign({ messages: chatMessages, selfUserId: selfUserId, selectedGroup: this.selectedGroup }, uiProps))), this.renderComposerUI()))));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "chatGroups": ["chatGroupsChanged"]
  }; }
};
DyteChat.style = dyteChatCss;

const dyteParticipantsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;height:100%;width:100%;flex-direction:column;font-size:14px}*{box-sizing:border-box}.ctr{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);box-sizing:border-box;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);overflow-y:auto;flex-grow:1;flex-basis:0}.search{position:-webkit-sticky;position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px)}.search dyte-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search input{box-sizing:border-box;height:var(--dyte-space-9, 36px);width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}:host([size='md']) .search{margin-top:var(--dyte-space-4, 16px) !important;margin-bottom:var(--dyte-space-4, 16px) !important}:host([size='sm']) .search{margin-top:var(--dyte-space-4, 16px) !important;margin-bottom:var(--dyte-space-4, 16px) !important}";

const DyteParticipants = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onSearchInput = (e) => {
      this.search = e.target.value;
    };
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.search = '';
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    if (this.meeting == null)
      return;
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      config: this.config,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    return (h(Host, null, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon", iconPack: this.iconPack, t: this.t }), h("input", { type: "search", autocomplete: "off", placeholder: "Search", onInput: this.onSearchInput, part: "search-input" })), h("div", { class: "ctr scrollbar", part: "container" }, h(Render, { element: "dyte-participants-waiting-list", defaults: defaults }), h(Render, { element: "dyte-participants-stage-queue", defaults: defaults }), h(Render, { element: "dyte-participants-stage-list", defaults: defaults, props: { search: this.search } }), h(Render, { element: "dyte-participants-viewer-list", defaults: defaults, props: { search: this.search } }))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteParticipants.style = dyteParticipantsCss;

const dytePluginsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;flex-direction:column;font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);display:block;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}ul{overflow-y:auto;padding:var(--dyte-space-0, 0px);flex-grow:1;flex-basis:0}.metadata{display:flex;align-items:center}.metadata img{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-sm, 4px)}.metadata .name{margin-left:var(--dyte-space-2, 8px);font-weight:500}.plugin{display:flex;align-items:center;justify-content:space-between;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.plugin .buttons{display:flex;align-items:center}dyte-button:hover{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-opacity:1;--tw-ring-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-ring-opacity));--tw-ring-offset-width:2px;--tw-ring-offset-color:rgb(var(--dyte-colors-background-1000, 8 8 8))}";

const DytePlugins = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.close = () => {
      this.stateUpdate.emit({ activeSidebar: false, sidebar: undefined });
      state.activeSidebar = false;
      state.sidebar = undefined;
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.plugins = [];
    this.canStartPlugins = false;
    this.canClosePlugin = false;
    this.activatedPluginsId = [];
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.plugins.all.removeListener('stateUpdate', this.updateActivePlugins);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      this.canStartPlugins = meeting.self.permissions.plugins.canStart;
      this.canClosePlugin = meeting.self.permissions.plugins.canClose;
      this.plugins = meeting.plugins.all
        .toArray()
        .filter((plugin) => { var _a; return !((_a = meeting.self.config.disabledPlugins) === null || _a === void 0 ? void 0 : _a.includes(plugin.id)); });
      this.updateActivePlugins = () => {
        this.activatedPluginsId = meeting.plugins.active.toArray().map((p) => p.id);
      };
      this.updateActivePlugins();
      meeting.plugins.all.addListener('stateUpdate', this.updateActivePlugins);
    }
  }
  render() {
    return (h(Host, null, h("ul", { class: "scrollbar" }, this.plugins.map((plugin) => (h("li", { key: plugin.name, class: "plugin" }, h("div", { class: "metadata" }, h("img", { src: plugin.picture }), h("div", { class: "name" }, plugin.name)), !this.activatedPluginsId.includes(plugin.id) && this.canStartPlugins && (h("div", { class: "buttons" }, h("dyte-button", { kind: "icon", size: "lg", iconPack: this.iconPack, t: this.t, onClick: () => {
        plugin.activate();
        this.close();
      }, "aria-label": `${this.t('activate')} ${plugin.name}` }, h("dyte-icon", { icon: this.iconPack.rocket, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t })))), this.activatedPluginsId.includes(plugin.id) && this.canClosePlugin && (h("div", { class: "buttons" }, h("dyte-button", { kind: "icon", size: "lg", onClick: () => {
        plugin.deactivate();
      }, iconPack: this.iconPack, t: this.t, "aria-label": `${this.t('close')} ${plugin.name}` }, h("dyte-icon", { icon: this.iconPack.dismiss, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }))))))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DytePlugins.style = dytePluginsCss;

const dytePollsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{margin-top:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;flex-direction:column;font-size:14px}*{box-sizing:border-box}.ctr{box-sizing:border-box;padding:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-0, 0px);display:flex;flex:1 1 0%;flex-direction:column}.polls-view{overflow-y:auto;flex:1 1 0%;flex-basis:0}";

const DytePolls$1 = class DytePolls {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onPollsUpdate = (data) => {
      this.polls = [...data.polls];
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.create = false;
    this.polls = undefined;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a;
    if (this.meeting == null)
      return;
    (_a = this.meeting.polls) === null || _a === void 0 ? void 0 : _a.removeListener('pollsUpdate', this.onPollsUpdate);
  }
  meetingChanged(meeting) {
    if (meeting == undefined)
      return;
    if (meeting && !meeting.polls)
      return;
    this.polls = [...meeting.polls.items];
    meeting.polls.addListener('pollsUpdate', this.onPollsUpdate);
    this.onCreate = async (data) => {
      this.create = false;
      await meeting.polls.create(data.question, data.options, data.anonymous, data.hideVotes);
    };
    this.onVote = async (id, index) => {
      await meeting.polls.vote(id, index);
    };
  }
  toggleCreateState() {
    this.create = !this.create;
  }
  componentDidRender() {
    smoothScrollToBottom(this.pollEl);
  }
  render() {
    return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("div", { class: "polls-view scrollbar", ref: (el) => (this.pollEl = el), part: "polls" }, this.polls.map((item) => {
      var _a;
      return (h("dyte-poll", { key: item.id, poll: item, onDyteVotePoll: (e) => {
          this.onVote(e.detail.id, e.detail.index);
        }, self: (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.userId, iconPack: this.iconPack, t: this.t, permissions: this.meeting.self.permissions }));
    }), this.create && (h("dyte-poll-form", { part: "poll-form", onDyteCreatePoll: (e) => {
        this.onCreate(e.detail);
      }, iconPack: this.iconPack, t: this.t }))), this.meeting.self.permissions.polls.canCreate && (h("dyte-button", { kind: "wide", onClick: () => this.toggleCreateState(), variant: this.create ? 'secondary' : 'primary', part: "button", iconPack: this.iconPack, t: this.t }, this.create ? this.t('polls.cancel') : this.t('polls.create'))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DytePolls$1.style = dytePollsCss;

const dyteSidebarUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;height:100%;width:100%;font-family:var(--dyte-font-family, sans-serif);z-index:50;display:flex;flex-direction:column}:host([view='sidebar']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}:host([view='full-screen']){position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);max-width:100%;border:none}::slotted(*){flex-grow:1}.close{position:absolute;top:var(--dyte-space-2, 8px);left:var(--dyte-space-2, 8px)}.main-header{display:flex;height:var(--dyte-space-12, 48px);place-items:center;justify-content:center}.main-header,.mobile-tabs{flex-shrink:0}.mobile-tabs{display:flex;place-items:center;justify-content:space-evenly;border-bottom:1px solid rgb(var(--dyte-colors-background-700, 44 44 44))}.mobile-tabs button{margin:var(--dyte-space-0, 0px);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;padding:var(--dyte-space-0, 0px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));height:var(--dyte-space-10, 40px);cursor:pointer;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);font-weight:500;border-bottom:1px solid transparent}.mobile-tabs button.active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}header h3{font-size:14px;font-weight:500}@media only screen and (max-device-height: 480px) and (orientation: landscape){.main-header{display:none !important}}";

const DyteSidebarUi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tabChange = createEvent(this, "tabChange", 7);
    this.sidebarClose = createEvent(this, "sidebarClose", 7);
    this.onClose = () => {
      this.sidebarClose.emit();
    };
    this.view = 'sidebar';
    this.tabs = [];
    this.currentTab = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    const isFullScreen = this.view === 'full-screen';
    const activeTab = this.tabs.find((tab) => tab.id === this.currentTab);
    return (h(Host, { class: this.view }, h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: this.onClose, "aria-label": this.t('close') }, h("dyte-icon", { icon: this.iconPack.dismiss })), activeTab && (h("header", { class: "main-header" }, h("h3", null, activeTab.name))), isFullScreen && (h("header", { class: "mobile-tabs" }, this.tabs.map((tab) => (h("button", { onClick: () => {
        this.tabChange.emit(tab.id);
      }, class: {
        active: this.currentTab === tab.id,
      } }, tab.name))))), h("slot", { name: this.currentTab })));
  }
};
DyteSidebarUi.style = dyteSidebarUiCss;

var dyteChat_5_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_chat: DyteChat,
    dyte_participants: DyteParticipants,
    dyte_plugins: DytePlugins,
    dyte_polls: DytePolls$1,
    dyte_sidebar_ui: DyteSidebarUi
});

const dyteDebuggerAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}.status{margin-left:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:12px}.status dyte-icon{margin-right:var(--dyte-space-2, 8px)}.scroll{overflow:auto;border-radius:var(--dyte-border-radius-none, 0)}.warning,.NOT_REQUESTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity)) !important;opacity:0.8}.success,.ACCEPTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity)) !important;opacity:0.8}.COULD_NOT_START,.error,.failed,.DENIED,.SYSTEM_DENIED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity)) !important;opacity:0.8}.row{display:flex;flex-direction:row;align-items:center;justify-content:flex-start}.section{display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start}h3{margin:var(--dyte-space-0, 0px);font-size:14px;font-weight:600}.stage-indicator{margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.status-text{margin-top:var(--dyte-space-3, 12px);font-size:14px;font-weight:100 !important}.status-text dyte-icon{margin-right:var(--dyte-space-2, 8px)}.tooltip-text{display:flex;flex-direction:column;font-size:12px}.tooltip-text span{margin-left:var(--dyte-space-1, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88)) !important}.tooltip-text div{margin-top:var(--dyte-space-1, 4px)}.tooltip-text div:nth-child(1){margin:var(--dyte-space-0, 0px)}.row{display:flex;flex-direction:row;align-items:center;justify-content:center}.row dyte-switch{margin-left:var(--dyte-space-8, 32px)}.row dyte-button{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px)}.row .label{width:var(--dyte-space-40, 160px)}.row .text{margin-top:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px)}.m3{margin-top:var(--dyte-space-3, 12px)}.m1{margin-top:var(--dyte-space-1, 4px)}.col{display:flex;width:100%;flex-direction:column;align-items:flex-start;justify-content:flex-start}.label{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;justify-content:space-between;font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.text{margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));opacity:0.7}.title{margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.sub-title{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.error-text{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;font-size:14px;font-weight:100 !important;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.error-text dyte-icon{margin-right:var(--dyte-space-2, 8px)}.volume-indicator{margin-left:var(--dyte-space-4, 16px);height:var(--dyte-space-3, 12px);width:var(--dyte-space-56, 224px);overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.volume-level{height:var(--dyte-space-3, 12px);width:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-400, 53 110 253) / var(--tw-bg-opacity));transition:width 0.5s}.stage-manager{position:-webkit-sticky;position:sticky;bottom:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);display:flex;flex-direction:row-reverse;align-items:center;justify-content:space-between;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-text-opacity))}.stage-button{display:flex;cursor:pointer;flex-direction:row;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}.stage-button dyte-icon{padding:var(--dyte-space-0, 0px)}.disabled{cursor:not-allowed;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52)) !important}#header{margin-top:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-evenly;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}#header dyte-button{border-bottom:var(--dyte-border-width-md, 2px) solid transparent;border-radius:var(--dyte-border-radius-none, 0)}#header dyte-button:hover{background-color:transparent}#header dyte-button.active{border-color:rgb(var(--dyte-colors-brand-400, 53 110 253))}.tab-body{display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto;padding:var(--dyte-space-4, 16px)}.speaker-test{margin-top:var(--dyte-space-4, 16px);display:flex;flex-direction:row}.speaker-test dyte-button{margin-right:var(--dyte-space-2, 8px)}";

const DyteDebuggerAudio$2 = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.testProgress = createEvent(this, "testProgress", 7);
    this.lowVolCount = 0;
    this.silenceCount = 0;
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.micMetadata = {};
    this.micPreview = false;
    this.speakerPreview = false;
    this.audioTrackStats = {
      lowVolume: false,
      clip: false,
      silence: false,
      volume: 0,
      timestamp: 0,
    };
    this.activeTab = 'Report';
    this.stage = 0;
    this.mediaPermission = 'NOT_REQUESTED';
    this.speakerDevice = undefined;
    this.speakerTest = 'none';
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.updateProgress();
  }
  disconnectedCallback() {
    var _a;
    const { self, troubleshoot } = this.meeting;
    this.micPreview && this.toggleMicTest();
    this.speakerPreview && this.toggleSpeakerTest();
    self === null || self === void 0 ? void 0 : self.removeListener('deviceUpdate', this.deviceUpdateListener);
    self === null || self === void 0 ? void 0 : self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    (_a = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.audio) === null || _a === void 0 ? void 0 : _a.removeListener('audioTrackStats', this.audioTrackUpdateListener);
  }
  async meetingChanged(meeting) {
    var _a, _b;
    if (!meeting)
      return;
    const { self, troubleshoot } = meeting;
    if (self === null || self === void 0 ? void 0 : self.audioTrack) {
      await this.getTrackInfo();
    }
    self === null || self === void 0 ? void 0 : self.on('deviceUpdate', this.deviceUpdateListener.bind(this));
    self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener.bind(this));
    const permission = (_a = self === null || self === void 0 ? void 0 : self.mediaPermissions) === null || _a === void 0 ? void 0 : _a.audio;
    this.mediaPermissionUpdateListener({ kind: 'audio', message: permission });
    (_b = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.audio) === null || _b === void 0 ? void 0 : _b.on('audioTrackStats', this.audioTrackUpdateListener.bind(this));
  }
  deviceUpdateListener({ device, preview }) {
    if (preview)
      return;
    if (device.kind === 'audioInput')
      this.speakerDevice = device;
    if (device.kind === 'audiooutput')
      this.getTrackInfo();
  }
  mediaPermissionUpdateListener({ kind, message }) {
    if (kind !== 'audio')
      return;
    this.mediaPermission = message;
    if (this.mediaPermission !== 'ACCEPTED') {
      this.stage = 0;
      this.updateProgress();
      if (this.micPreview)
        this.toggleMicTest();
      if (this.speakerPreview)
        this.toggleSpeakerTest();
    }
  }
  audioTrackUpdateListener(data) {
    this.audioTrackStats = Object.assign(Object.assign({}, data), { volume: this.normalizeVolume(data === null || data === void 0 ? void 0 : data.volume) });
    if (this.volumeEl)
      this.volumeEl.style.width = `${this.audioTrackStats.volume}%`;
  }
  setActiveTab(state) {
    this.activeTab = state;
    this.updateProgress();
  }
  async toggleMicTest() {
    var _a, _b, _c;
    const troubleshooter = (_a = this.meeting.troubleshoot) === null || _a === void 0 ? void 0 : _a.audio;
    this.micPreview = !this.micPreview;
    if (this.micPreview) {
      await this.getTrackInfo();
      troubleshooter.stopTrackAnalysis();
      await (troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.startTrackAnalysis(true));
    }
    else {
      (_c = (_b = this.meeting.troubleshoot) === null || _b === void 0 ? void 0 : _b.audio) === null || _c === void 0 ? void 0 : _c.stopTrackAnalysis();
      this.audioTrackStats.volume = 0;
      if (this.volumeEl)
        this.volumeEl.style.width = '5%';
    }
  }
  async toggleSpeakerTest() {
    var _a, _b, _c, _d;
    const troubleshooter = (_a = this.meeting.troubleshoot) === null || _a === void 0 ? void 0 : _a.audio;
    if ((_b = this.testAudioEl) === null || _b === void 0 ? void 0 : _b.paused) {
      this.testAudioEl.currentTime = 0.2;
      (_c = this.testAudioEl) === null || _c === void 0 ? void 0 : _c.play();
      this.speakerPreview = true;
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.startTrackAnalysis(true);
      this.testAudioEl.addEventListener('ended', () => {
        this.speakerPreview = false;
        troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopTrackAnalysis();
      });
    }
    else {
      (_d = this.testAudioEl) === null || _d === void 0 ? void 0 : _d.pause();
      this.speakerPreview = false;
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopTrackAnalysis();
    }
    if (this.speakerPreview) {
      const { self } = this.meeting;
      const speakerDevices = await (self === null || self === void 0 ? void 0 : self.getSpeakerDevices());
      if (!speakerDevices)
        return;
      this.speakerDevice = speakerDevices[0];
      self === null || self === void 0 ? void 0 : self.setDevice(speakerDevices[0]);
    }
  }
  async getTrackInfo() {
    var _a, _b;
    this.micMetadata = await ((_b = (_a = this.meeting.troubleshoot) === null || _a === void 0 ? void 0 : _a.audio) === null || _b === void 0 ? void 0 : _b.getTrackMetadata(true));
  }
  changeStage(stage) {
    if (this.mediaPermission !== 'ACCEPTED')
      return;
    stage = Math.max(0, stage);
    stage = Math.min(2, stage);
    this.stage = stage;
    this.updateProgress();
    if (this.micPreview)
      this.toggleMicTest();
    if (this.speakerPreview)
      this.toggleSpeakerTest();
  }
  updateProgress() {
    if (this.activeTab === 'Troubleshoot') {
      this.testProgress.emit(((this.stage + 1) * 100) / 3);
    }
    else
      this.testProgress.emit(0);
  }
  getAudioLevelStatus() {
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    if (this.detectLowVolume()) {
      message = 'Low volume detected, please move closer to the device.';
      icon = 'warning';
      style = 'warning';
    }
    if (this.audioTrackStats.clip) {
      message = 'Clipping detected. Your audio may be noisy.';
      icon = 'warning';
      style = 'error';
    }
    if (this.detectSilence()) {
      message = 'Silence detected. Your device is not picking up audio.';
      icon = 'warning';
      style = 'error';
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  getDeviceInformationStatus() {
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    const { channelCount: count, channelInterpretation: mode, channelType: type, outputs, } = this.micMetadata;
    if (mode === 'discrete' && outputs > count) {
      message = 'Audio quality might be degraded.';
      icon = 'warning';
      style = 'warning';
    }
    else if ((type === 'STEREO' && outputs === 1) ||
      (type === 'QUAD' && outputs === 1) ||
      (type === 'QUAD' && outputs === 2)) {
      message = 'Audio quality might be degraded.';
      icon = 'warning';
      style = 'warning';
    }
    if ((type === 'MONO' && count < 1) ||
      (type === 'STEREO' && count < 2) ||
      (type === 'QUAD' && count < 4)) {
      message = 'Looks like your device is not functioning properly.';
      icon = 'warning';
      style = 'error';
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  getSpeakerTestStatus() {
    if (this.speakerTest === 'success')
      return 'All systems are functional.';
    if (this.speakerTest === 'failed')
      return 'Test failed. Please ensure your system volume is not 0.';
  }
  setSpeakerTestResult(status) {
    if (this.speakerPreview)
      this.toggleSpeakerTest();
    this.speakerTest = status;
  }
  boolToStr(val) {
    if (val)
      return 'Yes';
    return 'No';
  }
  formatLabel(camelCaseLabel) {
    const result = camelCaseLabel.replace(/([A-Z])/g, ' $1');
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  normalizeVolume(val = 0) {
    let max = 0.3;
    const min = 0.001;
    if (val > max)
      max = val;
    return Math.max(5, Math.round((val * 100) / (max - min)));
  }
  detectLowVolume() {
    var _a;
    if ((_a = this.audioTrackStats) === null || _a === void 0 ? void 0 : _a.lowVolume) {
      this.lowVolCount++;
    }
    else {
      this.lowVolCount = 0;
    }
    return this.lowVolCount > 10;
  }
  detectSilence() {
    var _a;
    if ((_a = this.audioTrackStats) === null || _a === void 0 ? void 0 : _a.silence) {
      this.silenceCount++;
    }
    else {
      this.silenceCount = 0;
    }
    return this.silenceCount > 5;
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      iconPack: this.iconPack,
      t: this.t,
      size: this.size,
    };
    const deviceInfoKeys = ['label', 'channelType'];
    return (h(Host, null, h("audio", { preload: "auto", src: "https://assets.dyte.io/ui-kit/speaker-test.mp3", ref: (el) => (this.testAudioEl = el) }), h("div", { id: "header" }, ['Report', 'Troubleshoot'].map((section) => (h("dyte-button", { key: section, variant: "ghost", class: { active: this.activeTab === section }, onClick: () => this.setActiveTab(section), iconPack: this.iconPack, t: this.t }, this.t(section))))), this.activeTab === 'Troubleshoot' && (h("div", { class: "tab-body" }, h("div", null, h("div", { class: "stage-indicator" }, "Step ", this.stage + 1, "/3"), this.stage === 0 && (h("dyte-debugger-permissions-ui", Object.assign({}, defaults, { mediaType: "audio" }))), this.stage === 1 && (h("div", null, h("div", { class: "title" }, "Microphone Test"), h("div", { class: "text" }, this.t('Please start the microphone test and start speaking in order to test your audio device.')), h("dyte-button", { size: "md", onClick: () => this.toggleMicTest() }, this.micPreview ? 'Stop' : 'Start', " Microphone Test"), this.micPreview && (h("div", { class: "col" }, h("div", { class: "sub-title" }, "Device Information", h("dyte-information-tooltip", { iconPack: this.iconPack }, h("div", { slot: "tootlip-text", class: "tooltip-text" }, Object.keys(this.micMetadata).map((key) => (h("div", null, this.formatLabel(key), ": ", h("span", null, this.micMetadata[key]))))))), deviceInfoKeys.map((key) => {
      const val = this.micMetadata[key];
      if (!val)
        return;
      return (h("div", { class: "row" }, h("div", { class: "label" }, h("span", null, this.t(this.formatLabel(key))), ":"), h("div", { class: "text" }, this.t(val))));
    }), this.getDeviceInformationStatus(), h("div", { class: "sub-title" }, "Audio Level Analysis", h("dyte-information-tooltip", { iconPack: this.iconPack }, h("div", { slot: "tootlip-text", class: "tooltip-text" }, h("div", null, "Volume Level:", h("span", null, this.audioTrackStats.volume, "/100")), h("div", null, "Low Volume:", h("span", null, this.boolToStr(this.audioTrackStats.lowVolume))), h("div", null, "Silence Detected:", h("span", null, this.boolToStr(this.audioTrackStats.silence))), h("div", null, "Noise Detected:", h("span", null, this.boolToStr(this.audioTrackStats.clip))), h("div", null, "Time:", h("span", null, new Date(this.audioTrackStats.timestamp).toLocaleTimeString()))))), h("div", { class: "row" }, h("dyte-icon", { icon: this.iconPack.speaker, size: "md" }), h("div", { class: "volume-indicator" }, h("div", { class: "volume-level", ref: (el) => (this.volumeEl = el) }))), this.getAudioLevelStatus())))), this.stage === 2 && (h("div", { class: "col" }, h("div", { class: "title" }, "Speaker Test"), h("div", { class: "text" }, this.t('Upon starting this test, an audio will be played. Please ensure your system volume is not set to zero.')), h("dyte-button", { onClick: () => this.toggleSpeakerTest(), size: "md" }, this.speakerPreview ? 'Stop' : 'Start', " Speaker Test"), this.speakerDevice && (h("div", null, h("div", { class: "sub-title" }, "Device Information"), h("div", { class: "row" }, h("div", { class: "label" }, h("span", null, "Label"), ":"), h("div", { class: "text" }, this.speakerDevice.label)))), this.speakerPreview && (h("div", null, h("p", { class: "sub-title" }, "Are you able to hear the audio?"), h("div", { class: "speaker-test" }, h("dyte-button", { onClick: () => this.setSpeakerTestResult('success'), size: "sm", variant: "primary" }, "Yes"), h("dyte-button", { onClick: () => this.setSpeakerTestResult('failed'), size: "sm", variant: "secondary" }, "No")))), !this.speakerPreview && this.speakerTest !== 'none' && (h("div", { class: `row status-text ${this.speakerTest}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[this.speakerTest === 'failed' ? 'dismiss' : 'checkmark'] }), this.getSpeakerTestStatus()))))), h("div", { class: "stage-manager" }, this.stage < 2 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage + 1) }, "Next", h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_right }))), this.stage > 0 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage - 1) }, h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_left }), "Prev"))))), this.activeTab === 'Report' && (h("div", { class: "tab-body" }, h("dyte-debugger-issues-ui", Object.assign({}, defaults, { mediaType: "audio" }))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteDebuggerAudio$2.style = dyteDebuggerAudioCss;

const dyteDebuggerScreenshareCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}.status{margin-left:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:12px}.status dyte-icon{margin-right:var(--dyte-space-2, 8px)}.stage-indicator{margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.scroll{overflow:auto;border-radius:var(--dyte-border-radius-none, 0)}.warning,.NOT_REQUESTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity)) !important;opacity:0.8}.success,.ACCEPTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity)) !important;opacity:0.8}.COULD_NOT_START,.error,.DENIED,.SYSTEM_DENIED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity)) !important;opacity:0.8}h3{margin:var(--dyte-space-0, 0px);font-size:14px;font-weight:600}.status-text{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:100 !important}.status-text dyte-icon{margin-right:var(--dyte-space-2, 8px)}.tooltip-text{display:flex;flex-direction:column;font-size:12px}.tooltip-text span{margin-left:var(--dyte-space-1, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88)) !important}.tooltip-text div{margin-top:var(--dyte-space-1, 4px)}.tooltip-text div:nth-child(1){margin:var(--dyte-space-0, 0px)}.row{display:flex;width:100%;flex-direction:row;align-items:center;justify-content:flex-start}.row dyte-switch{margin-left:var(--dyte-space-8, 32px)}.row dyte-icon{margin-left:var(--dyte-space-2, 8px)}.row dyte-button{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px)}.row .label{width:var(--dyte-space-28, 112px) !important;min-width:var(--dyte-space-28, 112px)}.row .text{margin-top:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px)}.align-start{align-items:flex-start !important}.col{display:flex;width:100%;flex-direction:column;align-items:flex-start;justify-content:flex-start}.label{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;justify-content:space-between;font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.info{margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;font-size:14px;font-weight:100 !important;--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity));opacity:0.7}.info dyte-icon{margin-right:var(--dyte-space-2, 8px)}.text{margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));opacity:0.7}.title{margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.sub-title{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.stage-manager{margin-top:var(--dyte-space-4, 16px);display:flex;width:100%;flex-direction:row-reverse;align-items:center;justify-content:space-between;align-self:flex-end;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-text-opacity))}.stage-button{display:flex;cursor:pointer;flex-direction:row;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}.stage-button dyte-icon{padding:var(--dyte-space-0, 0px)}.disabled{cursor:not-allowed;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52)) !important}#header{margin-top:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-evenly;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}#header dyte-button{border-bottom:var(--dyte-border-width-md, 2px) solid transparent;border-radius:var(--dyte-border-radius-none, 0)}#header dyte-button:hover{background-color:transparent}#header dyte-button.active{border-color:rgb(var(--dyte-colors-brand-400, 53 110 253))}.tab-body{position:relative;display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto;padding:var(--dyte-space-4, 16px)}";

const DyteDebuggerAudio$1$1 = class DyteDebuggerAudio$1 {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.testProgress = createEvent(this, "testProgress", 7);
    this.lowVolCount = 0;
    this.silenceCount = 0;
    this.frozenFramesCount = 0;
    this.blackFramesCount = 0;
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.activeTab = 'Report';
    this.stage = 0;
    this.mediaPermission = 'NOT_REQUESTED';
    this.screenshareEnabled = false;
    this.audioTrackMetadata = {};
    this.videoTrackMetadata = {};
    this.screenshareTest = false;
    this.audioTrackStats = {
      lowVolume: false,
      clip: false,
      silence: false,
      volume: 0,
      timestamp: 0,
    };
    this.videoTrackStats = {
      isBlackFrame: false,
      isFrozenFrame: false,
      timestamp: 0,
      videoScore: 0,
    };
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.updateProgress();
  }
  disconnectedCallback() {
    var _a, _b;
    const { self, troubleshoot } = this.meeting;
    this.screenshareTest && this.toggleScreenshareTest();
    self === null || self === void 0 ? void 0 : self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    self.removeListener('screenShareUpdate', this.screenShareUpdateListener);
    (_a = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.screenshare) === null || _a === void 0 ? void 0 : _a.removeListener('audioTrackStats', this.audioTrackUpdateListener);
    (_b = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.screenshare) === null || _b === void 0 ? void 0 : _b.removeListener('videoTrackStats', this.videoTrackUpdateListener);
  }
  async meetingChanged(meeting) {
    var _a, _b, _c;
    if (!meeting)
      return;
    const { self, troubleshoot } = meeting;
    self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener.bind(this));
    self.addListener('screenShareUpdate', this.screenShareUpdateListener.bind(this));
    (_a = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.screenshare) === null || _a === void 0 ? void 0 : _a.on('audioTrackStats', this.audioTrackUpdateListener.bind(this));
    (_b = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.screenshare) === null || _b === void 0 ? void 0 : _b.on('videoTrackStats', this.videoTrackUpdateListener.bind(this));
    const permission = (_c = self === null || self === void 0 ? void 0 : self.mediaPermissions) === null || _c === void 0 ? void 0 : _c.screenshare;
    this.mediaPermissionUpdateListener({ kind: 'screenshare', message: permission });
    const screenShareEnabled = self === null || self === void 0 ? void 0 : self.screenShareEnabled;
    this.screenShareUpdateListener({ screenShareEnabled });
  }
  mediaPermissionUpdateListener({ kind, message }) {
    if (kind !== 'screenshare')
      return;
    this.mediaPermission = message;
    if (this.mediaPermission !== 'ACCEPTED') {
      this.stage = 0;
      this.updateProgress();
    }
  }
  screenShareUpdateListener({ screenShareEnabled }) {
    this.screenshareEnabled = screenShareEnabled;
    if (!this.screenshareEnabled && this.screenshareTest)
      this.toggleScreenshareTest();
  }
  audioTrackUpdateListener(stats) {
    this.audioTrackStats = Object.assign(Object.assign({}, stats), { volume: this.normalizeVolume(stats === null || stats === void 0 ? void 0 : stats.volume) });
  }
  videoTrackUpdateListener(stats) {
    this.videoTrackStats = Object.assign(Object.assign({}, stats), { videoScore: this.normalizeVideoScore(stats === null || stats === void 0 ? void 0 : stats.videoScore) });
  }
  async toggleScreenshareTest() {
    var _a, _b, _c;
    this.screenshareTest = !this.screenshareTest;
    const troubleshooter = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.troubleshoot.screenshare;
    if (this.screenshareTest && this.screenshareEnabled) {
      this.audioTrackMetadata = (_b = troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.getAudioTrackMetaData()) !== null && _b !== void 0 ? _b : {};
      this.videoTrackMetadata = (_c = troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.getVideoTrackMetaData()) !== null && _c !== void 0 ? _c : {};
      await troubleshooter.startAudioTrackAnalysis();
      await troubleshooter.startVideoTrackAnalysis();
    }
    else {
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopAudioTrackAnalysis();
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopVideoTrackAnalysis();
    }
  }
  setActiveTab(state) {
    this.activeTab = state;
    this.updateProgress();
  }
  changeStage(stage) {
    if (this.mediaPermission !== 'ACCEPTED')
      return;
    stage = Math.max(0, stage);
    stage = Math.min(1, stage);
    this.stage = stage;
    this.updateProgress();
    if (this.screenshareTest)
      this.toggleScreenshareTest();
  }
  updateProgress() {
    if (this.activeTab === 'Troubleshoot') {
      this.testProgress.emit(((this.stage + 1) * 100) / 2);
    }
    else
      this.testProgress.emit(0);
  }
  getDeviceInformationStatus() {
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    if (this.audioTrackMetadata) {
      const { channelCount: count, channelInterpretation: mode, channelType: type, outputs, } = this.audioTrackMetadata;
      if (mode === 'discrete' && outputs > count) {
        message = 'Audio quality might be degraded.';
        icon = 'warning';
        style = 'warning';
      }
      else if ((type === 'STEREO' && outputs === 1) ||
        (type === 'QUAD' && outputs === 1) ||
        (type === 'QUAD' && outputs === 2)) {
        message = 'Audio quality might be degraded.';
        icon = 'warning';
        style = 'warning';
      }
      if ((type === 'MONO' && count < 1) ||
        (type === 'STEREO' && count < 2) ||
        (type === 'QUAD' && count < 4)) {
        message = 'Looks like your device is not functioning properly.';
        icon = 'warning';
        style = 'error';
      }
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  getAudioAnalysisStatus() {
    var _a;
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    if (!((_a = this.audioTrackMetadata) === null || _a === void 0 ? void 0 : _a.label))
      return (h("div", { class: `row status-text warning` }, h("dyte-icon", { size: "sm", icon: this.iconPack.warning }), this.t('Not Available')));
    if (this.detectLowVolume()) {
      message = 'Low volume detected.';
      icon = 'warning';
      style = 'warning';
    }
    if (this.audioTrackStats.clip) {
      message = 'Your audio may be noisy.';
      icon = 'warning';
      style = 'error';
    }
    if (this.detectSilence()) {
      message = 'Silence detected.';
      icon = 'warning';
      style = 'error';
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  getVideoAnalysisStatus() {
    var _a, _b;
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    if ((_a = this.videoTrackStats) === null || _a === void 0 ? void 0 : _a.isBlackFrame) {
      this.blackFramesCount++;
    }
    else {
      this.blackFramesCount = 0;
    }
    if ((_b = this.videoTrackStats) === null || _b === void 0 ? void 0 : _b.isFrozenFrame) {
      this.frozenFramesCount++;
    }
    else {
      this.frozenFramesCount = 0;
    }
    if (this.frozenFramesCount > 4) {
      message = 'Looks like the video is frozen.';
      icon = 'warning';
      style = 'error';
    }
    if (this.blackFramesCount > 4) {
      message = 'Video is not being processed by the camera.';
      icon = 'warning';
      style = 'error';
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  formatLabel(camelCaseLabel) {
    const result = camelCaseLabel.replace(/([A-Z])/g, ' $1');
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  nullToStr(val) {
    if (!val)
      return 'Not Available';
    return val;
  }
  normalizeVolume(val = 0) {
    let max = 0.3;
    const min = 0.001;
    if (val > max)
      max = val;
    return Math.max(5, Math.round((val * 100) / (max - min)));
  }
  normalizeVideoScore(val = 0) {
    let max = 1;
    const min = 0;
    if (val > max)
      max = val;
    return Math.max(5, Math.round((val * 10) / (max - min)));
  }
  detectLowVolume() {
    var _a;
    if ((_a = this.audioTrackStats) === null || _a === void 0 ? void 0 : _a.lowVolume) {
      this.lowVolCount++;
    }
    else {
      this.lowVolCount = 0;
    }
    return this.lowVolCount > 10;
  }
  detectSilence() {
    var _a;
    if ((_a = this.audioTrackStats) === null || _a === void 0 ? void 0 : _a.silence) {
      this.silenceCount++;
    }
    else {
      this.silenceCount = 0;
    }
    return this.silenceCount > 5;
  }
  render() {
    var _a, _b;
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      iconPack: this.iconPack,
      t: this.t,
      size: this.size,
    };
    return (h(Host, null, h("div", { id: "header" }, ['Report', 'Troubleshoot'].map((section) => (h("dyte-button", { key: section, variant: "ghost", class: { active: this.activeTab === section }, onClick: () => this.setActiveTab(section), iconPack: this.iconPack, t: this.t }, this.t(section))))), this.activeTab === 'Troubleshoot' && (h("div", { class: "tab-body" }, h("div", null, h("div", { class: "stage-indicator" }, "Step ", this.stage + 1, "/2"), this.stage === 0 && (h("dyte-debugger-permissions-ui", Object.assign({}, defaults, { mediaType: "screenshare" }))), this.stage === 1 &&
      (this.screenshareEnabled ? (h("div", { class: "col" }, h("div", { class: "text" }, "Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots."), h("dyte-button", { onClick: () => this.toggleScreenshareTest() }, this.screenshareTest ? 'Stop' : 'Start', " Screenshare Tests"), this.screenshareTest && (h("div", null, h("div", { class: "sub-title" }, "Device Information", h("dyte-information-tooltip", null, h("div", { slot: "tootlip-text", class: "tooltip-text" }, Object.keys(this.audioTrackMetadata).map((key) => {
        if (key === 'label')
          return;
        return (h("div", null, "Audio ", this.formatLabel(key), ":", ' ', h("span", null, this.audioTrackMetadata[key])));
      }), Object.keys(this.videoTrackMetadata).map((key) => {
        if (key === 'label')
          return;
        return (h("div", null, "Video ", this.formatLabel(key), ":", ' ', h("span", null, JSON.stringify(this.videoTrackMetadata[key]))));
      })))), h("div", { class: "row align-start" }, h("div", { class: "label" }, h("span", null, "Audio Label"), ":"), h("div", { class: "text" }, this.nullToStr((_a = this.audioTrackMetadata) === null || _a === void 0 ? void 0 : _a.label))), h("div", { class: "row align-start" }, h("div", { class: "label" }, h("span", null, "Video Label"), ":"), h("div", { class: "text" }, this.nullToStr((_b = this.videoTrackMetadata) === null || _b === void 0 ? void 0 : _b.label))), this.getDeviceInformationStatus(), h("div", { class: "sub-title" }, "Device Analysis"), h("div", { class: "row " }, h("div", { class: "label" }, h("span", null, "Audio Analysis"), " :"), this.getAudioAnalysisStatus()), h("div", { class: "row" }, h("div", { class: "label" }, h("span", null, "Video Analysis"), " :"), this.getVideoAnalysisStatus()))))) : (h("div", { class: "col" }, h("div", { class: "info" }, h("dyte-icon", { size: "sm", icon: this.iconPack.warning }), "You are not sharing your screen."), h("div", { class: "text" }, "In order for us to test your screenshare, you need to be sharing your screen. You can enable screenshare from the control bar."))))), h("div", { class: "stage-manager" }, this.stage < 1 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage + 1) }, "Next", h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_right }))), this.stage > 0 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage - 1) }, h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_left }), "Prev"))))), this.activeTab === 'Report' && (h("div", { class: "tab-body" }, h("dyte-debugger-issues-ui", Object.assign({}, defaults, { mediaType: "screenshare" }))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteDebuggerAudio$1$1.style = dyteDebuggerScreenshareCss;

const dyteDebuggerVideoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}.status{margin-left:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:12px}.status dyte-icon{margin-right:var(--dyte-space-2, 8px)}.stage-indicator{margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.scroll{overflow:auto;border-radius:var(--dyte-border-radius-none, 0)}.warning,.NOT_REQUESTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity)) !important;opacity:0.8}.success,.ACCEPTED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity)) !important;opacity:0.8}.COULD_NOT_START,.error,.DENIED,.SYSTEM_DENIED{--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity)) !important;opacity:0.8}.row{display:flex;flex-direction:row;align-items:center;justify-content:flex-start}h3{margin:var(--dyte-space-0, 0px);font-size:14px;font-weight:600}.status-text{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:100 !important}.status-text dyte-icon{margin-right:var(--dyte-space-2, 8px)}.tooltip-text{display:flex;flex-direction:column;font-size:12px}.tooltip-text span{margin-left:var(--dyte-space-1, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88)) !important}.tooltip-text div{margin-top:var(--dyte-space-1, 4px)}.tooltip-text div:nth-child(1){margin:var(--dyte-space-0, 0px)}.row{display:flex;flex-direction:row;align-items:center;justify-content:center}.row dyte-switch{margin-left:var(--dyte-space-8, 32px)}.row dyte-button{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px)}.row .label{width:var(--dyte-space-40, 160px)}.row .text{margin-top:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px)}.col{display:flex;width:100%;flex-direction:column;align-items:flex-start;justify-content:flex-start}.label{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;justify-content:space-between;font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.text{margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));opacity:0.7}.title{margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.sub-title{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;align-items:center;font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.stage-manager{position:-webkit-sticky;position:sticky;bottom:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);display:flex;width:100%;flex-direction:row-reverse;align-items:center;justify-content:space-between;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-text-opacity))}.stage-button{display:flex;cursor:pointer;flex-direction:row;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}.stage-button dyte-icon{padding:var(--dyte-space-0, 0px)}.disabled{cursor:not-allowed;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52)) !important}.video-container{position:relative;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.no-video-preview{position:absolute;top:50%;left:50%;z-index:50;display:flex;height:var(--dyte-space-12, 48px);width:var(--dyte-space-12, 48px);align-items:center;justify-content:center;border-radius:50%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));translate:-50% -50%}.video-preview{margin-top:var(--dyte-space-1, 4px);aspect-ratio:16 / 9;height:var(--dyte-space-28, 112px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}video{transform:scaleX(-1)}#header{margin-top:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-evenly;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}#header dyte-button{border-bottom:var(--dyte-border-width-md, 2px) solid transparent;border-radius:var(--dyte-border-radius-none, 0)}#header dyte-button:hover{background-color:transparent}#header dyte-button.active{border-color:rgb(var(--dyte-colors-brand-400, 53 110 253))}.tab-body{display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto;padding:var(--dyte-space-4, 16px)}";

const DyteDebuggerAudio$3 = class DyteDebuggerAudio {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.testProgress = createEvent(this, "testProgress", 7);
    this.blackFramesCount = 0;
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.activeTab = 'Report';
    this.stage = 0;
    this.mediaPermission = 'NOT_REQUESTED';
    this.videoPreview = false;
    this.videoMetadata = {};
    this.videoTrackStats = {
      isBlackFrame: false,
      isFrozenFrame: false,
      timestamp: 0,
      videoScore: 0,
    };
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.updateProgress();
  }
  disconnectedCallback() {
    var _a;
    const { self, troubleshoot } = this.meeting;
    this.videoPreview && this.toggleVideoTest();
    self === null || self === void 0 ? void 0 : self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    (_a = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.video) === null || _a === void 0 ? void 0 : _a.removeListener('videoTrackStats', this.videoTrackUpdateListener);
  }
  async meetingChanged(meeting) {
    var _a, _b;
    if (!meeting)
      return;
    const { self, troubleshoot } = meeting;
    if (self === null || self === void 0 ? void 0 : self.videoTrack) {
      await this.getTrackInfo();
    }
    self === null || self === void 0 ? void 0 : self.on('deviceUpdate', this.deviceUpdateListner.bind(this));
    self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener.bind(this));
    const permission = (_a = self === null || self === void 0 ? void 0 : self.mediaPermissions) === null || _a === void 0 ? void 0 : _a.video;
    this.mediaPermissionUpdateListener({ kind: 'video', message: permission });
    (_b = troubleshoot === null || troubleshoot === void 0 ? void 0 : troubleshoot.video) === null || _b === void 0 ? void 0 : _b.on('videoTrackStats', this.videoTrackUpdateListener.bind(this));
  }
  mediaPermissionUpdateListener({ kind, message }) {
    if (kind !== 'video')
      return;
    this.mediaPermission = message;
    if (this.mediaPermission !== 'ACCEPTED') {
      this.stage = 0;
      this.updateProgress();
      if (this.videoPreview)
        this.toggleVideoTest();
    }
  }
  deviceUpdateListner({ device, preview }) {
    if (preview)
      return;
    if ((device === null || device === void 0 ? void 0 : device.kind) !== 'videoinput')
      return;
    this.getTrackInfo();
  }
  videoTrackUpdateListener(data) {
    this.videoTrackStats = Object.assign(Object.assign({}, data), { videoScore: this.normalizeVideoScore(data === null || data === void 0 ? void 0 : data.videoScore) });
  }
  setActiveTab(state) {
    this.activeTab = state;
    this.updateProgress();
  }
  async toggleVideoTest() {
    var _a, _b;
    this.videoPreview = !this.videoPreview;
    const troubleshooter = (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.troubleshoot) === null || _b === void 0 ? void 0 : _b.video;
    if (this.videoPreview) {
      const track = await (troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.startPreview());
      const stream = new MediaStream();
      if (!track)
        return;
      stream.addTrack(track);
      setTimeout(() => {
        this.videoEl.srcObject = stream;
      }, 500);
      this.getTrackInfo();
      await (troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.startTrackAnalysis());
    }
    else {
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopPreview();
      troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.stopTrackAnalysis();
      this.videoEl.srcObject = undefined;
    }
  }
  getTrackInfo() {
    var _a, _b;
    this.videoMetadata = (_b = (_a = this.meeting.troubleshoot) === null || _a === void 0 ? void 0 : _a.video) === null || _b === void 0 ? void 0 : _b.getTrackMetadata();
  }
  getAnalysisStatus() {
    var _a, _b;
    let message = 'All systems are functional.';
    let icon = 'checkmark';
    let style = 'success';
    if ((_a = this.videoTrackStats) === null || _a === void 0 ? void 0 : _a.isBlackFrame) {
      this.blackFramesCount++;
    }
    else {
      this.blackFramesCount = 0;
    }
    if ((_b = this.videoTrackStats) === null || _b === void 0 ? void 0 : _b.isFrozenFrame) {
      message = 'Looks like the video is frozen.';
      icon = 'warning';
      style = 'error';
    }
    if (this.blackFramesCount > 10) {
      message = 'Video is not being processed by the camera.';
      icon = 'warning';
      style = 'error';
    }
    return (h("div", { class: `row status-text ${style}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[icon] }), this.t(message)));
  }
  changeStage(stage) {
    if (this.mediaPermission !== 'ACCEPTED')
      return;
    stage = Math.max(0, stage);
    stage = Math.min(1, stage);
    this.stage = stage;
    this.updateProgress();
    if (this.videoPreview)
      this.toggleVideoTest();
  }
  updateProgress() {
    if (this.activeTab === 'Troubleshoot') {
      this.testProgress.emit(((this.stage + 1) * 100) / 2);
    }
    else
      this.testProgress.emit(0);
  }
  formatLabel(camelCaseLabel) {
    const result = camelCaseLabel.replace(/([A-Z])/g, ' $1');
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  boolToStr(val) {
    if (val)
      return 'Yes';
    return 'No';
  }
  normalizeVideoScore(val = 0) {
    let max = 1;
    const min = 0;
    if (val > max)
      max = val;
    return Math.max(5, Math.round((val * 10) / (max - min)));
  }
  render() {
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      iconPack: this.iconPack,
      t: this.t,
      size: this.size,
    };
    return (h(Host, null, h("div", { id: "header" }, ['Report', 'Troubleshoot'].map((section) => (h("dyte-button", { key: section, variant: "ghost", class: { active: this.activeTab === section }, onClick: () => this.setActiveTab(section), iconPack: this.iconPack, t: this.t }, this.t(section))))), this.activeTab === 'Troubleshoot' && (h("div", { class: "tab-body" }, h("div", null, h("div", { class: "stage-indicator" }, "Step ", this.stage + 1, "/2"), this.stage === 0 && (h("dyte-debugger-permissions-ui", Object.assign({}, defaults, { mediaType: "video" }))), this.stage === 1 && (h("div", null, h("div", { class: "title" }, "Camera Test"), h("div", { class: "text" }, this.t('Upon starting the Camera Test, a video preview will be enabled for you.')), h("dyte-button", { size: "md", onClick: () => this.toggleVideoTest() }, this.videoPreview ? 'Stop' : 'Start', " Camera Test"), this.videoPreview && this.videoMetadata && (h("div", { class: "col" }, h("div", { class: "sub-title" }, "Device Information", h("dyte-information-tooltip", { iconPack: this.iconPack }, h("div", { slot: "tootlip-text", class: "tooltip-text" }, Object.keys(this.videoMetadata).map((key) => (h("div", null, this.formatLabel(key), ":", h("span", null, JSON.stringify(this.videoMetadata[key])))))))), h("div", { class: "row" }, h("div", { class: "label" }, h("span", null, this.t('Device Label')), ":"), h("div", { class: "text" }, this.t(this.videoMetadata.label))), h("div", { class: "sub-title" }, "Video & Device Analysis", h("dyte-information-tooltip", { iconPack: this.iconPack }, h("div", { slot: "tootlip-text", class: "tooltip-text" }, h("div", null, "Video Score:", h("span", null, this.videoTrackStats.videoScore, "/10")), h("div", null, "Black Frame Detected:", h("span", null, this.boolToStr(this.videoTrackStats.isBlackFrame))), h("div", null, "Frozen Frame Detected:", h("span", null, this.boolToStr(this.videoTrackStats.isFrozenFrame))), h("div", null, "Time:", h("span", null, new Date(this.videoTrackStats.timestamp).toLocaleTimeString()))))), h("div", { class: "video-container" }, !this.videoPreview && (h("div", { class: "no-video-preview" }, h("dyte-icon", { icon: this.iconPack.video_off, size: "md" }))), h("video", { ref: (el) => (this.videoEl = el), autoPlay: true, playsInline: true, muted: true, class: "video-preview" })), this.getAnalysisStatus()))))), h("div", { class: "stage-manager" }, this.stage > 0 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage - 1) }, h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_left }), "Prev")), this.stage < 1 && (h("div", { class: { 'stage-button': true, disabled: this.mediaPermission !== 'ACCEPTED' }, onClick: () => this.changeStage(this.stage + 1) }, "Next", h("dyte-icon", { size: "sm", icon: this.iconPack.chevron_right })))))), this.activeTab === 'Report' && (h("div", { class: "tab-body" }, h("dyte-debugger-issues-ui", Object.assign({}, defaults, { mediaType: "video" }))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteDebuggerAudio$3.style = dyteDebuggerVideoCss;

var dyteDebuggerAudio_3_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_debugger_audio: DyteDebuggerAudio$2,
    dyte_debugger_screenshare: DyteDebuggerAudio$1$1,
    dyte_debugger_video: DyteDebuggerAudio$3
});

const dyteLivestreamIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex}:host[size='sm']{margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px)}.indicator{display:flex;flex-direction:row;align-items:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);-webkit-animation:blink 4s linear infinite;animation:blink 4s linear infinite}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([size='sm']) .indicator span{display:none}@-webkit-keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}@keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}";

const DyteLivestreamIndicator = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.setIsLivestreaming = (state) => {
      this.isLivestreaming = state === 'LIVESTREAMING';
    };
    this.meeting = undefined;
    this.size = undefined;
    this.t = useLanguage();
    this.isLivestreaming = undefined;
    this.iconPack = defaultIconPack;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b;
    (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.livestream) === null || _b === void 0 ? void 0 : _b.removeListener('livestreamUpdate', this.setIsLivestreaming);
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting == null)
      return;
    this.setIsLivestreaming((_a = this.meeting.livestream) === null || _a === void 0 ? void 0 : _a.state);
    (_b = this.meeting.livestream) === null || _b === void 0 ? void 0 : _b.on('livestreamUpdate', this.setIsLivestreaming);
  }
  render() {
    if (!showLivestream(this.meeting) || !this.isLivestreaming)
      return;
    return (h(Host, null, h("div", { class: "indicator", "aria-label": this.t('livestream.indicator'), part: "indicator" }, h("dyte-icon", { icon: this.iconPack.start_livestream, size: this.size }), h("span", null, this.t('LIVE')))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteLivestreamIndicator.style = dyteLivestreamIndicatorCss;

const dyteLivestreamPlayerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.player-container{position:relative;margin:var(--dyte-space-4, 16px);display:flex;flex-grow:1;align-items:center;justify-content:center;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px)}video{z-index:0;height:100%;width:100%;border-radius:var(--dyte-border-radius-md, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.loader{position:absolute;z-index:10;height:100%;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));display:flex;flex-direction:column;align-items:center;justify-content:center}p{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);font-size:16px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.latency-controls{position:absolute;bottom:var(--dyte-space-4, 16px);right:var(--dyte-space-4, 16px);z-index:20;display:flex;flex-direction:row;align-items:center}.sync-live-stream{cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);font-size:12px}.unmute-popup{position:absolute;z-index:30 !important;display:flex;width:var(--dyte-space-72, 288px);flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-4, 16px);text-align:center;max-width:70%}.unmute-popup h3{margin:var(--dyte-space-0, 0px);font-size:16px;font-weight:500}.unmute-popup p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);font-size:14px}";

const DyteLivestreamPlayer = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
    this.showLatencyIndicator = false;
    this.LoadPlayer = (player = this.ivsPlayer) => {
      if (this.player && player) {
        player.attachHTMLVideoElement(this.player);
        player.setAutoplay(true);
        player.setVolume(1);
      }
    };
    this.livestreamUpdateListener = (state) => {
      var _a, _b;
      this.livestreamState = state;
      if (state === 'LIVESTREAMING') {
        this.LoadPlayer();
        this.getPlaybackUrl();
        if (!((_b = (_a = this.meeting.__internals__) === null || _a === void 0 ? void 0 : _a.browserSpecs) === null || _b === void 0 ? void 0 : _b.isIOSMobile())) {
          this.fetchLatency();
          this.updateLatency = setInterval(this.fetchLatency, 2000);
        }
        store.enableSource('livestream-player');
      }
      else {
        this.showLatencyIndicator = false;
        if (this.updateLatency)
          clearInterval(this.updateLatency);
        store.disableSource('livestream-player');
      }
    };
    this.getLoadingState = () => {
      let loadingMessage = '';
      let isLoading = false;
      let showIcon = false;
      switch (this.livestreamState) {
        case 'IDLE':
          loadingMessage = this.t('livestream.idle');
          isLoading = true;
          showIcon = false;
          break;
        case 'STARTING':
          loadingMessage = this.t('livestream.starting');
          isLoading = true;
          showIcon = true;
          break;
        case 'STOPPING':
          loadingMessage = this.t('livestream.stopping');
          isLoading = true;
          showIcon = true;
          break;
        case 'LIVESTREAMING':
          if (this.playerState !== PlayerState.PLAYING) {
            loadingMessage = this.t('livestream.starting');
            showIcon = true;
            isLoading = true;
          }
          break;
        default:
          isLoading = false;
          loadingMessage = this.t('');
          showIcon = true;
          break;
      }
      return { isLoading, loadingMessage, showIcon };
    };
    this.getErrorState = () => {
      var _a, _b;
      let isError = false;
      let errorMessage = '';
      if (this.livestreamState !== 'LIVESTREAMING') {
        isError = false;
        errorMessage = this.t('');
        return { isError, errorMessage };
      }
      if (!this.isSupported) {
        isError = true;
        errorMessage = this.t('livestream.error.not_supported');
      }
      if (!this.playbackUrl) {
        isError = true;
        errorMessage = this.t('livestream.error.not_found');
      }
      if (this.playerError) {
        isError = true;
        errorMessage = this.t((_b = (_a = this.playerError) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'livestream.error.unknown');
      }
      return { isError, errorMessage };
    };
    this.fetchLatency = () => {
      if (this.ivsPlayer) {
        this.latency = this.ivsPlayer.getLiveLatency();
        this.meeting.__internals__.logger.info('IVS.Player.LivestreamLatency', {
          livestream: {
            latency: this.latency,
          },
        });
      }
    };
    this.stopRebuffer = (latency) => {
      this.ivsPlayer.setRebufferToLive(false);
      this.latency = latency;
      clearInterval(this.updateLatency);
      this.updateLatency = setInterval(this.fetchLatency, 2000);
    };
    this.resetSyncLivestream = () => {
      const latency = this.ivsPlayer.getLiveLatency();
      this.stopRebuffer(latency);
      this.dyteAPIError.emit({
        trace: this.t('livestreamPlayer.rebuffer.error'),
        message: this.t('livestream.error.sync'),
      });
    };
    this.syncLiveStream = () => {
      clearInterval(this.updateLatency);
      // set latency to -1, to show loading icon
      this.latency = -1;
      this.ivsPlayer.setRebufferToLive(true);
      // Reset after 15 seconds
      const resetTimeout = setTimeout(this.resetSyncLivestream, 15000);
      this.updateLatency = setInterval(() => {
        const latency = this.ivsPlayer.getLiveLatency();
        if (latency < 10) {
          // Stop dropping frames
          this.stopRebuffer(latency);
          clearTimeout(resetTimeout);
        }
      }, 1000);
    };
    this.meeting = undefined;
    this.size = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.playbackUrl = undefined;
    this.isSupported = true;
    this.playerState = PlayerState.IDLE;
    this.livestreamState = 'IDLE';
    this.playerError = undefined;
    this.latency = 0;
    this.audioPlaybackError = false;
  }
  AddPlayerListeners(player = this.ivsPlayer) {
    Object.values(Object.assign(Object.assign({}, PlayerEventType), PlayerState)).forEach((key) => {
      if (awsIvsPlayerEventsToIgnore.includes(key))
        return;
      player === null || player === void 0 ? void 0 : player.addEventListener(key, (event) => {
        var _a, _b, _c;
        if (key === PlayerState.IDLE ||
          key === PlayerState.PLAYING ||
          key === PlayerEventType.ERROR ||
          key === PlayerState.READY)
          this.playerState = key;
        if (key === PlayerEventType.ERROR) {
          this.playerError = event;
        }
        if (key === PlayerState.IDLE && player.isPaused()) {
          player.play();
        }
        if (key === PlayerEventType.AUDIO_BLOCKED) {
          this.audioPlaybackError = true;
        }
        if (this.playerState === PlayerState.PLAYING &&
          !((_b = (_a = this.meeting.__internals__) === null || _a === void 0 ? void 0 : _a.browserSpecs) === null || _b === void 0 ? void 0 : _b.isIOSMobile())) {
          this.showLatencyIndicator = true;
        }
        else
          this.showLatencyIndicator = false;
        this.meeting.__internals__.logger.info(`IVS.Player.${key}`, event);
        // Send selected data to CallStats
        if (isIvsPlayerCallStatsEvent.includes(key)) {
          (_c = this.meeting.__internals__.callStats) === null || _c === void 0 ? void 0 : _c.ivsPlayerEvent(key, event);
        }
      });
    });
  }
  getPlaybackUrl(player = this.ivsPlayer) {
    this.playbackUrl = this.meeting.livestream.playbackUrl;
    if (this.playbackUrl && player) {
      player.load(this.playbackUrl);
      player.play();
    }
  }
  onPlayerRef(el) {
    this.player = el;
    store.addSource('livestream-player', this.player, this.playbackUrl ? true : false);
    if (this.playbackUrl)
      store.enableSource('livestream-player');
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    window.onDyteLivestreamPlayer = (player) => {
      if (player) {
        this.isSupported = true;
        this.ivsPlayer = player;
        this.AddPlayerListeners(player);
        this.LoadPlayer(player);
        this.getPlaybackUrl(player);
      }
      else
        this.isSupported = false;
    };
    this.sendLatencyToCallStats = setInterval(() => {
      var _a;
      this.fetchLatency();
      (_a = this.meeting.__internals__.callStats) === null || _a === void 0 ? void 0 : _a.livestreamLatency(this.latency);
    }, 10000);
  }
  disconnectedCallback() {
    window.onDyteLivestreamPlayer = undefined;
    this.meeting.livestream.removeListener('livestreamUpdate', this.livestreamUpdateListener);
    clearInterval(this.sendLatencyToCallStats);
    this.ivsPlayer.load('');
    this.ivsPlayer = undefined;
    this.player = undefined;
  }
  async componentDidLoad() {
    const IVSPlayerImport = `
    import IVSPlayer from 'https://cdn.jsdelivr.net/npm/amazon-ivs-player@1.16.0/+esm'
    let player = undefined;
    if (IVSPlayer.isPlayerSupported) {
      player = IVSPlayer.create({
        wasmBinary:
          'https://unpkg.com/amazon-ivs-player@1.11.0/dist/assets/amazon-ivs-wasmworker.min.wasm',
        wasmWorker:
          'https://unpkg.com/amazon-ivs-player@1.11.0/dist/assets/amazon-ivs-wasmworker.min.js',
      });
    }
    window.onDyteLivestreamPlayer && window.onDyteLivestreamPlayer(player);
    `;
    const pScript = document.createElement('script');
    pScript.type = 'module';
    pScript.innerHTML = IVSPlayerImport;
    document.body.appendChild(pScript);
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
    this.livestreamState = this.meeting.livestream.state;
    if (this.livestreamState === 'LIVESTREAMING') {
      this.LoadPlayer();
      this.getPlaybackUrl();
      store.enableSource('livestream-player');
    }
    this.meeting.livestream.on('livestreamUpdate', this.livestreamUpdateListener);
  }
  render() {
    if (!showLivestream(this.meeting))
      return;
    const { isError, errorMessage } = this.getErrorState();
    const { isLoading, loadingMessage, showIcon } = this.getLoadingState();
    return (h(Host, null, h("div", { class: "player-container" }, h("video", { ref: (el) => this.onPlayerRef(el), playsInline: true }), this.audioPlaybackError && (h("div", { class: "unmute-popup" }, h("h3", null, this.t('audio_playback.title')), h("p", null, this.t('audio_playback.description')), h("dyte-button", { kind: "wide", onClick: () => {
        this.player.muted = false;
        this.audioPlaybackError = false;
      }, title: this.t('audio_playback'), iconPack: this.iconPack, t: this.t }, this.t('audio_playback')))), this.livestreamState === 'LIVESTREAMING' && this.showLatencyIndicator && (h("div", { class: "latency-controls" }, (this.latency > 10 || this.latency < 0) && (h("div", { class: "sync-live-stream", onClick: this.syncLiveStream }, this.latency === -1 ? (h("dyte-spinner", { id: "icon", part: "spinner", iconPack: this.iconPack, t: this.t, size: "sm" })) : (this.t('livestream.skip')))))), isError && (h("div", { class: "loader" }, h("dyte-icon", { icon: this.iconPack.warning, t: this.t }), h("p", null, errorMessage))), !isError && isLoading && (h("div", { class: "loader" }, showIcon && (h("dyte-spinner", { id: "icon", part: "spinner", iconPack: this.iconPack, t: this.t, size: "md" })), h("p", null, loadingMessage))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteLivestreamPlayer.style = dyteLivestreamPlayerCss;

const dyteViewerCountCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;height:var(--dyte-space-10, 40px);-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;font-size:14px}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([variant='embedded']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));opacity:0.5;margin-top:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:12px}:host([variant='embedded']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

const DyteViewerCount = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.disconnectMeeting = (meeting) => {
      var _a;
      if (meeting != null && this.countListener != null) {
        (_a = meeting.livestream) === null || _a === void 0 ? void 0 : _a.removeListener('viewerCountUpdate', this.countListener);
      }
    };
    this.meeting = undefined;
    this.variant = 'primary';
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.viewerCount = 0;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    this.disconnectMeeting(this.meeting);
  }
  meetingChanged(meeting, oldMeeting) {
    var _a;
    this.disconnectMeeting(oldMeeting);
    if (meeting != null) {
      this.countListener = () => {
        var _a;
        this.viewerCount = (_a = meeting.livestream) === null || _a === void 0 ? void 0 : _a.viewerCount;
      };
      this.countListener();
      (_a = meeting.livestream) === null || _a === void 0 ? void 0 : _a.addListener('viewerCountUpdate', this.countListener);
    }
  }
  render() {
    if (!showLivestream(this.meeting))
      return null;
    return (h(Host, { tabIndex: 0, role: "log", "aria-label": `${this.viewerCount} ${this.t('viewers')}` }, h("dyte-icon", { icon: this.iconPack.viewers, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t }), this.viewerCount, " ", this.t('viewers')));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteViewerCount.style = dyteViewerCountCss;

var dyteLivestreamIndicator_3_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_livestream_indicator: DyteLivestreamIndicator,
    dyte_livestream_player: DyteLivestreamPlayer,
    dyte_viewer_count: DyteViewerCount
});

const dyteSettingsAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{display:flex;width:100%;flex-direction:column}audio{visibility:hidden}label{-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:14px}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.row{display:flex;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}.dyte-select{width:100%;max-width:100%}dyte-audio-visualizer{flex-shrink:0}dyte-button{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}dyte-button dyte-icon{margin-right:var(--dyte-space-2, 8px)}";

const DyteSettingsAudio = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.stageStateListener = () => {
      this.updateCanProduce(this.meeting);
    };
    this.selfStageLeftListener = () => {
      this.canProduceAudio = false;
    };
    this.deviceListUpdateListener = ({ added, removed }) => {
      added.map((device) => {
        if (device.kind === 'audioinput')
          this.audioDevices = [...this.audioDevices, device];
        if (device.kind === 'audiooutput')
          this.speakerDevices = [...this.speakerDevices, device];
      });
      removed.map((device) => {
        if (device.kind === 'audioinput')
          this.audioDevices = this.audioDevices.filter((x) => x.deviceId !== device.deviceId);
        if (device.kind === 'audiooutput')
          this.speakerDevices = this.speakerDevices.filter((x) => x.deviceId !== device.deviceId);
      });
    };
    this.deviceUpdateListener = ({ device }) => {
      if (device.kind === 'audioinput') {
        this.audioDevices = [
          device,
          ...this.audioDevices.filter((x) => x.deviceId !== device.deviceId),
        ];
      }
      if (device.kind === 'audiooutput') {
        this.speakerDevices = [
          device,
          ...this.speakerDevices.filter((x) => x.deviceId !== device.deviceId),
        ];
      }
    };
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.audioDevices = [];
    this.speakerDevices = [];
    this.canProduceAudio = true;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.removeListener('joinStageRequestAccepted', this.stageStateListener);
    (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.removeListener('stageJoined', this.stageStateListener);
    (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('removedFromStage', this.stageStateListener);
    (_e = (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.stage) === null || _e === void 0 ? void 0 : _e.removeListener('stageStatusUpdate', this.stageStateListener);
    (_f = this.meeting) === null || _f === void 0 ? void 0 : _f.self.removeListener('stageLeft', this.selfStageLeftListener);
    (_g = this.meeting) === null || _g === void 0 ? void 0 : _g.self.removeListener('joinStageRequestRejected', this.stageStateListener);
    (_h = this.meeting) === null || _h === void 0 ? void 0 : _h.self.removeListener('deviceListUpdate', this.deviceListUpdateListener);
    (_j = this.meeting) === null || _j === void 0 ? void 0 : _j.self.removeListener('deviceUpdate', this.deviceUpdateListener);
  }
  updateCanProduce(meeting) {
    const { self, meta, stage } = meeting;
    const canProduceAudio = self.permissions.canProduceAudio === 'ALLOWED';
    const isWebinar = meta.viewType === 'WEBINAR';
    const isLiveStream = meta.viewType === 'LIVESTREAM';
    this.canProduceAudio = false;
    if (canProduceAudio) {
      this.canProduceAudio = true;
    }
    else if (isWebinar || isLiveStream) {
      const canRequestAudio = self.permissions.canProduceAudio === 'CAN_REQUEST';
      // If the peer can present or has approved request to present
      if (canRequestAudio &&
        ((isWebinar &&
          (self.webinarStageStatus === 'ON_STAGE' ||
            self.webinarStageStatus === 'ACCEPTED_TO_JOIN_STAGE')) ||
          (isLiveStream &&
            (stage.status === 'ON_STAGE' || stage.status === 'ACCEPTED_TO_JOIN_STAGE')))) {
        this.canProduceAudio = true;
      }
    }
  }
  meetingChanged(meeting) {
    if (meeting == null)
      return;
    writeTask(async () => {
      var _a, _b, _c, _d;
      const { self, stage } = meeting;
      const audioDevices = await meeting.self.getAudioDevices();
      const speakerDevices = await meeting.self.getSpeakerDevices();
      const currentAudioDevice = (_a = meeting.self.getCurrentDevices()) === null || _a === void 0 ? void 0 : _a.audio;
      const currentSpeakerDevice = (_b = meeting.self.getCurrentDevices()) === null || _b === void 0 ? void 0 : _b.speaker;
      this.updateCanProduce(meeting);
      self.addListener('joinStageRequestAccepted', this.stageStateListener);
      self.addListener('stageJoined', this.stageStateListener);
      self.addListener('removedFromStage', this.stageStateListener);
      stage === null || stage === void 0 ? void 0 : stage.addListener('stageStatusUpdate', this.stageStateListener);
      self.addListener('stageLeft', this.selfStageLeftListener);
      self.addListener('joinStageRequestRejected', this.stageStateListener);
      self.addListener('deviceListUpdate', this.deviceListUpdateListener);
      self.addListener('deviceUpdate', this.deviceUpdateListener);
      if (currentAudioDevice != undefined) {
        this.audioDevices = [
          (_c = audioDevices.find((device) => device.deviceId === currentAudioDevice.deviceId)) !== null && _c !== void 0 ? _c : currentAudioDevice,
          ...audioDevices.filter((device) => device.deviceId !== currentAudioDevice.deviceId),
        ];
      }
      else {
        this.audioDevices = audioDevices;
      }
      if (currentSpeakerDevice != undefined) {
        this.speakerDevices = [
          (_d = speakerDevices.find((device) => device.deviceId === currentSpeakerDevice.deviceId)) !== null && _d !== void 0 ? _d : currentSpeakerDevice,
          ...speakerDevices.filter((device) => device.deviceId !== currentSpeakerDevice.deviceId),
        ];
      }
      else {
        this.speakerDevices = speakerDevices;
      }
    });
  }
  testAudio() {
    var _a;
    (_a = this.testAudioEl) === null || _a === void 0 ? void 0 : _a.play();
  }
  setDevice(kind, deviceId) {
    var _a, _b;
    const device = kind === 'audio'
      ? this.audioDevices.find((d) => d.deviceId === deviceId)
      : this.speakerDevices.find((d) => d.deviceId === deviceId);
    if (device != null) {
      (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.setDevice(device);
      if (device.kind === 'audiooutput') {
        (_b = this.testAudioEl) === null || _b === void 0 ? void 0 : _b.setSinkId(device.deviceId);
      }
    }
  }
  render() {
    var _a, _b, _c;
    if (this.meeting == null)
      return null;
    let unnamedMicCount = 0;
    let unnamedSpeakerCount = 0;
    const currentDevices = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.getCurrentDevices();
    const states = this.states || state;
    const initialNotificationSoundsPreference = ((_b = states === null || states === void 0 ? void 0 : states.prefs) === null || _b === void 0 ? void 0 : _b.muteNotificationSounds) === true ||
      getPreference('mute-notification-sounds') === 'true';
    return (h(Host, null, h("audio", { preload: "auto", src: "https://assets.dyte.io/ui-kit/speaker-test.mp3", ref: (el) => (this.testAudioEl = el) }), this.canProduceAudio && (h("div", { class: "group", part: "microphone-selection" }, h("label", null, "Microphone (input)"), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice('audio', e.target.value) }, this.audioDevices.map(({ deviceId, label }) => {
      var _a;
      return (h("option", { value: deviceId, selected: ((_a = currentDevices.audio) === null || _a === void 0 ? void 0 : _a.deviceId) === deviceId }, label || `Microphone ${++unnamedMicCount}`));
    })), h("dyte-audio-visualizer", { participant: (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self, iconPack: this.iconPack, t: this.t })))), h("div", { class: "group", part: "speaker-selection" }, this.speakerDevices.length > 0 && (h("div", null, h("label", null, "Speaker (output)"), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice('speaker', e.target.value) }, this.speakerDevices.map(({ deviceId, label }) => {
      var _a;
      return (h("option", { value: deviceId, selected: ((_a = currentDevices.speaker) === null || _a === void 0 ? void 0 : _a.deviceId) === deviceId }, label || `Speaker ${++unnamedSpeakerCount}`));
    }))))), h("dyte-button", { variant: "secondary", onClick: () => this.testAudio(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.speaker, slot: "start", iconPack: this.iconPack, t: this.t }), "Test")), h("div", { class: "group", part: "notification-toggle" }, h("div", { class: "row" }, h("label", { htmlFor: "notification-toggle" }, "Notification sound"), h("dyte-switch", { id: "notification-toggle", checked: !initialNotificationSoundsPreference, onDyteChange: (e) => {
        var _a;
        const { checked } = e.target;
        const muteNotificationSounds = !checked;
        this.stateUpdate.emit({ prefs: { muteNotificationSounds } });
        state.prefs = Object.assign(Object.assign({}, ((_a = state.prefs) !== null && _a !== void 0 ? _a : {})), { muteNotificationSounds });
        setPreference('mute-notification-sounds', muteNotificationSounds);
      }, iconPack: this.iconPack, t: this.t })))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteSettingsAudio.style = dyteSettingsAudioCss;

const dyteSettingsVideoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{display:flex;width:100%;flex-direction:column}dyte-participant-tile{margin-left:auto;margin-right:auto;margin-bottom:var(--dyte-space-4, 16px);max-width:100%}#icon{padding-bottom:var(--dyte-space-1, 4px)}.apply-button{height:var(--dyte-space-10, 40px)}label{-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:14px}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.row{display:flex;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}";

const DyteSettingsVideo = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onVideoUpdate = (videoState) => {
      this.videoEnabled = videoState.videoEnabled;
    };
    this.deviceListUpdateListener = ({ added, removed }) => {
      added.map((device) => {
        if (device.kind !== 'videoinput')
          return;
        this.videoDevices = [...this.videoDevices, device];
      });
      removed.map((device) => {
        if (device.kind !== 'videoinput')
          return;
        this.videoDevices = this.videoDevices.filter((x) => x.deviceId !== device.deviceId);
      });
    };
    this.deviceUpdateListener = ({ device }) => {
      if (device.kind !== 'videoinput')
        return;
      this.videoDevices = [
        device,
        ...this.videoDevices.filter((x) => x.deviceId !== device.deviceId),
      ];
    };
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.videoDevices = [];
    this.currentDevice = undefined;
    this.videoEnabled = undefined;
  }
  componentDidLoad() {
    this.meetingChanged(this.meeting);
  }
  meetingChanged(meeting) {
    var _a, _b, _c;
    if (meeting == null)
      return;
    this.videoEnabled = meeting.self.videoEnabled;
    (_a = meeting.self) === null || _a === void 0 ? void 0 : _a.addListener('videoUpdate', this.onVideoUpdate);
    (_b = meeting.self) === null || _b === void 0 ? void 0 : _b.addListener('deviceListUpdate', this.deviceListUpdateListener);
    (_c = meeting.self) === null || _c === void 0 ? void 0 : _c.addListener('deviceUpdate', this.deviceUpdateListener);
    writeTask(async () => {
      var _a, _b;
      const videoDevices = await meeting.self.getVideoDevices();
      const currentVideoDevice = (_a = meeting.self.getCurrentDevices()) === null || _a === void 0 ? void 0 : _a.video;
      //  NOTE(callmetarush): Setting current video device to show on top of list
      if (currentVideoDevice != undefined) {
        this.videoDevices = [
          (_b = videoDevices.find((device) => device.deviceId === currentVideoDevice.deviceId)) !== null && _b !== void 0 ? _b : currentVideoDevice,
          ...videoDevices.filter((device) => device.deviceId !== currentVideoDevice.deviceId),
        ];
      }
      else {
        this.videoDevices = videoDevices;
      }
    });
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.meeting.self) === null || _a === void 0 ? void 0 : _a.removeListener('videoUpdate', this.onVideoUpdate);
    (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self.removeListener('deviceListUpdate', this.deviceListUpdateListener);
    (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.removeListener('deviceUpdate', this.deviceUpdateListener);
  }
  async setDevice(deviceId) {
    var _a;
    const device = this.videoDevices.find((d) => d.deviceId === deviceId);
    this.currentDevice = device;
    if (device != null) {
      await ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.setDevice(device));
    }
  }
  render() {
    var _a, _b;
    if (this.meeting == null)
      return null;
    let unnamedVideoCount = 0;
    const states = this.states || state;
    const initialMirrorPreference = ((_a = states === null || states === void 0 ? void 0 : states.prefs) === null || _a === void 0 ? void 0 : _a.mirrorVideo) === true || getPreference('mirror-video') === 'true';
    return (h(Host, null, h("div", { class: "group", part: "tile-preview" }, this.videoEnabled === true ? (h("dyte-participant-tile", { participant: (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.self, iconPack: this.iconPack, t: this.t, states: states, isPreview: true })) : (h("div", { class: "camera-off-helper" }, h("dyte-participant-tile", { participant: undefined }, h("div", null, h("dyte-icon", { id: "icon", icon: this.iconPack.video_off, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }), h("div", null, "Camera is off")))))), h("div", { class: "group", part: "camera-selection" }, h("label", null, "Camera"), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice(e.target.value) }, this.videoDevices.map(({ deviceId, label }) => (h("option", { value: deviceId }, label || `Camera ${++unnamedVideoCount}`)))))), h("div", { class: "group", part: "mirror-toggle" }, h("div", { class: "row" }, h("label", { htmlFor: "mirror-toggle" }, "Mirror my Video"), h("dyte-switch", { checked: initialMirrorPreference, iconPack: this.iconPack, t: this.t, onDyteChange: (e) => {
        var _a;
        const { checked } = e.target;
        this.stateUpdate.emit({ prefs: { mirrorVideo: checked } });
        state.prefs = Object.assign(Object.assign({}, ((_a = state.prefs) !== null && _a !== void 0 ? _a : {})), { mirrorVideo: checked });
        setPreference('mirror-video', checked);
      } })))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteSettingsVideo.style = dyteSettingsVideoCss;

var dyteSettingsAudio_2_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_settings_audio: DyteSettingsAudio,
    dyte_settings_video: DyteSettingsVideo
});

const dyteTabBarCss = ":host{box-sizing:border-box;display:flex;height:100%;width:var(--dyte-space-16, 64px);flex-direction:column;gap:var(--dyte-space-2, 8px);font-family:var(--dyte-font-family, sans-serif)}dyte-button{z-index:10}.col{display:flex;flex-direction:column;align-items:center}.tab{display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center;margin-bottom:var(--dyte-space-2, 8px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.tab.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}.tab img{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);border-radius:var(--dyte-border-radius-sm, 4px)}@media (orientation: portrait){:host([size='sm']){margin-top:var(--dyte-space-2, 8px);height:var(--dyte-space-16, 64px);width:100%;flex-direction:row;transition:all 0.3s linear}:host([size='md']){height:var(--dyte-space-24, 96px);width:100%;flex-direction:row;transition:all 0.3s linear}:host .tab{margin:var(--dyte-space-0, 0px)}}:host([size='sm']){flex-direction:column;margin-top:var(--dyte-space-4, 16px);height:var(--dyte-space-16, 64px);width:100%;flex-direction:row;gap:var(--dyte-space-2, 8px);overflow-x:auto}:host([size='sm']) .tab{margin:var(--dyte-space-0, 0px);text-overflow:clip;min-width:100px;height:40px}:host([size='sm']) .tab .col{display:flex;flex-direction:row;align-items:center;gap:var(--dyte-space-2, 8px)}:host([size='sm']) .tab .col img,:host([size='sm']) .tab .col dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([layout='column']){flex-direction:column}:host([layout='column']) .aside{flex:2;max-width:100%;width:100%}";

const DyteTabBar = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.tabChange = createEvent(this, "tabChange", 7);
    this.size = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.layout = 'row';
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.activeTab = undefined;
    this.tabs = [];
  }
  render() {
    return (h(Host, null, h("dyte-spotlight-indicator", { meeting: this.meeting, iconPack: this.iconPack, t: this.t, size: this.size }), this.tabs.map((tab) => {
      var _a, _b, _c, _d, _e;
      if (tab.type === 'screenshare') {
        const participant = tab.participant;
        const name = formatName(participant.name);
        return (h("dyte-button", { title: `${name}'s Screen Share`, key: tab.participant.id, kind: "icon", iconPack: this.iconPack, t: this.t, class: {
            tab: true,
            active: ((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.type) === 'screenshare' &&
              ((_b = this.activeTab) === null || _b === void 0 ? void 0 : _b.participant.id) === tab.participant.id,
          }, onClick: () => this.tabChange.emit(tab) }, h("div", { class: "center col" }, h("dyte-icon", { icon: this.iconPack.share_screen_person, iconPack: this.iconPack, t: this.t }), h("span", { class: "name" }, participant.id === ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self.id) ? this.t('you') : shorten(name, 6)))));
      }
      else if (tab.type === 'plugin') {
        const plugin = tab.plugin;
        return (h("dyte-button", { title: plugin.name, key: plugin.id, kind: "icon", iconPack: this.iconPack, t: this.t, class: {
            tab: true,
            active: ((_d = this.activeTab) === null || _d === void 0 ? void 0 : _d.type) === 'plugin' && ((_e = this.activeTab) === null || _e === void 0 ? void 0 : _e.plugin.id) === plugin.id,
          }, onClick: () => this.tabChange.emit(tab) }, h("div", { class: "center col" }, h("img", { src: plugin.picture }), h("span", { class: "name" }, shorten(plugin.name, 6)))));
      }
    })));
  }
};
DyteTabBar.style = dyteTabBarCss;

var dyteTabBar_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_tab_bar: DyteTabBar
});

/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {

});

emitter.on('somenamespace*', function (eventName, payloads) {

});

Please note that callbacks triggered by wildcard registered events also get
the event name as the first argument.
*/

var wildemitter = WildEmitter;

function WildEmitter() { }

WildEmitter.mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;

    prototype.isWildEmitter= true;

    // Listen on the given `event` with `fn`. Store a group name if present.
    prototype.on = function (event, groupName, fn) {
        this.callbacks = this.callbacks || {};
        var hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        func._groupName = group;
        (this.callbacks[event] = this.callbacks[event] || []).push(func);
        return this;
    };

    // Adds an `event` listener that will be invoked a single
    // time then automatically removed.
    prototype.once = function (event, groupName, fn) {
        var self = this,
            hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        function on() {
            self.off(event, on);
            func.apply(this, arguments);
        }
        this.on(event, group, on);
        return this;
    };

    // Unbinds an entire group
    prototype.releaseGroup = function (groupName) {
        this.callbacks = this.callbacks || {};
        var item, i, len, handlers;
        for (item in this.callbacks) {
            handlers = this.callbacks[item];
            for (i = 0, len = handlers.length; i < len; i++) {
                if (handlers[i]._groupName === groupName) {
                    //console.log('removing');
                    // remove it and shorten the array we're looping through
                    handlers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        return this;
    };

    // Remove the given callback for `event` or all
    // registered callbacks.
    prototype.off = function (event, fn) {
        this.callbacks = this.callbacks || {};
        var callbacks = this.callbacks[event],
            i;

        if (!callbacks) return this;

        // remove all handlers
        if (arguments.length === 1) {
            delete this.callbacks[event];
            return this;
        }

        // remove specific handler
        i = callbacks.indexOf(fn);
        if (i !== -1) {
            callbacks.splice(i, 1);
            if (callbacks.length === 0) {
                delete this.callbacks[event];
            }
        }
        return this;
    };

    /// Emit `event` with the given args.
    // also calls any `*` handlers
    prototype.emit = function (event) {
        this.callbacks = this.callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this.callbacks[event],
            specialCallbacks = this.getWildcardCallbacks(event),
            i,
            len,
            listeners;

        if (callbacks) {
            listeners = callbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, args);
            }
        }

        if (specialCallbacks) {
            len = specialCallbacks.length;
            listeners = specialCallbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, [event].concat(args));
            }
        }

        return this;
    };

    // Helper for for finding special wildcard event handlers that match the event
    prototype.getWildcardCallbacks = function (eventName) {
        this.callbacks = this.callbacks || {};
        var item,
            split,
            result = [];

        for (item in this.callbacks) {
            split = item.split('*');
            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
                result = result.concat(this.callbacks[item]);
            }
        }
        return result;
    };

};

WildEmitter.mixin(WildEmitter);

function getMaxVolume (analyser, fftBins) {
  var maxVolume = -Infinity;
  analyser.getFloatFrequencyData(fftBins);

  for(var i=4, ii=fftBins.length; i < ii; i++) {
    if (fftBins[i] > maxVolume && fftBins[i] < 0) {
      maxVolume = fftBins[i];
    }
  }
  return maxVolume;
}


var audioContextType;
if (typeof window !== 'undefined') {
  audioContextType = window.AudioContext || window.webkitAudioContext;
}
// use a single audio context due to hardware limits
var audioContext = null;
var hark = function(stream, options) {
  var harker = new wildemitter();

  // make it not break in non-supported browsers
  if (!audioContextType) return harker;

  //Config
  var options = options || {},
      smoothing = (options.smoothing || 0.1),
      interval = (options.interval || 50),
      threshold = options.threshold,
      play = options.play,
      history = options.history || 10,
      running = true;

  // Ensure that just a single AudioContext is internally created
  audioContext = options.audioContext || audioContext || new audioContextType();

  var sourceNode, fftBins, analyser;

  analyser = audioContext.createAnalyser();
  analyser.fftSize = 512;
  analyser.smoothingTimeConstant = smoothing;
  fftBins = new Float32Array(analyser.frequencyBinCount);

  if (stream.jquery) stream = stream[0];
  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {
    //Audio Tag
    sourceNode = audioContext.createMediaElementSource(stream);
    if (typeof play === 'undefined') play = true;
    threshold = threshold || -50;
  } else {
    //WebRTC Stream
    sourceNode = audioContext.createMediaStreamSource(stream);
    threshold = threshold || -50;
  }

  sourceNode.connect(analyser);
  if (play) analyser.connect(audioContext.destination);

  harker.speaking = false;

  harker.suspend = function() {
    return audioContext.suspend();
  };
  harker.resume = function() {
    return audioContext.resume();
  };
  Object.defineProperty(harker, 'state', { get: function() {
    return audioContext.state;
  }});
  audioContext.onstatechange = function() {
    harker.emit('state_change', audioContext.state);
  };

  harker.setThreshold = function(t) {
    threshold = t;
  };

  harker.setInterval = function(i) {
    interval = i;
  };

  harker.stop = function() {
    running = false;
    harker.emit('volume_change', -100, threshold);
    if (harker.speaking) {
      harker.speaking = false;
      harker.emit('stopped_speaking');
    }
    analyser.disconnect();
    sourceNode.disconnect();
  };
  harker.speakingHistory = [];
  for (var i = 0; i < history; i++) {
      harker.speakingHistory.push(0);
  }

  // Poll the analyser node to determine if speaking
  // and emit events if changed
  var looper = function() {
    setTimeout(function() {

      //check if stop has been called
      if(!running) {
        return;
      }

      var currentVolume = getMaxVolume(analyser, fftBins);

      harker.emit('volume_change', currentVolume, threshold);

      var history = 0;
      if (currentVolume > threshold && !harker.speaking) {
        // trigger quickly, short history
        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {
          history += harker.speakingHistory[i];
        }
        if (history >= 2) {
          harker.speaking = true;
          harker.emit('speaking');
        }
      } else if (currentVolume < threshold && harker.speaking) {
        for (var i = 0; i < harker.speakingHistory.length; i++) {
          history += harker.speakingHistory[i];
        }
        if (history == 0) {
          harker.speaking = false;
          harker.emit('stopped_speaking');
        }
      }
      harker.speakingHistory.shift();
      harker.speakingHistory.push(0 + (currentVolume > threshold));

      looper();
    }, interval);
  };
  looper();

  return harker;
};

/**
 * Draws audio visualizer of variant `bars`
 * @param canvas Canvas element
 * @param volume Current volume
 */
const drawBarsVisualizer = (canvas, volume) => {
  if (canvas == null) {
    return;
  }
  const nSlices = 3;
  const halfwaySlice = Math.round(nSlices / 2);
  const sample = [...Array(nSlices)].map((_, i) => {
    let index = i;
    if (index > halfwaySlice - 1) {
      index = nSlices - index - 1;
    }
    return Math.round(((index + 1) / (halfwaySlice + 1)) * volume);
  });
  const { width, height } = canvas;
  const context = canvas.getContext('2d');
  let x = 2;
  const sliceGraphicWidth = 4;
  const sliceWidth = (width * 1.0) / sample.length;
  const slicePadding = sliceWidth - sliceGraphicWidth;
  context.clearRect(0, 0, width, height);
  context.fillStyle = 'rgb(0,0,0,0.0)';
  context.fillRect(0, 0, width, height);
  const color = getComputedStyle(canvas).getPropertyValue('color');
  context.fillStyle = color;
  context.strokeStyle = color;
  context.lineCap = 'round';
  context.lineWidth = 4;
  context.beginPath();
  for (const item of sample) {
    const y = Math.min(-Math.abs(((item * 1.2) / 10) * height) + height / 2, height / 2 - 2.5);
    const sliceHeight = Math.max((height / 2 - y) * 2, 5);
    context.moveTo(x + slicePadding / 2, y);
    context.lineTo(x + slicePadding / 2, y + sliceHeight);
    x += sliceWidth;
  }
  context.stroke();
};

const dyteAudioVisualizerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:var(--dyte-space-6, 24px);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}canvas,dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){transform:scale(0.9)}canvas{display:none}canvas.visible{display:block}canvas.bars{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

const DyteAudioVisualizer = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.variant = 'bars';
    this.participant = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isScreenShare = false;
    this.audioEnabled = undefined;
    this.volume = 0;
  }
  connectedCallback() {
    this.participantChanged(this.participant);
  }
  componentDidLoad() {
    drawBarsVisualizer(this.visualizer, 0);
  }
  disconnectedCallback() {
    var _a, _b, _c;
    (_a = this.hark) === null || _a === void 0 ? void 0 : _a.stop();
    this.audioUpdateListener &&
      ((_b = this.participant) === null || _b === void 0 ? void 0 : _b.removeListener('audioUpdate', this.audioUpdateListener));
    this.screenShareUpdateListener &&
      ((_c = this.participant) === null || _c === void 0 ? void 0 : _c.removeListener('screenShareUpdate', this.screenShareUpdateListener));
  }
  participantChanged(participant) {
    if (participant != null) {
      this.audioUpdateListener = ({ audioEnabled, audioTrack }) => {
        var _a;
        (_a = this.hark) === null || _a === void 0 ? void 0 : _a.stop();
        if (audioEnabled && audioTrack != null) {
          this.audioEnabled = true;
          const stream = new MediaStream();
          stream.addTrack(audioTrack);
          this.calcVolume(stream);
          // initial draw with volume: 0
          drawBarsVisualizer(this.visualizer, 0);
        }
        else {
          this.volume = 0;
          this.audioEnabled = false;
        }
      };
      if (this.isScreenShare) {
        this.screenShareUpdateListener = ({ screenShareEnabled, screenShareTracks }) => {
          this.audioUpdateListener({
            audioEnabled: screenShareEnabled && screenShareTracks.audio != null,
            audioTrack: screenShareTracks.audio,
          });
        };
        this.screenShareUpdateListener(participant);
        participant.addListener('screenShareUpdate', this.screenShareUpdateListener);
      }
      else {
        this.audioUpdateListener(participant);
        participant.addListener('audioUpdate', this.audioUpdateListener);
      }
    }
  }
  /**
   * Determines the volume from a given MediaStream and updates the components state
   * @param stream A MediaStream with AudioTrack(s) added
   */
  calcVolume(stream) {
    this.hark = hark(stream, {
      play: false,
      interval: 1000 / 10,
    });
    this.hark.on('volume_change', (dBs) => {
      const prevVolume = this.volume;
      // The exact formula to convert from dBs (-100..0) to linear (0..1) is:
      //   Math.pow(10, dBs / 20)
      // However it does not produce a visually useful output, so let exagerate
      // it a bit. Also, let convert it from 0..1 to 0..10 and avoid value 1 to
      // minimize component renderings.
      // if dBs is -Inifnity, set vol to 0
      let audioVol = Math.round(10 ** (dBs / 115) * 10);
      if (audioVol < 3)
        audioVol = 0;
      let volume = Math.round((prevVolume * 2 + audioVol) / 3);
      if (prevVolume !== volume) {
        this.volume = volume;
        drawBarsVisualizer(this.visualizer, this.volume);
      }
    });
  }
  render() {
    return (h(Host, null, h("canvas", { width: "24", height: "24", class: {
        bars: true,
        visible: this.audioEnabled,
      }, ref: (el) => (this.visualizer = el), part: "canvas" }), !this.isScreenShare && !this.audioEnabled && (h("dyte-icon", { icon: this.iconPack.mic_off, part: "mic-off-icon", iconPack: this.iconPack, t: this.t }))));
  }
  static get watchers() { return {
    "participant": ["participantChanged"]
  }; }
};
DyteAudioVisualizer.style = dyteAudioVisualizerCss;

const dyteSwitchCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:inline-flex;height:var(--dyte-space-6, 24px);width:var(--dyte-space-10, 40px);align-items:center;padding:var(--dyte-space-1, 4px);border-radius:9999px;background-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));cursor:pointer}.switch{box-sizing:border-box;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);background-color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:9999px;transition-property:var(--dyte-transition-property, all);transition-duration:200ms}:host(.checked){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host(.checked) .switch{transform:translateX(100%)}:host([readonly]),:host([disabled]){cursor:not-allowed;opacity:0.6}";

const DyteSwitch = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dyteChange = createEvent(this, "dyteChange", 4);
    this.onClick = () => {
      if (!this.readonly && !this.disabled) {
        this.checked = !this.checked;
      }
    };
    this.onKeyPress = (e) => {
      if (this.readonly)
        return;
      switch (e.key) {
        // Enter or Space
        case 'Enter':
        case ' ':
          this.checked = !this.checked;
          break;
      }
    };
    this.checked = false;
    this.readonly = false;
    this.disabled = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.checkedChange(this.checked);
  }
  checkedChange(checked) {
    this.checked = checked;
    this.dyteChange.emit(checked);
  }
  render() {
    return (h(Host, { role: "switch", tabIndex: this.disabled && 0, "aria-readonly": this.readonly, "aria-checked": this.checked, "aria-disabled": this.disabled, class: { checked: this.checked }, onClick: this.onClick, onKeyPress: this.onKeyPress }, h("div", { class: "switch", part: "switch" })));
  }
  static get watchers() { return {
    "checked": ["checkedChange"]
  }; }
};
DyteSwitch.style = dyteSwitchCss;

var dyteAudioVisualizer_2_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_audio_visualizer: DyteAudioVisualizer,
    dyte_switch: DyteSwitch
});

const SOUNDS = {
  joined: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_join.mp3',
  left: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_join.mp3',
  message: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_message.mp3',
};
/**
 * Handles notification sounds in a meeting
 */
class DyteNotificationsAudio {
  constructor() {
    this.audio = document.createElement('audio');
    this.audio.volume = 0.3;
  }
  play(sound, duration = 3000) {
    var _a;
    if (this.playing)
      return;
    this.playing = true;
    this.audio.src = SOUNDS[sound];
    this.audio.volume = 0.3;
    (_a = this.audio.play()) === null || _a === void 0 ? void 0 : _a.catch((err) => {
      logger.error('[dyte-notifications] play() failed\n', { sound, duration }, err);
    });
    setTimeout(() => {
      this.playing = false;
    }, duration);
  }
  async setDevice(id) {
    var _a, _b, _c;
    await ((_c = (_b = (_a = this.audio) === null || _a === void 0 ? void 0 : _a.setSinkId) === null || _b === void 0 ? void 0 : _b.call(_a, id)) === null || _c === void 0 ? void 0 : _c.catch((err) => {
      logger.error('[dyte-notifications] setSinkId() error\n', err);
    }));
  }
}

const dyteChannelDetailsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-72, 288px);padding-top:var(--dyte-space-5, 20px);padding-bottom:var(--dyte-space-5, 20px);padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px)}header{font-size:20px}dyte-spinner{margin-top:var(--dyte-space-10, 40px);margin-bottom:var(--dyte-space-10, 40px);margin-left:auto;margin-right:auto}ul{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-6, 24px);margin-bottom:var(--dyte-space-4, 16px);height:var(--dyte-space-48, 192px);padding:var(--dyte-space-0, 0px);overflow-y:auto;list-style-type:none;display:flex;flex-direction:column;gap:var(--dyte-space-2, 8px)}ul li{margin-right:var(--dyte-space-2, 8px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}ul li:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}ul li dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

const DyteChannelDetails = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.channel = undefined;
    this.t = useLanguage();
    this.iconPack = defaultIconPack;
    this.members = [];
  }
  renderMembers() {
    return (h("ul", { class: "scrollbar" }, this.members.map((member) => {
      return (h("li", null, h("dyte-avatar", { participant: { name: member.name, picture: member.picture }, size: "sm" }), h("span", null, member.name)));
    })));
  }
  render() {
    return (h(Host, null, h("header", null, this.t('chat.channel_members')), this.renderMembers()));
  }
};
DyteChannelDetails.style = dyteChannelDetailsCss;

const dyteChannelHeaderCss = "header{box-sizing:border-box;height:var(--dyte-space-16, 64px);width:100%;padding:var(--dyte-space-4, 16px);padding-left:var(--dyte-space-12, 48px);display:flex;justify-content:space-between;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}header.searching{justify-content:flex-end}header.searching .channel-details{display:none}header .channel-details{display:flex;flex-grow:1;flex-direction:column;justify-content:center;height:var(--dyte-space-9, 36px);width:var(--dyte-space-1, 4px)}header .channel-details .name{font-weight:500}header .channel-details .members{margin-top:var(--dyte-space-0\\.5, 2px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}header .channel-tools{display:flex;flex-shrink:0;justify-content:flex-end;gap:var(--dyte-space-1, 4px);min-width:var(--dyte-space-24, 96px)}header .channel-tools dyte-tooltip{height:var(--dyte-space-8, 32px);width:var(--dyte-space-10, 40px);display:flex}header .search-input{height:var(--dyte-space-8, 32px);width:var(--dyte-space-48, 192px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header .name{font-size:16px}header .br-primary-btn{background-color:transparent}header .br-primary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}@media (orientation: landscape) and (min-width: 400px){header{padding-left:var(--dyte-space-4, 16px)}header.searching .channel-details{display:flex}}";

const DyteChannelHeader = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.search = createEvent(this, "search", 7);
    this.searchDismissed = createEvent(this, "searchDismissed", 7);
    this.onSearchClickHanlder = () => {
      this.showSearchBar = !this.showSearchBar;
      if (this.showSearchBar) {
        writeTask(() => {
          this.$searchInput.focus();
        });
      }
      else {
        this.searchDismissed.emit();
      }
    };
    this.onKeyDownHandler = (e) => {
      if (e.key === 'Enter') {
        this.search.emit(this.$searchInput.value);
        this.$searchInput.blur();
      }
      else if (e.key === 'Escape') {
        this.$searchInput.value = '';
        this.showSearchBar = false;
      }
    };
    this.meeting = undefined;
    this.channel = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showChannelDetailsDialog = false;
    this.showSearchBar = false;
    this.members = [];
  }
  onChannelChanged() {
    if (this.$searchInput)
      this.$searchInput.value = '';
    this.showSearchBar = false;
    if (!this.channel.isDirectMessage) {
      this.meeting.chat.getChannelMembers(this.channel.id).then((members) => {
        this.members = members;
      });
    }
  }
  connectedCallback() {
    this.onChannelChanged();
  }
  renderChannelDetails() {
    return (h("dyte-dialog", { open: true, onDyteDialogClose: () => {
        this.showChannelDetailsDialog = false;
      }, iconPack: this.iconPack, t: this.t }, h("dyte-channel-details", { members: this.members, channel: this.channel })));
  }
  render() {
    if (!this.channel) {
      return null;
    }
    return (h(Host, null, this.showChannelDetailsDialog && this.renderChannelDetails(), h("header", { class: {
        searching: this.showSearchBar,
      } }, h("div", { class: "channel-details" }, h("span", { class: "name" }, this.channel.displayName), !this.channel.isDirectMessage && (h("span", { class: "members" }, this.members.map((member) => member.name).join(', ')))), h("div", { class: "channel-tools" }, this.showSearchBar && (h("input", { class: "search-input", type: "text", placeholder: this.t('chat.search_msgs'), ref: (el) => (this.$searchInput = el), onKeyDown: (e) => this.onKeyDownHandler(e) })), h("dyte-tooltip", { label: this.showSearchBar ? this.t('close') : this.t('chat.search_msgs'), iconPack: this.iconPack, t: this.t, variant: "primary" }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "secondary", size: "md", onClick: this.onSearchClickHanlder, class: "br-primary-btn" }, h("dyte-icon", { icon: this.showSearchBar ? this.iconPack.dismiss : this.iconPack.search, iconPack: this.iconPack, t: this.t }))), !this.channel.isDirectMessage && (h("dyte-tooltip", { label: this.t('chat.channel_members'), iconPack: this.iconPack, t: this.t, variant: "primary" }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "secondary", size: "md", onClick: () => {
        this.showChannelDetailsDialog = !this.showChannelDetailsDialog;
      }, class: "br-primary-btn" }, h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }))))))));
  }
  static get watchers() { return {
    "channel": ["onChannelChanged"]
  }; }
};
DyteChannelHeader.style = dyteChannelHeaderCss;

const dyteChannelSelectorUiCss = ".scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex}.container{display:flex;height:100%;width:var(--dyte-space-96, 384px);flex-direction:column;position:absolute;--tw-translate-x:calc(var(--dyte-space-96, 384px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-sm, 1px);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-right-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity));transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}@-webkit-keyframes fade{0%{opacity:0}100%{opacity:1}}@keyframes fade{0%{opacity:0}100%{opacity:1}}.overlay-container{width:100vw;--tw-translate-x:var(--dyte-space-96, 384px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;-webkit-animation:fade 0.8s;animation:fade 0.8s}.overlay-container .sidebar-btn{position:static;padding:var(--dyte-space-4, 16px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.sidebar-btn{position:absolute;right:calc(var(--dyte-space-9, 36px) * -1);top:var(--dyte-space-4, 16px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-7, 28px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px)}@media (orientation: landscape) and (min-width: 400px){.container{position:static;--tw-translate-x:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.sidebar-btn,.overlay-container{display:none}}.search-wrapper{display:flex;align-items:center;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-2, 8px);border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}.search{position:-webkit-sticky;position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-8, 32px);width:100%}.search .search-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);padding:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));border-top-right-radius:var(--dyte-border-radius-sm, 4px);border-bottom-right-radius:var(--dyte-border-radius-sm, 4px)}.search input{box-sizing:border-box;width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;font-size:14px;line-height:1.25rem}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input{border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px)}.channel-container{box-sizing:border-box;display:flex;flex-direction:column;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);overflow-y:scroll}.channel-container .channel{display:flex;align-items:center;justify-content:space-between;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px);border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-border-opacity))}.channel-container .channel:hover{cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}.channel-container .channel:hover .latest-msg-time,.channel-container .channel:hover .latest-msg,.channel-container .channel:hover .latest-msg.new{color:rgb(var(--dyte-colors-text-on-brand-700, var(--dyte-colors-text-700, 255 255 255 / 0.64)))}.channel-container .channel-display{display:flex;gap:var(--dyte-space-2, 8px);align-self:center;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-0, 0px)}.channel-container .channel-display dyte-avatar{height:var(--dyte-space-9, 36px);width:var(--dyte-space-9, 36px);flex-shrink:0;font-size:12px}.channel-container .channel-display dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);flex-shrink:0;padding:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.channel-container .channel-card{width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-1, 4px)}.channel-container .channel-card .channel-name{max-width:var(--dyte-space-60, 240px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px;font-weight:500}.channel-container .channel-card .latest-msg{margin:var(--dyte-space-0, 0px);max-width:var(--dyte-space-56, 224px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px}.channel-container .channel-card .latest-msg.new{font-weight:200;font-style:italic;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.channel-container .channel-card .latest-msg-time{font-size:12px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.channel-container .channel-meta{width:var(--dyte-space-12, 48px);display:flex;flex-direction:column;align-items:flex-end;justify-content:space-between;gap:var(--dyte-space-1\\.5, 6px);font-size:12px;font-weight:600}.channel-container .new-msgs-count{height:var(--dyte-space-4, 16px);min-width:var(--dyte-space-4, 16px);padding-top:1px;padding-bottom:1px;padding-left:2px;padding-right:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:var(--dyte-border-radius-sm, 4px);text-align:center;font-size:12px}.channel-container .selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}.channel-container .selected .latest-msg-time,.channel-container .selected .latest-msg,.channel-container .selected .latest-msg.new{color:rgb(var(--dyte-colors-text-on-brand-700, var(--dyte-colors-text-700, 255 255 255 / 0.64)))}.channel-container .highlight .channel-title span{font-weight:700}.latest-msg p{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-1, 4px);display:inline-block}.latest-msg blockquote{display:none}.recent-message-row{margin-bottom:var(--dyte-space-2, 8px);display:flex;width:100%;flex-direction:row;justify-content:space-between}";

const DyteChannelSelectorUi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.channelChanged = createEvent(this, "channelChanged", 7);
    this.handleResize = (e) => {
      this.isHidden = !e.matches;
    };
    this.channelSelected = (channelId) => {
      this.channelChanged.emit(channelId);
      this.onRevealClicked();
    };
    this.onSearchInput = (e) => {
      this.searchQuery = e.target.value;
    };
    this.onRevealClicked = () => {
      if (this.matchMedia.matches)
        return;
      this.isHidden = !this.isHidden;
    };
    this.renderChannelDisplayPic = (channel) => {
      const hasDisplayPic = channel.displayPictureUrl && channel.displayPictureUrl.length !== 0;
      if (channel.isDirectMessage || hasDisplayPic) {
        return (h("div", { class: "channel-display" }, h("dyte-avatar", { participant: {
            name: channel.displayName,
            picture: channel.displayPictureUrl,
          } })));
      }
      else {
        return (h("div", { class: "channel-display" }, h("dyte-icon", { icon: this.iconPack.people, slot: "start" })));
      }
    };
    this.renderRecentMessage = (channel) => {
      if (!channel.latestMessage)
        return h("p", { class: "latest-msg new" }, this.t('chat.start_conversation'));
      let senderFragment = channel.isDirectMessage ? '' : `${channel.latestMessage.displayName}: `;
      if (channel.latestMessage.type === 'text') {
        return (h("p", { class: "latest-msg" }, senderFragment, h(TextMessageView, { message: channel.latestMessage.message })));
      }
      // non text
      let messageFragment = '';
      if (channel.latestMessage.type === 'image') {
        messageFragment = this.t('image');
      }
      else if (channel.latestMessage.type === 'file') {
        messageFragment = this.t('file');
      }
      return h("p", { class: "latest-msg" }, `${senderFragment}${messageFragment}`);
    };
    this.channels = undefined;
    this.selectedChannelId = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showRecentMessage = false;
    this.isHidden = false;
    this.searchQuery = '';
  }
  connectedCallback() {
    this.matchMedia = window.matchMedia(`(orientation: landscape) and (min-width: 400px)`);
    this.matchMedia.addEventListener('change', this.handleResize);
    this.isHidden = !this.matchMedia.matches;
  }
  disconnectedCallback() {
    this.matchMedia.removeEventListener('change', this.handleResize);
  }
  componentDidRender() {
    this.$el.style.transform = this.isHidden ? 'translateX(-380px)' : 'translateX(0)';
  }
  getTimeLabel(message) {
    const messageDate = message.time;
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const firstDayOfWeek = new Date(today);
    firstDayOfWeek.setDate(today.getDate() - today.getDay() - 1);
    if (messageDate.toDateString() === today.toDateString()) {
      return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    else if (messageDate.toDateString() === yesterday.toDateString()) {
      return this.t('date.yesteday');
    }
    else if (messageDate > firstDayOfWeek) {
      const weekdays = [
        'date.sunday',
        'date.monday',
        'date.tuesday',
        'date.wednesday',
        'date.thursday',
        'date.friday',
        'date.saturday',
      ];
      return this.t(weekdays[messageDate.getDay()]);
    }
    else {
      return Intl.DateTimeFormat([], {
        day: '2-digit',
        month: '2-digit',
        year: '2-digit',
      }).format(messageDate);
    }
  }
  render() {
    return (h(Host, null, h("div", { class: "container", ref: (el) => (this.$el = el) }, this.isHidden && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "icon", variant: "ghost", size: "md", onClick: this.onRevealClicked, class: "sidebar-btn" }, h("dyte-icon", { icon: this.isHidden ? this.iconPack.chevron_left : this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("slot", { name: "header" }), h("div", { class: "search-wrapper" }, h("div", { class: "search" }, h("input", { type: "search", autocomplete: "off", placeholder: this.t('chat.search_conversations'), onInput: this.onSearchInput }), h("dyte-icon", { icon: this.iconPack.search, iconPack: this.iconPack, t: this.t, class: "search-icon" }))), h("div", { class: "channel-container scrollbar", role: "list" }, this.channels
      .filter((channel) => this.searchQuery === '' || channel.displayName.includes(this.searchQuery))
      .map((channel) => {
      return (h("div", { class: {
          channel: true,
          selected: channel.id === this.selectedChannelId,
          highlight: !!channel.unreadCount,
        }, role: "listitem", onClick: () => {
          this.channelSelected(channel.id);
        } }, this.renderChannelDisplayPic(channel), h("div", { class: "channel-card", "is-direct-message": channel.isDirectMessage }, h("div", { class: 'recent-message-row' }, h("span", { class: "channel-name" }, channel.displayName), channel.latestMessage && (h("span", { class: "latest-msg-time" }, this.getTimeLabel(channel.latestMessage)))), h("div", { class: 'recent-message-row' }, this.renderRecentMessage(channel), channel.unreadCount > 0 && channel.id !== this.selectedChannelId ? (h("span", { class: "new-msgs-count" }, channel.unreadCount < 99 ? channel.unreadCount : '99+')) : null))));
    }))), !this.isHidden && (h("div", { class: "overlay-container" }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "icon", variant: "ghost", size: "md", onClick: this.onRevealClicked, class: "sidebar-btn" }, h("dyte-icon", { icon: this.isHidden ? this.iconPack.chevron_left : this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))));
  }
};
DyteChannelSelectorUi.style = dyteChannelSelectorUiCss;

const dyteChatComposerUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.chat-input{position:relative;margin:var(--dyte-space-2, 8px);z-index:10;box-sizing:border-box;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}textarea{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));box-sizing:border-box;padding:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea::-moz-placeholder{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea::placeholder{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea{border-top-left-radius:var(--dyte-border-radius-md, 8px);border-top-right-radius:var(--dyte-border-radius-md, 8px);font-family:var(--dyte-font-family, sans-serif);outline:2px solid transparent;outline-offset:2px;resize:none;overflow-y:auto;border-width:var(--dyte-border-width-none, 0);border-style:none;min-height:60px;font-size:14px}.chat-buttons{border-bottom-right-radius:var(--dyte-border-radius-md, 8px);border-bottom-left-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));display:flex;height:var(--dyte-space-8, 32px);align-items:center;justify-content:space-between;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.chat-buttons .left dyte-button{margin-right:var(--dyte-space-1, 4px)}.chat-buttons .left dyte-button dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.chat-buttons .right{z-index:10}.chat-buttons .right .edit-buttons{display:flex;gap:var(--dyte-space-2, 8px)}.chat-buttons>div{display:flex;align-items:center}dyte-emoji-picker{z-index:0;position:absolute;bottom:var(--dyte-space-32, 128px);border-top:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));-webkit-animation:0.3s slide-up ease;animation:0.3s slide-up ease}@-webkit-keyframes slide-up{from{transform:translateY(100%)}to{transform:translateY(0%)}}@keyframes slide-up{from{transform:translateY(100%)}to{transform:translateY(0%)}}.member-list{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-1, 4px);max-height:var(--dyte-space-28, 112px);min-width:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);padding:var(--dyte-space-0, 0px);position:absolute;bottom:var(--dyte-space-28, 112px);list-style-type:none;overflow-y:auto;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px);--tw-border-spacing-x:var(--dyte-space-2, 8px);--tw-border-spacing-y:var(--dyte-space-2, 8px);border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-style:solid;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.member-list .member{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-4, 16px);cursor:pointer}.member-list .member dyte-avatar{flex-shrink:0;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.member-list .member span{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.member-list .member:hover,.member-list .member.selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.suggested-replies{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-3, 12px);display:flex;flex-wrap:nowrap;gap:var(--dyte-space-2, 8px);list-style-type:none;overflow-x:auto}.suggested-replies dyte-tooltip{flex-shrink:0}.suggested-replies li{padding:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.75);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));cursor:pointer}.suggested-replies li:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity))}.preview-overlay{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-md, 8px)}.file-preview{position:absolute;top:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);max-width:-webkit-fit-content;max-width:-moz-fit-content;max-width:fit-content;max-height:var(--dyte-space-20, 80px)}.file-preview:hover dyte-tooltip{display:block}.file-preview dyte-tooltip{position:absolute;top:calc(var(--dyte-space-1, 4px) * -1);left:calc(var(--dyte-space-1, 4px) * -1);display:none;margin-left:calc(var(--dyte-space-1, 4px) * -1);margin-top:calc(var(--dyte-space-1, 4px) * -1)}.file-preview dyte-button{display:flex;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));border:1px solid rgb(var(--dyte-colors-text-1000, 255 255 255))}.file-preview dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.preview-image{height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);-o-object-fit:cover;object-fit:cover;max-height:100%;max-width:100%;overflow:clip;border-radius:var(--dyte-border-radius-md, 8px)}.preview-file{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-radius:var(--dyte-border-radius-md, 8px);max-width:200px}@-webkit-keyframes scroll-text{0%{transform:translateX(0%)}70%{transform:translateX(-100%)}80%{transform:translateX(0%)}100%{transform:translateX(0%)}}@keyframes scroll-text{0%{transform:translateX(0%)}70%{transform:translateX(-100%)}80%{transform:translateX(0%)}100%{transform:translateX(0%)}}";

const MENTION_CHAR = '@';
const DyteChatComposerUi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onNewMessage = createEvent(this, "dyteNewMessage", 7);
    this.onEditMessage = createEvent(this, "dyteEditMessage", 7);
    this.onEditCancelled = createEvent(this, "dyteEditCancelled", 7);
    this.fileReader = new FileReader();
    this.fileToUpload = null;
    this.handleKeyDown = (e) => {
      if (e.key === MENTION_CHAR && [undefined, ' '].includes(this.$textArea.value.at(-1))) {
        // [undefined, ' '] checks if mention is start of text or start of new word
        this.mentionQuery = MENTION_CHAR;
      }
      if (e.key === 'ArrowDown') {
        this.focusedMemberIndex = Math.min(this.focusedMemberIndex + 1, this.getFilteredMembers().length - 1);
      }
      if (e.key === 'ArrowUp') {
        this.focusedMemberIndex = Math.max(0, this.focusedMemberIndex - 1);
      }
      if (e.key === 'Escape' || (e.key === 'Backspace' && this.mentionQuery === MENTION_CHAR)) {
        this.mentionQuery = '';
      }
      if (['Enter', 'Tab', ' '].includes(e.key) && this.mentionQuery !== '') {
        const member = this.getFilteredMembers()[this.focusedMemberIndex];
        this.onMemberSelect(member);
        e.preventDefault();
        return;
      }
      // slack like typing experience
      if (e.key === 'Enter' && e.shiftKey) {
        const height = this.$textArea.clientHeight;
        if (height < 200) {
          this.$textArea.style.height = this.$textArea.clientHeight + 20 + 'px';
        }
      }
      else if (e.key === 'Enter') {
        e.preventDefault();
        if (this.prefill.editMessage) {
          this.handleEditMessage();
        }
        else {
          this.handleSendMessage();
        }
      }
      else if (e.key === 'Backspace') {
        if (this.$textArea.value.endsWith('\n')) {
          this.$textArea.style.height = this.$textArea.clientHeight - 20 + 'px';
        }
        else if (this.$textArea.value === '') {
          this.$textArea.style.height = 'auto';
        }
      }
    };
    this.handleKeyUp = (_e) => {
      if (this.mentionQuery !== '') {
        const reversed = reverse(this.$textArea.value.trim());
        const query = reversed.substring(0, reversed.indexOf(MENTION_CHAR));
        this.mentionQuery = `${MENTION_CHAR}${reverse(query)}`;
      }
    };
    this.onPaste = (e) => {
      const data = e.clipboardData || e.originalEvent.clipboardData;
      handleFilesDataTransfer(data.items, this.generateFilePreview);
      writeTask(() => {
        if (data.items.length > 0) {
          this.$textArea.value = '';
        }
      });
    };
    this.generateFilePreview = (type, file) => {
      this.fileToUpload = { type, image: file, file };
      if (type === 'image') {
        this.fileReader.readAsDataURL(file);
      }
      else if (type === 'file') {
        this.filePreview = file.name;
      }
    };
    this.sendFile = () => {
      if (!this.canSendFiles) {
        return;
      }
      if (this.fileToUpload.type === 'image') {
        this.onNewMessage.emit({
          type: 'image',
          file: this.fileToUpload.image,
          image: this.fileToUpload.image,
        });
      }
      else {
        this.onNewMessage.emit({ type: 'file', file: this.fileToUpload.file });
      }
      this.cleanUpFileUpload();
    };
    this.handleSendMessage = () => {
      if (!this.canSendTextMessage) {
        return;
      }
      if (this.fileToUpload !== null) {
        this.sendFile();
        return;
      }
      const message = this.$textArea.value.trim();
      if (message.length > 0) {
        if (this.prefill.replyMessage) {
          this.onNewMessage.emit({
            type: 'text',
            message,
            replyTo: this.prefill.replyMessage,
          });
        }
        else {
          this.onNewMessage.emit({ type: 'text', message });
        }
        this.cleanup();
      }
    };
    this.cleanup = () => {
      this.mentionQuery = '';
      this.focusedMemberIndex = 0;
      this.$textArea.value = '';
      this.$textArea.style.height = 'auto';
      gracefulStorage$1.setItem(this.storageKey, '');
    };
    this.handleEditMessage = () => {
      var _a;
      let editedMessage = this.$textArea.value.trim();
      if (((_a = this.prefill.editMessage) === null || _a === void 0 ? void 0 : _a.message) &&
        replyBlockPattern.test(this.prefill.editMessage.message)) {
        // add back the reply block which we stripped out for editing
        const replyBlock = extractReplyBlock(this.prefill.editMessage.message);
        editedMessage = `${replyBlock}\n\n${editedMessage}`;
      }
      this.onEditMessage.emit({
        id: this.prefill.editMessage.id,
        message: editedMessage,
        channelId: this.prefill.editMessage.channelId,
      });
      this.cleanup();
    };
    this.handleEditCancel = () => {
      this.onEditCancelled.emit();
      this.cleanup();
    };
    this.initializeTextField = (el) => {
      this.$textArea = el;
      const message = gracefulStorage$1.getItem(this.storageKey) || '';
      this.$textArea.value = message;
    };
    this.onMemberSelect = (member) => {
      const reversedQuery = reverse(this.mentionQuery);
      const reversed = reverse(this.$textArea.value.trim()).replace(reversedQuery, '');
      this.$textArea.value = reverse(reversed) + `${MENTION_CHAR}${member.name} `;
      this.mentionQuery = '';
      this.focusedMemberIndex = 0;
      writeTask(() => this.$textArea.focus());
    };
    this.getFilteredMembers = () => {
      const query = this.mentionQuery.replace(MENTION_CHAR, '');
      return this.members.filter((member) => member.name.toLowerCase().includes(query.toLowerCase()));
    };
    this.cleanUpFileUpload = () => {
      this.filePreview = null;
      this.fileToUpload = null;
    };
    this.renderSuggestedReplies = () => {
      if (!this.prefill.suggestedReplies)
        return;
      if (this.prefill.suggestedReplies.length === 0)
        return;
      return (h("ul", { class: "suggested-replies scrollbar" }, this.prefill.suggestedReplies.map((reply) => (h("dyte-tooltip", { label: this.t('chat.click_to_send') }, h("li", { onClick: () => this.onNewMessage.emit({ type: 'text', message: reply }) }, reply))))));
    };
    this.renderMenu = () => {
      if (this.mentionQuery.length === 0)
        return;
      const filteredMembers = this.getFilteredMembers();
      if (filteredMembers.length === 0)
        return;
      return (h("ul", { class: "member-list scrollbar" }, filteredMembers.map((member, index) => (h("li", { class: { member: true, selected: index === this.focusedMemberIndex }, onClick: () => this.onMemberSelect(member), ref: ($li) => {
          if (index === this.focusedMemberIndex) {
            writeTask(() => {
              if ($li)
                $li.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
            });
          }
        } }, h("dyte-avatar", { participant: {
          name: member.name,
          picture: member.picture,
        }, size: "sm" }), h("span", null, member.name))))));
    };
    this.canSendTextMessage = false;
    this.canSendFiles = false;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.disableEmojiPicker = false;
    this.prefill = {};
    this.members = [];
    this.channelId = undefined;
    this.emojiPickerActive = false;
    this.mentionQuery = '';
    this.focusedMemberIndex = 0;
    this.filePreview = null;
  }
  connectedCallback() {
    this.fileReader.onload = (e) => {
      if (typeof e.target.result === 'string') {
        this.filePreview = e.target.result;
      }
    };
    // this.fileReader.onloadstart = () => {};
    // this.fileReader.onloadend = () => {};
  }
  onChannelChanged() {
    this.mentionQuery = '';
    this.focusedMemberIndex = 0;
    const message = gracefulStorage$1.getItem(this.storageKey) || '';
    this.$textArea.value = message;
    this.emojiPickerActive = false;
  }
  componentDidRender() {
    if (this.prefill.editMessage || this.prefill.replyMessage) {
      writeTask(() => this.$textArea.focus());
    }
  }
  get storageKey() {
    if (this.channelId) {
      return `dyte-text-message-${this.channelId}`;
    }
    return 'dyte-text-message';
  }
  uploadFile(type) {
    const input = document.createElement('input');
    input.type = 'file';
    if (type === 'image') {
      input.accept = 'image/*';
    }
    input.onchange = (e) => {
      const { validity, files: [file], } = e.target;
      if (validity.valid) {
        this.generateFilePreview(type, file);
      }
    };
    input.click();
  }
  renderFilePreview() {
    if (typeof this.filePreview !== 'string')
      return;
    return (h("div", { class: "preview-overlay" }, h("div", { class: "file-preview" }, h("dyte-tooltip", { label: this.t('chat.cancel_upload') }, h("dyte-button", { variant: "secondary", kind: "icon", onClick: this.cleanUpFileUpload }, h("dyte-icon", { icon: this.iconPack.dismiss }))), this.fileToUpload.type === 'image' ? (h("img", { class: "preview-image", src: this.filePreview })) : (h("div", { class: "preview-file" }, h("span", null, this.filePreview))))));
  }
  render() {
    var _a;
    const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
    let defaultValue = '';
    if ((_a = this.prefill.editMessage) === null || _a === void 0 ? void 0 : _a.message) {
      defaultValue = stripOutReplyBlock(this.prefill.editMessage.message);
    }
    return (h(Host, null, this.canSendTextMessage && this.emojiPickerActive && (h("dyte-emoji-picker", { part: "emoji-picker", onPickerClose: () => {
        this.emojiPickerActive = false;
      }, onDyteEmojiClicked: (e) => {
        this.$textArea.value += e.detail;
        this.$textArea.focus();
      }, t: this.t })), this.renderSuggestedReplies(), h("slot", { name: "chat-addon" }), h("div", { class: "chat-input", part: "chat-input" }, this.renderMenu(), this.canSendTextMessage && (h("textarea", { class: "scrollbar", part: "textarea", ref: this.initializeTextField, autoFocus: true, placeholder: this.fileToUpload ? '' : this.t('chat.message_placeholder'), value: defaultValue, onPaste: this.onPaste, onKeyDown: this.handleKeyDown, onKeyUp: this.handleKeyUp, onInput: (e) => {
        gracefulStorage$1.setItem(this.storageKey, e.target.value);
      }, disabled: !!this.filePreview })), h("div", { class: "chat-buttons", part: "chat-buttons" }, h("div", { class: "left", part: "chat-buttons-left" }, !this.prefill.editMessage &&
      this.canSendFiles && [
      h("dyte-tooltip", Object.assign({ label: this.t('chat.send_file') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", onClick: () => this.uploadFile('file'), title: this.t('chat.send_file'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.attach }))),
      h("dyte-tooltip", Object.assign({ label: this.t('chat.send_img') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", onClick: () => this.uploadFile('image'), title: this.t('chat.send_img'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.image }))),
    ], !this.prefill.editMessage && this.canSendTextMessage && !this.disableEmojiPicker && (h("dyte-tooltip", Object.assign({ label: this.t('chat.send_emoji') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", class: { active: this.emojiPickerActive }, title: this.t('chat.send_emoji'), iconPack: this.iconPack, t: this.t, onClick: () => {
        this.emojiPickerActive = !this.emojiPickerActive;
      } }, h("dyte-icon", { icon: this.iconPack.emoji_multiple }))))), !!this.filePreview && this.renderFilePreview(), this.canSendTextMessage && (h("div", { class: "right", part: "chat-buttons-right" }, !this.prefill.editMessage && (h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.send_msg'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", onClick: () => this.handleSendMessage(), title: this.t('chat.send_msg'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.send })))), this.prefill.editMessage && (h("div", { class: "edit-buttons" }, h("dyte-tooltip", Object.assign({ variant: "secondary", label: this.t('cancel'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", variant: "secondary", onClick: () => this.handleEditCancel(), title: this.t('cancel'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss }))), h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.update_msg'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", onClick: () => this.handleEditMessage(), title: this.t('chat.send_msg'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.checkmark })))))))))));
  }
  static get watchers() { return {
    "channelId": ["onChannelChanged"]
  }; }
};
DyteChatComposerUi.style = dyteChatComposerUiCss;

const dyteChatMessagesUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;word-break:break-word}.chat-container{box-sizing:border-box;display:flex;flex-direction:column;padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);flex:1 0 0px;overflow-y:scroll}.chat-container .spacer{flex:1 1 auto}.chat-container .chat{flex:0 0 auto}.file-picker{display:none}.chat *:first-child{margin-top:var(--dyte-space-0, 0px)}.chat .head{display:flex;align-items:center}.chat .head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.chat .head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);overflow-wrap:break-word;font-size:14px;line-height:1.375}.chat .body .emoji{font-size:24px}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-text-message,dyte-image-message,dyte-file-message{margin-top:var(--dyte-space-4, 16px);display:block;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}*[is-continued]{margin-top:var(--dyte-space-3, 12px)}dyte-text-message[is-continued]{margin-top:var(--dyte-space-2, 8px)}.chat .image{position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.chat .image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.chat .image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.chat .image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.chat .image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.chat .image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}.chat .file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1\\.5, 6px);padding-bottom:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.chat .file .file-data{flex:1 1 0%}.chat .file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.chat .file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.chat .file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.new-chat-marker{display:flex;width:100%;align-items:center;gap:var(--dyte-space-2, 8px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.new-chat-marker::before{content:'';height:1px;flex:1 1 0%;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.show-new-messages-ctr{pointer-events:none;display:flex;justify-content:flex-end;padding:var(--dyte-space-3, 12px);z-index:0;margin-top:calc(var(--dyte-space-14, 56px) * -1)}.show-new-messages{pointer-events:auto;--tw-translate-y:calc(var(--dyte-space-6, 24px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}";

const DyteChatMessagesUi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.observingEl = [];
    this.onScroll = (e) => {
      const target = e.target;
      writeTask(() => {
        const { scrollTop, clientHeight, scrollHeight } = target;
        const fromTop = scrollTop + clientHeight;
        if (fromTop + 10 >= scrollHeight) {
          // at bottom
          this.autoScrollEnabled = true;
          this.showLatestMessageButton = false;
        }
        else {
          // not at bottom
          this.autoScrollEnabled = false;
        }
      });
    };
    this.scrollToBottom = () => {
      smoothScrollToBottom(this.$chat);
    };
    this.observeMessage = (el) => {
      if (el) {
        this.observingEl.push(el);
      }
      try {
        this.intersectionObserver.observe(el);
      }
      catch (_a) { }
    };
    this.selectedGroup = undefined;
    this.messages = [];
    this.selfUserId = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.now = new Date();
    this.showLatestMessageButton = false;
  }
  connectedCallback() {
    var _a;
    this.lastReadTimestamp = (_a = chatUnreadTimestamps['everyone']) !== null && _a !== void 0 ? _a : new Date('0001-01-01T00:00:00Z');
    this.intersectionObserver = new IntersectionObserver((entries) => {
      if (!document.hasFocus())
        return;
      writeTask(() => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            const currTimestamp = parseInt(entry.target.getAttribute('data-timestamp'));
            if (currTimestamp > this.lastReadTimestamp.getTime()) {
              // this.lastReadTimestamp = new Date();
              chatUnreadTimestamps[this.selectedGroup] = new Date();
            }
          }
        }
      });
    });
    // update current time every minute
    const updateNow = () => {
      this.now = new Date();
      this.timeout = setTimeout(() => {
        if (this.request != null) {
          this.request = requestAnimationFrame(updateNow);
        }
      }, 60 * 1000);
    };
    this.request = requestAnimationFrame(updateNow);
    this.chatChanged(this.messages);
  }
  componentDidLoad() {
    this.$chat.addEventListener('scroll', this.onScroll);
  }
  componentDidRender() {
    if (this.autoScrollEnabled) {
      smoothScrollToBottom(this.$chat);
    }
    else if (this.autoScrollEnabled == null) {
      // scroll to bottom on first render
      smoothScrollToBottom(this.$chat, false);
    }
  }
  chatChanged(messages) {
    if (this.$chat == null)
      return;
    if (this.autoScrollEnabled || this.$chat.clientHeight === this.$chat.scrollHeight)
      return;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].message.time > this.lastReadTimestamp &&
        messages[i].message.userId !== this.selfUserId) {
        // show latest message button when you have new messages
        // and chat container is scrollable and autoscroll is not enabled
        this.showLatestMessageButton = true;
        break;
      }
    }
  }
  selectedBucketChanged() {
    this.autoScrollEnabled = undefined;
    this.observingEl.forEach((el) => {
      this.intersectionObserver.unobserve(el);
    });
    this.observingEl = [];
  }
  disconnectedCallback() {
    this.$chat.removeEventListener('scroll', this.onScroll);
    this.intersectionObserver.disconnect();
    clearTimeout(this.timeout);
    cancelAnimationFrame(this.request);
  }
  render() {
    var _a;
    let prevMessage = null;
    let reachedFirstUnread = false;
    return (h(Host, null, h("div", { class: "chat-container scrollbar", ref: (el) => (this.$chat = el), part: "container" }, h("div", { class: "spacer", part: "spacer" }), h("div", { class: "chat", part: "chat" }, (_a = this.messages) === null || _a === void 0 ? void 0 : _a.map((item) => {
      if (item.type === 'chat') {
        const { message } = item;
        const isSelfMessage = message.userId === this.selfUserId;
        const isUnread = !isSelfMessage &&
          !this.autoScrollEnabled &&
          !reachedFirstUnread &&
          message.time > this.lastReadTimestamp;
        if (isUnread)
          reachedFirstUnread = isUnread;
        const isContinued = !isUnread &&
          message.userId === (prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.userId) &&
          differenceInMinutes(message.time, prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.time) < 2;
        prevMessage = message;
        switch (message.type) {
          case 'text':
            return (h("div", { "is-continued": isContinued, key: item.message.id }, isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-text-message", { message: message, now: this.now, isContinued: isContinued, "data-timestamp": message.time.getTime(), ref: this.observeMessage, iconPack: this.iconPack, t: this.t })));
          case 'image':
            return (h("div", { "is-continued": isContinued, key: item.message.id }, isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-image-message", { message: message, now: this.now, isContinued: isContinued, iconPack: this.iconPack, "data-timestamp": message.time.getTime(), ref: this.observeMessage, t: this.t })));
          case 'file':
            return (h("div", { "is-continued": isContinued, key: item.message.id }, isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-file-message", { message: message, now: this.now, isContinued: isContinued, iconPack: this.iconPack, t: this.t, "data-timestamp": message.time.getTime(), ref: this.observeMessage })));
        }
      }
      return null;
    }))), h("div", { class: "show-new-messages-ctr" }, h("dyte-button", { class: {
        'show-new-messages': true,
        active: this.showLatestMessageButton,
      }, kind: "icon", part: "show-new-messages", onClick: this.scrollToBottom, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t })))));
  }
  static get watchers() { return {
    "messages": ["chatChanged"],
    "selectedGroup": ["selectedBucketChanged"]
  }; }
};
DyteChatMessagesUi.style = dyteChatMessagesUiCss;

const dyteChatMessagesUiPaginatedCss = ":host{display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));flex:1 0 0px}";

const DyteChatMessagesUiPaginated = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.editMessageInit = createEvent(this, "editMessageInit", 7);
    this.pageSize = 25;
    this.lastReadMessageIndex = -1;
    this.maybeMarkChannelAsRead = (messages) => {
      if (!this.selectedChannelId)
        return;
      if (messages.length === 0)
        return;
      if (this.lastReadMessageIndex !== -1)
        return;
      const latestMsg = messages.at(0).time > messages.at(-1).time ? messages.at(0) : messages.at(-1);
      if (!latestMsg.channelIndex)
        return;
      this.lastReadMessageIndex = parseInt(latestMsg.channelIndex, 10);
      this.meeting.chat.markLastReadMessage(this.selectedChannelId, latestMsg);
    };
    this.getChatMessages = async (timestamp, size, reversed) => {
      const { messages } = await this.meeting.chat.getMessages(timestamp, size, reversed, undefined, this.selectedChannelId);
      this.maybeMarkChannelAsRead(messages);
      return messages;
    };
    this.createChatNodes = (data) => {
      /**
       * NOTE(callmetarush): When between pages the message's isContinued
       * will fail in current implementation
       */
      return data.map((message, idx) => {
        var _a;
        const isContinued = message.userId === ((_a = data[idx - 1]) === null || _a === void 0 ? void 0 : _a.userId);
        return this.createChatNode(message, isContinued);
      });
    };
    this.disconnectMeeting = (meeting) => {
      var _a;
      (_a = meeting === null || meeting === void 0 ? void 0 : meeting.chat) === null || _a === void 0 ? void 0 : _a.removeListener('chatUpdate', this.chatUpdateListener);
    };
    this.createChatNode = (message, isContinued) => {
      var _a, _b;
      const isSelf = this.meeting.self.userId === message.userId;
      return (h("dyte-chat-message", { message: message, isContinued: isContinued, isUnread: false, size: this.size, iconPack: this.iconPack, key: message.id, isSelf: isSelf, alignRight: isSelf && this.meeting.meta.viewType === 'CHAT', disableControls: this.meeting.meta.viewType !== 'CHAT', senderDisplayPicture: (_a = this.meeting.participants.all.toArray().find((member) => member.userId === message.userId)) === null || _a === void 0 ? void 0 : _a.picture, hideAvatar: (isSelf && this.meeting.meta.viewType === 'CHAT') || ((_b = this.selectedChannel) === null || _b === void 0 ? void 0 : _b.isDirectMessage), canEdit: isSelf && message.type === 'text', canDelete: isSelf, canReply: message.type === 'text', onEdit: () => {
          if (message.type !== 'text')
            return;
          this.editMessageInit.emit({ payload: message, flags: { isEdit: true } });
        }, onReply: () => {
          if (message.type !== 'text')
            return;
          this.editMessageInit.emit({
            payload: message,
            flags: { isReply: true },
          });
        }, onDelete: async () => {
          var _a;
          await this.meeting.chat.deleteMessage(message.id, (_a = this.selectedChannel) === null || _a === void 0 ? void 0 : _a.id).catch(() => {
            // log failure
          });
        } }));
    };
    this.chatUpdateListener = (data) => {
      if (this.selectedChannelId && data.message.channelId !== this.selectedChannelId)
        return;
      if (data.action === 'add') {
        this.$paginatedListRef.onNewNode(data.message);
        this.lastReadMessageIndex = -1;
        this.maybeMarkChannelAsRead([data.message]);
      }
      else if (data.action === 'delete') {
        this.$paginatedListRef.onNodeDelete(data.message.id);
      }
      else if (data.action === 'edit') {
        this.$paginatedListRef.onNodeUpdate(data.message.id, data.message);
      }
    };
    this.meeting = undefined;
    this.selectedChannel = undefined;
    this.selectedChannelId = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  disconnectedCallback() {
    this.disconnectMeeting(this.meeting);
  }
  meetingChanged(meeting, oldMeeting) {
    var _a;
    if (oldMeeting != undefined)
      this.disconnectMeeting(oldMeeting);
    if (meeting && !meeting.chat)
      return;
    if (meeting != null) {
      (_a = meeting.chat) === null || _a === void 0 ? void 0 : _a.addListener('chatUpdate', this.chatUpdateListener);
    }
  }
  channelChanged() {
    this.lastReadMessageIndex = -1;
  }
  render() {
    return (h(Host, null, h("dyte-paginated-list", { ref: (el) => (this.$paginatedListRef = el), pageSize: this.pageSize, pagesAllowed: 3, fetchData: this.getChatMessages, createNodes: this.createChatNodes, selectedItemId: this.selectedChannelId, emptyListLabel: this.t('chat.empty_channel') })));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "selectedChannelId": ["channelChanged"]
  }; }
};
DyteChatMessagesUiPaginated.style = dyteChatMessagesUiPaginatedCss;

const dyteChatSearchResultsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;flex-direction:column;position:relative;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}";

const DyteChatSearchResults = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.pageSize = 50;
    this.searchMessages = async (timestamp, size, reversed) => {
      return this.meeting.chat.searchMessages(this.query, {
        channelId: this.channelId,
        timestamp,
        size,
        reversed,
      });
    };
    this.nodeRenderer = (messages) => {
      return messages.map((message) => (h("dyte-chat-message", { key: message.id, message: message, disableControls: true })));
    };
    this.meeting = undefined;
    this.query = undefined;
    this.channelId = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("dyte-paginated-list", { pageSize: this.pageSize, pagesAllowed: 3, fetchData: this.searchMessages, createNodes: this.nodeRenderer, selectedItemId: this.query })));
  }
};
DyteChatSearchResults.style = dyteChatSearchResultsCss;

const dyteChatSelectorUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;flex-direction:column}.chat-scope-selector{position:relative;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));z-index:10}.chat-scope-selector button{width:100%;border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-4, 16px);display:flex;align-items:center;justify-content:space-between;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px;cursor:pointer;height:var(--dyte-space-12, 48px)}.chat-scope-selector button span{display:flex;align-items:center;justify-content:flex-start}.chat-scope-selector button dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.chat-scope-selector .search{position:-webkit-sticky;position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-0, 0px)}.chat-scope-selector .search dyte-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.chat-scope-selector .search input{box-sizing:border-box;height:var(--dyte-space-9, 36px);width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.chat-scope-selector .search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat-scope-selector .search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat-scope-selector .participants-container{position:absolute;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));top:var(--dyte-space-12, 48px);-webkit-animation:0.3s slide-down ease;animation:0.3s slide-down ease}@-webkit-keyframes slide-down{from{transform:translateY(-50px)}to{transform:translateY(0%)}}@keyframes slide-down{from{transform:translateY(-50px)}to{transform:translateY(0%)}}.chat-scope-selector .scope-list{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);list-style-type:none;padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px);overflow:auto;max-height:375px}.chat-scope-selector .scope-list .scope{position:relative;display:flex;flex-direction:row;align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px)}.chat-scope-selector .scope-list .scope:hover{cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.chat-scope-selector .scope-list .scope-special{margin-top:var(--dyte-space-4, 16px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.chat-scope-selector .scope-list .everyone-icon>dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.chat-scope-selector .scope-list .everyone-icon{display:flex;height:100%;width:100%;align-items:center;justify-content:center;margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px}.unread-count.selector{position:unset;margin-left:var(--dyte-space-2, 8px)}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}dyte-avatar{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px)}";

const DyteChatSelectorUi = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.groupChanged = createEvent(this, "dyteChatGroupChanged", 7);
    this.onScopeClick = (scope) => {
      this.showParticipantsPanel = false;
      this.groupChanged.emit(scope);
    };
    this.selfUserId = undefined;
    this.selectedGroupId = undefined;
    this.unreadCounts = {};
    this.groups = [];
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showParticipantsPanel = false;
    this.query = '';
  }
  toggleParticipants() {
    this.showParticipantsPanel = !this.showParticipantsPanel;
  }
  getGroups() {
    return this.groups.filter((participant) => participant.name.toLowerCase().includes(this.query.toLowerCase()));
  }
  getName() {
    if (!this.selectedGroupId || this.selectedGroupId === 'everyone') {
      return this.t('everyone');
    }
    const group = this.groups.find((g) => g.userId === this.selectedGroupId);
    if (group) {
      return group.name;
    }
    return this.t('everyone');
  }
  render() {
    const unreadCountTotal = Object.keys(this.unreadCounts).reduce((total, key) => {
      return total + this.unreadCounts[key];
    }, 0);
    return (h(Host, null, h("div", { class: "chat-scope-selector" }, this.showParticipantsPanel && (h("div", { class: "participants-container" }, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon" }), h("input", { type: "search", autocomplete: "off", placeholder: "Search", value: this.query, onInput: (e) => {
        this.query = e.target.value;
      }, part: "search-input" })), h("ul", { class: "scope-list scrollbar" }, this.query === '' && (h("li", { class: "scope scope-special", onClick: () => this.onScopeClick('everyone') }, h("div", { class: "everyone-icon" }, h("dyte-icon", { icon: this.iconPack.participants })), "Everyone", this.unreadCounts['everyone'] > 0 && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadCounts['everyone']))))), this.getGroups().map((group) => {
      const count = this.unreadCounts[generateChatGroupKey([this.selfUserId, group.userId])];
      return (h("li", { class: "scope", onClick: () => this.onScopeClick(group), key: group.userId }, group.name, count > 0 && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, count)))));
    })))), h("button", { onClick: () => this.toggleParticipants() }, h("span", null, `${this.t('to')} ${this.getName()}`, '  ', unreadCountTotal > 0 && (h("div", { class: "unread-count selector" }, h("span", null, unreadCountTotal)))), h("dyte-icon", { icon: this.showParticipantsPanel ? this.iconPack.chevron_up : this.iconPack.chevron_down })))));
  }
};
DyteChatSelectorUi.style = dyteChatSelectorUiCss;

const dyteDialogManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

const DyteDialogManager = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.onDyteDialogClose = (state$1, value) => {
      state[state$1] = value;
      this.stateUpdate.emit({ [state$1]: value });
    };
    this.leaveStage = async () => {
      var _a, _b, _c;
      if (this.meeting.meta.viewType === 'LIVESTREAM' &&
        ((_a = this.meeting.stage) === null || _a === void 0 ? void 0 : _a.status) === 'ACCEPTED_TO_JOIN_STAGE') {
        await ((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.stage) === null || _c === void 0 ? void 0 : _c.leave());
      }
      if (this.meeting.meta.viewType === 'WEBINAR') {
        await this.meeting.self.leaveStage();
      }
      this.onDyteDialogClose('activeJoinStage', false);
    };
    this.joinStage = async () => {
      if (this.meeting.meta.viewType === 'LIVESTREAM') {
        await this.meeting.stage.join();
      }
      if (this.meeting.meta.viewType === 'WEBINAR') {
        await this.meeting.self.joinStage();
      }
      this.onDyteDialogClose('activeJoinStage', false);
    };
    this.meeting = undefined;
    this.config = defaultConfig;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    var _a, _b, _c, _d;
    const defaults = {
      meeting: this.meeting,
      states: this.states || state,
      config: this.config,
      size: this.size,
      iconPack: this.iconPack,
      t: this.t,
    };
    const states = this.states || state;
    if ((states === null || states === void 0 ? void 0 : states.image) != null) {
      const image = states.image;
      const onImageClose = () => {
        this.stateUpdate.emit({ image: null });
        state.image = null;
      };
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: onImageClose, hideCloseButton: true, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-image-viewer", defaults: defaults, props: { image, onClose: onImageClose } }))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeSettings) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeSettings', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-settings", defaults: defaults }))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeDebugger) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeDebugger', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-debugger", defaults: defaults }))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeLeaveConfirmation) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeLeaveConfirmation', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-leave-meeting", defaults: defaults }))));
    }
    else if (((_a = states === null || states === void 0 ? void 0 : states.activePermissionsMessage) === null || _a === void 0 ? void 0 : _a.enabled) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activePermissionsMessage', { enabled: false }), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-permissions-message", defaults: defaults }))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeRemoteAccessManager) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeRemoteAccessManager', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-remote-access-manager", defaults: defaults }))));
    }
    else if (((_b = states === null || states === void 0 ? void 0 : states.activeBreakoutRoomsManager) === null || _b === void 0 ? void 0 : _b.active) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeBreakoutRoomsManager', {
          active: false,
          data: undefined,
        }), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-breakout-rooms-manager", defaults: defaults, props: { mode: this.meeting.connectedMeetings.isActive ? 'view' : 'create' } }))));
    }
    else if (((_c = states === null || states === void 0 ? void 0 : states.activeConfirmationModal) === null || _c === void 0 ? void 0 : _c.active) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeConfirmationModal', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-confirmation-modal", defaults: defaults }))));
    }
    else if (((_d = states === null || states === void 0 ? void 0 : states.activeOverlayModal) === null || _d === void 0 ? void 0 : _d.active) === true) {
      return (h(Host, null, h("dyte-overlay-modal", { meeting: this.meeting, states: this.states, iconPack: this.iconPack, t: this.t })));
    }
    else if (states === null || states === void 0 ? void 0 : states.activeBroadcastMessageModal) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.onDyteDialogClose('activeBroadcastMessageModal', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-broadcast-message-modal", defaults: defaults }))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeJoinStage) === true) {
      const dataState = {
        title: this.t('stage.join_title'),
        label: {
          accept: this.t('stage.join_confirm'),
          reject: this.t('stage.join_cancel'),
        },
        description: this.t('stage.join_summary'),
      };
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: this.leaveStage, iconPack: this.iconPack, t: this.t }, h("dyte-join-stage", Object.assign({ dataConfig: dataState, onDyteJoinStage: this.joinStage, onDyteLeaveStage: this.leaveStage }, defaults)))));
    }
    else if ((states === null || states === void 0 ? void 0 : states.activeMuteAllConfirmation) === true) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => {
          this.onDyteDialogClose('activeMuteAllConfirmation', false);
        }, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-mute-all-confirmation", defaults: defaults }))));
    }
    else if (states === null || states === void 0 ? void 0 : states.activeChannelCreator) {
      return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => {
          this.onDyteDialogClose('activeChannelCreator', false);
        }, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-channel-creator", defaults: defaults }))));
    }
    return null;
  }
};
DyteDialogManager.style = dyteDialogManagerCss;

const EMOJI_ASSET_URL = 'https://cdn.dyte.in/assets/emojis-data.json';
/**
 * fetches the latest emoji list from CDN
 * @returns list of emojis
 */
const fetchEmojis = async () => {
  const emojis = await fetch(EMOJI_ASSET_URL);
  return emojis.json();
};

const dyteEmojiPickerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.emoji-parent{box-sizing:border-box;display:inline-flex;height:var(--dyte-space-64, 256px);max-width:640px;flex-direction:column;padding:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-0, 0px);width:auto;min-width:var(--dyte-space-20, 80px);-webkit-user-select:none;-moz-user-select:none;user-select:none;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.close-parent{display:flex;flex:1 1 0%;justify-content:flex-end;padding:var(--dyte-space-0, 0px)}#emoji-grid{margin-top:var(--dyte-space-2, 8px);box-sizing:border-box;display:flex;flex-direction:row;flex-wrap:wrap;overflow-x:hidden;overflow-y:scroll;height:100%;grid-auto-rows:minmax(-webkit-min-content, -webkit-max-content);grid-auto-rows:minmax(min-content, max-content)}#loader{display:flex;height:100%;width:100%;align-items:center;justify-content:center}input{display:block;height:var(--dyte-space-8, 32px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:14px;border-width:var(--dyte-border-width-none, 0);border-style:solid;border-style:none;border-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input::placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input{border-radius:var(--dyte-border-radius-sm, 4px);outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-ring-opacity));--tw-ring-opacity:0.3}.emoji{height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px);font-size:20px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

const DyteEmojiPicker = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.pickerClose = createEvent(this, "pickerClose", 7);
    this.emojiClicked = createEvent(this, "dyteEmojiClicked", 7);
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.emojiList = undefined;
    this.filterVal = '';
    this.filteredEmojis = [];
  }
  componentWillLoad() {
    // Don't use async here as it will block the render
    fetchEmojis().then((e) => {
      this.emojiList = e;
      this.handleInputChange({ value: '' });
    });
  }
  handleInputChange(target) {
    this.filterVal = target.value;
    const regex = new RegExp(`([^,]*?${this.filterVal}[^,]*):(\\d+)`, 'g');
    this.filteredEmojis = Array.from(this.emojiList['search'].matchAll(regex)).map((m) => {
      return { name: m[1], emoji: this.emojiList['emojis'][m[2]] };
    });
  }
  handleEmojiClick(emoji) {
    this.emojiClicked.emit(emoji);
  }
  mapEmojiList() {
    var _a;
    if (((_a = this.emojiList) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      return (h("div", { id: "loader" }, h("dyte-spinner", { iconPack: this.iconPack, t: this.t })));
    }
    return (h("div", { id: "emoji-grid", class: "scrollbar max-w-40" }, this.filteredEmojis.map((e) => (h("dyte-button", { iconPack: this.iconPack, t: this.t, key: `emoji-button-${e.name}`, class: "emoji", variant: "ghost", kind: "icon", title: e.name, onClick: () => this.handleEmojiClick(e.emoji) }, e.emoji)))));
  }
  render() {
    return (h(Host, null, h("div", { class: 'close-parent' }, h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: () => { var _a; return (_a = this.pickerClose) === null || _a === void 0 ? void 0 : _a.emit(); }, "aria-label": this.t('close') }, h("dyte-icon", { icon: this.iconPack.dismiss }))), h("div", { class: 'emoji-parent' }, h("input", { value: this.filterVal, onInput: (event) => this.handleInputChange(event.target), placeholder: this.t('search') }), this.mapEmojiList())));
  }
};
DyteEmojiPicker.style = dyteEmojiPickerCss;

const dyteJoinStageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}:host::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host(.webinar){box-sizing:border-box;display:block;width:512px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-6, 24px);-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:auto;border-radius:var(--dyte-border-radius-md, 8px);line-height:1.25}:host(.webinar) dyte-participant-setup{display:flex;flex:1 1 0%;align-items:center;justify-content:space-around;margin-left:auto;margin-right:auto}:host(.webinar) .container dyte-button{margin:var(--dyte-space-3, 12px);flex-grow:1;padding:var(--dyte-space-1, 4px);width:50%}:host(.webinar) header{padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host(.webinar) .summary{padding:var(--dyte-space-4, 16px)}:host(.livestream){box-sizing:border-box;display:block;width:512px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding:var(--dyte-space-8, 32px);-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:auto;border-radius:var(--dyte-border-radius-md, 8px);line-height:1.25}:host(.livestream) dyte-participant-setup{display:flex;width:100%;flex:1 1 0%;align-items:center;justify-content:space-around;margin-left:auto;margin-right:auto}:host(.livestream) .container dyte-button{flex-grow:1;padding:var(--dyte-space-1, 4px);width:50%}:host(.livestream) .container dyte-button:nth-child(1){margin-right:var(--dyte-space-1\\.5, 6px)}:host(.livestream) .container dyte-button:nth-child(2){margin-left:var(--dyte-space-1\\.5, 6px)}:host(.livestream) h2{font-size:24px;font-weight:500;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host(.livestream) .summary{margin-top:var(--dyte-space-6, 24px);margin-bottom:var(--dyte-space-6, 24px);text-align:left;font-size:14px}.deny-access{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.container{width:100%;max-width:1080px;display:flex;flex:1 1 0%;align-items:center;justify-content:space-around}header{display:flex;align-items:center;justify-content:space-between}";

const DyteJoinStage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.joinStage = createEvent(this, "dyteJoinStage", 7);
    this.leaveStage = createEvent(this, "dyteLeaveStage", 7);
    this.meeting = undefined;
    this.config = defaultConfig;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.dataConfig = {
      title: this.t('stage.join_title'),
      label: {
        accept: this.t('stage.join_confirm'),
        reject: this.t('stage.join_cancel'),
      },
      description: this.t('stage.join_summary'),
    };
  }
  render() {
    var _a, _b, _c, _d;
    const defaults = {
      meeting: this.meeting,
      size: this.size,
      states: this.states || state,
      config: this.config,
      iconPack: this.iconPack,
      t: this.t,
    };
    return (h(Host, { class: {
        livestream: ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.meta.viewType) === 'LIVESTREAM',
        webinar: ((_b = this.meeting) === null || _b === void 0 ? void 0 : _b.meta.viewType) === 'WEBINAR',
      } }, h("header", null, h("h2", null, this.dataConfig.title)), h(Render, { element: "dyte-participant-setup", defaults: defaults, props: { participant: (_c = this.meeting) === null || _c === void 0 ? void 0 : _c.self, size: 'md' }, childProps: { participant: (_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self, size: 'md' }, deepProps: true }), h("div", { class: "summary" }, this.dataConfig.description), h("div", { class: "container" }, h("dyte-button", { variant: "secondary", onClick: () => this.leaveStage.emit(), title: this.dataConfig.label.reject, iconPack: this.iconPack, t: this.t }, this.dataConfig.label.reject), h("dyte-button", { onClick: () => this.joinStage.emit(), title: this.dataConfig.label.accept, iconPack: this.iconPack, t: this.t }, this.dataConfig.label.accept))));
  }
};
DyteJoinStage.style = dyteJoinStageCss;

const dyteNotificationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{pointer-events:none;display:block;height:var(--dyte-space-10, 40px);color:rgb(var(--dyte-colors-text-1000, 255 255 255));-webkit-animation:show 0.4s ease;animation:show 0.4s ease;transition:0.4s;z-index:100}.ctr{box-sizing:border-box;display:inline-flex;height:100%;min-width:var(--dyte-space-40, 160px);align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);--tw-shadow-color:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-shadow:var(--tw-shadow-colored);pointer-events:auto}img{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-0, 0px);width:var(--dyte-space-0, 0px);border-radius:9999px}img.loaded{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}.message{margin-right:var(--dyte-space-3, 12px);max-width:var(--dyte-space-72, 288px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.message p{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-1, 4px);display:inline-block}.message blockquote{display:none}dyte-icon.icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}dyte-icon.dismiss{margin-left:auto;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);border-radius:var(--dyte-border-radius-md, 8px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}dyte-icon.dismiss:hover{cursor:pointer;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}dyte-icon.dismiss{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}dyte-button{margin-left:var(--dyte-space-4, 16px);margin-right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px)}.right{margin-left:auto;display:flex;align-items:center}.right>*{margin-left:var(--dyte-space-2, 8px)}.right>*:first-child{margin-left:var(--dyte-space-0, 0px)}:host(.exit){-webkit-animation:exit 0.4s ease;animation:exit 0.4s ease}@-webkit-keyframes show{0%{opacity:0;transform:translateX(-120px)}100%{opacity:1;transform:translateX(0px)}}@keyframes show{0%{opacity:0;transform:translateX(-120px)}100%{opacity:1;transform:translateX(0px)}}@-webkit-keyframes exit{0%{opacity:1;transform:translateX(0)}100%{opacity:0;transform:translateX(-120px)}}@keyframes exit{0%{opacity:1;transform:translateX(0)}100%{opacity:0;transform:translateX(-120px)}}:host([size='sm']){font-size:14px}";

const DyteNotification = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dismiss = createEvent(this, "dyteNotificationDismiss", 7);
    this.notification = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.imageState = 'loading';
  }
  connectedCallback() {
    this.notificationChanged(this.notification);
  }
  notificationChanged(notification) {
    if (notification != null && typeof notification.duration === 'number') {
      setTimeout(() => {
        this.dismiss.emit(notification.id);
      }, notification.duration);
    }
  }
  render() {
    return (h(Host, null, h("div", { class: "ctr" }, this.notification.icon != null && (h("dyte-icon", { class: "icon", icon: this.notification.icon, iconPack: this.iconPack, t: this.t })), this.notification.image != null &&
      this.notification.icon == null &&
      this.imageState !== 'errored' && (h("img", { src: this.notification.image, class: { loaded: this.imageState === 'loaded' }, onLoad: () => (this.imageState = 'loaded'), onError: () => (this.imageState = 'errored') })), h("p", { class: "message" }, h(TextMessageView, { message: this.notification.message })), h("div", { class: "right" }, this.notification.button != null && (h("dyte-button", { size: "sm", variant: this.notification.button.variant, onClick: () => this.notification.button.onClick(), iconPack: this.iconPack, t: this.t }, this.notification.button.text)), h("dyte-icon", { "aria-label": this.t('dismiss'), class: "dismiss", icon: this.iconPack.dismiss, onClick: () => this.dismiss.emit(this.notification.id), iconPack: this.iconPack, t: this.t })))));
  }
  static get watchers() { return {
    "notification": ["notificationChanged"]
  }; }
};
DyteNotification.style = dyteNotificationCss;

const DEFAULT_NOTIFICATION_DURATION = 2000;
const DEFAULT_NOTIFICATION_CONFIG = Object.freeze({
  notifications: {
    participant_joined: true,
    participant_left: true,
    participant_joined_waitlist: true,
    chat: true,
    polls: true,
    webinar: true,
    tab_sync: true,
  },
  notification_sounds: {
    participant_joined: true,
    participant_left: true,
    chat: true,
    polls: true,
    webinar: true,
    participant_joined_waitlist: true,
  },
  notification_duration: {
    participant_joined: 2100,
    participant_left: 2100,
    participant_joined_waitlist: 4000,
    chat: DEFAULT_NOTIFICATION_DURATION,
    polls: DEFAULT_NOTIFICATION_DURATION,
    webinar: DEFAULT_NOTIFICATION_DURATION,
    tab_sync: DEFAULT_NOTIFICATION_DURATION,
  },
  participant_joined_sound_notification_limit: 10,
  participant_chat_message_sound_notification_limit: 10,
});

const dyteNotificationsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:absolute;top:var(--dyte-space-4, 16px);right:var(--dyte-space-4, 16px);bottom:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);top:auto;display:flex;flex-direction:column;pointer-events:none;z-index:100}dyte-notification{margin-top:var(--dyte-space-2, 8px)}";

function parseConfig(config) {
  const permissions = Object.assign({}, DEFAULT_NOTIFICATION_CONFIG);
  if (config == null)
    return permissions;
  Object.assign(permissions.notification_sounds, config.notification_sounds);
  Object.assign(permissions.notifications, config.notifications);
  Object.assign(permissions.notification_duration, config.notification_duration);
  permissions.participant_chat_message_sound_notification_limit =
    config.participant_chat_message_sound_notification_limit;
  permissions.participant_joined_sound_notification_limit =
    config.participant_joined_sound_notification_limit;
  return permissions;
}
function getEnabledSounds(sounds) {
  return Object.keys(sounds).filter((key) => sounds[key]);
}
const DyteNotifications = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.permissions = DEFAULT_NOTIFICATION_CONFIG;
    this.enabledSounds = getEnabledSounds(DEFAULT_NOTIFICATION_CONFIG.notification_sounds);
    this.addStagePeersListeners = (meeting) => {
      meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
      meeting.meta.addListener('disconnected', this.networkDisconnectedListener);
      meeting.meta.addListener('connected', this.networkConnectedListener);
      meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
    };
    this.removeStagePeersListeners = (meeting) => {
      meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
      meeting.meta.removeListener('disconnected', this.networkDisconnectedListener);
      meeting.meta.removeListener('connected', this.networkConnectedListener);
      meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
    };
    this.onRemoteUpdate = ({ payload, type }) => {
      if (type === RemoteUpdateType.INCOMING_REQUEST_ACCEPTED) {
        let remotePeer = this.meeting.participants.joined.get(payload.request.remotePeerId);
        this.add({
          id: `message-${Math.random().toString(36)}`,
          icon: this.iconPack.chat,
          message: `Granted remote control to ${remotePeer.name}`,
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
      if (type === RemoteUpdateType.OUTGOING_REQUEST_ACCEPTED) {
        let hostPeer = this.meeting.participants.joined.get(payload.request.hostPeerId);
        this.add({
          id: `message-${Math.random().toString(36)}`,
          icon: this.iconPack.chat,
          message: `${hostPeer.name} has granted remote control.`,
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
      if (type === RemoteUpdateType.REQUEST_RECEIVED) {
        let remotePeer = this.meeting.participants.joined.get(payload.request.remotePeerId);
        this.add({
          id: `message-${Math.random().toString(36)}`,
          icon: this.iconPack.chat,
          message: `${remotePeer.name} has requested for remote control.`,
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
      if (type === RemoteUpdateType.INCOMING_REQUEST_ENDED ||
        type === RemoteUpdateType.OUTGOING_REQUEST_ENDED) {
        this.add({
          id: `message-${Math.random().toString(36)}`,
          icon: this.iconPack.chat,
          message: `Existing remote control has been terminated.`,
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
      if (type === RemoteUpdateType.REQUEST_SENT) {
        let hostPeer = this.meeting.participants.joined.get(payload.request.hostPeerId);
        this.add({
          id: `message-${Math.random().toString(36)}`,
          icon: this.iconPack.chat,
          message: `Sent remote control request to ${hostPeer.name}`,
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
    };
    this.onDyteNotification = (e) => {
      this.add(e.detail);
      const playSound = e.detail.playSound;
      if (playSound != undefined)
        this.audio.play(playSound);
    };
    this.onRecordingUpdate = (recordingState) => {
      if (recordingState === 'RECORDING') {
        this.add({
          id: 'recording-started',
          icon: this.iconPack.recording,
          message: this.t('recording.started'),
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
      else if (recordingState === 'STOPPING') {
        this.add({
          id: 'recording-stopped',
          icon: this.iconPack.stop_recording,
          message: this.t('recording.stopped'),
          duration: DEFAULT_NOTIFICATION_DURATION,
        });
      }
    };
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.t = useLanguage();
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.notifications = [];
  }
  connectedCallback() {
    if (typeof document !== 'undefined') {
      document === null || document === void 0 ? void 0 : document.addEventListener('dyteNotification', this.onDyteNotification);
    }
    this.meetingChanged(this.meeting);
    this.configChanged(this.config);
    this.statesChanged(this.states);
  }
  clearListeners(meeting) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const isLivestream = meeting.meta.viewType === 'LIVESTREAM';
    if ((isLivestream && ((_a = meeting.stage) === null || _a === void 0 ? void 0 : _a.status) === 'ON_STAGE') || !isLivestream) {
      this.removeStagePeersListeners(meeting);
    }
    this.chatUpdateListener && ((_b = meeting.chat) === null || _b === void 0 ? void 0 : _b.removeListener('chatUpdate', this.chatUpdateListener));
    this.pollUpdateListener &&
      ((_c = meeting.polls) === null || _c === void 0 ? void 0 : _c.removeListener('pollsUpdate', this.pollUpdateListener));
    this.socketDisconnectedListener &&
      meeting.meta.removeListener('socketDisconnected', this.socketDisconnectedListener);
    this.socketReconnectFailureListener &&
      meeting.meta.removeListener('socketReconnectFailure', this.socketReconnectFailureListener);
    this.socketReconnectedListener &&
      meeting.meta.removeListener('socketReconnected', this.socketReconnectedListener);
    this.socketReconnectingListener &&
      meeting.meta.removeListener('socketReconnecting', this.socketReconnectingListener);
    this.socketFailureListener &&
      meeting.meta.removeListener('socketFailure', this.socketFailureListener);
    this.stageRequestAccepted &&
      ((_d = meeting.stage) === null || _d === void 0 ? void 0 : _d.removeListener('stageRequestApproved', this.stageRequestAccepted));
    this.stageRequestRejected &&
      ((_e = meeting.stage) === null || _e === void 0 ? void 0 : _e.removeListener('stageRequestRejected', this.stageRequestRejected));
    this.newStageRequests &&
      ((_f = meeting.stage) === null || _f === void 0 ? void 0 : _f.removeListener('newStageRequest', this.newStageRequests));
    this.stageStatusUpdateListener &&
      ((_g = meeting.stage) === null || _g === void 0 ? void 0 : _g.removeListener('stageStatusUpdate', this.stageStatusUpdateListener));
    (_h = meeting.remote) === null || _h === void 0 ? void 0 : _h.removeListener('remoteUpdate', this.onRemoteUpdate);
    (_j = meeting.recording) === null || _j === void 0 ? void 0 : _j.removeListener('recordingUpdate', this.onRecordingUpdate);
    clearTimeout(this.disconnectTimeout);
  }
  disconnectedCallback() {
    var _a;
    if (typeof document !== 'undefined') {
      document === null || document === void 0 ? void 0 : document.removeEventListener('dyteNotification', this.onDyteNotification);
    }
    if (this.meeting == null)
      return;
    this.clearListeners(this.meeting);
    this.waitlistedParticipantJoinedListener &&
      this.meeting.participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
    this.spotlightTabUpdateListener &&
      ((_a = this.meeting.spotlight) === null || _a === void 0 ? void 0 : _a.removeListener('activeTabUpdate', this.spotlightTabUpdateListener));
    this.peerRequestToJoinStateListener &&
      this.meeting.participants.joined.removeListener('peerRequestToJoinStage', this.peerRequestToJoinStateListener);
    this.peerAcceptedToJoinStageListener &&
      this.meeting.participants.joined.removeListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
    this.peerRejectedToJoinStageListener &&
      this.meeting.participants.joined.removeListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
  }
  meetingChanged(meeting, oldMeeting) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    clearTimeout(this.disconnectTimeout);
    if (oldMeeting !== undefined)
      this.clearListeners(oldMeeting);
    if (meeting == null)
      return;
    const isLivestream = meeting.meta.viewType === 'LIVESTREAM';
    this.audio = new DyteNotificationsAudio();
    const { notifications, notification_duration, notification_sounds } = this.permissions;
    this.participantJoinedListener = (participant) => {
      if (notifications.participant_joined) {
        this.add({
          id: `${participant.id}-joined`,
          message: `${formatName(participant.name)} just joined`,
          image: participant.picture,
          duration: notification_duration.participant_joined,
        });
      }
      if (notification_sounds.participant_joined && this.canPlayParticipantJoinedSound()) {
        this.audio.play('joined');
      }
    };
    this.participantLeftListener = (participant) => {
      if (notifications.participant_left) {
        this.add({
          id: `${participant.id}-left`,
          message: `${formatName(participant.name)} left`,
          image: participant.picture,
          duration: notification_duration.participant_left,
        });
      }
      if (notification_sounds.participant_left && this.canPlayParticipantJoinedSound()) {
        this.audio.play('left');
      }
    };
    this.waitlistedParticipantJoinedListener = (participant) => {
      const id = `${participant.id}-joined-waitlist`;
      this.add({
        id,
        message: `${formatName(participant.name)} is requesting to join the meeting`,
        image: participant.picture,
        duration: notification_duration.participant_joined_waitlist,
        button: {
          text: 'Accept',
          variant: 'secondary',
          onClick: async () => {
            await this.meeting.participants.acceptWaitingRoomRequest(participant.id);
            this.remove(id);
          },
        },
      });
      if (notification_sounds.participant_joined_waitlist && this.canPlayParticipantJoinedSound()) {
        this.audio.play('message');
      }
    };
    this.chatUpdateListener = ({ message }) => {
      const parsedMessage = parseMessageForTarget(message);
      if (parsedMessage != null) {
        if (parsedMessage.userId === meeting.self.userId) {
          return;
        }
        if (parsedMessage.type === 'text') {
          if (notifications.chat) {
            this.add({
              id: `message-${Math.random().toString(36)}`,
              icon: this.iconPack.chat,
              message: `${parsedMessage.displayName}: ${parsedMessage.message}`,
              duration: notification_duration.chat,
            });
          }
          if (notification_sounds.chat && this.canPlayChatSound()) {
            this.audio.play('message');
          }
        }
      }
    };
    this.pollUpdateListener = ({ polls, newPoll }) => {
      if (newPoll === false)
        return;
      if (notifications.polls &&
        this.meeting.self.userId !== polls[polls.length - 1].createdByUserId) {
        this.add({
          id: `poll-${Math.random().toString(36)}`,
          icon: this.iconPack.poll,
          message: `New poll created by ${polls[polls.length - 1].createdBy}`,
          duration: notification_duration.polls,
        });
      }
      if (notification_sounds.polls &&
        this.meeting.self.userId !== polls[polls.length - 1].createdByUserId &&
        this.canPlayChatSound()) {
        this.audio.play('message');
      }
    };
    this.deviceUpdateListener = ({ device, preview }) => {
      if (preview)
        return;
      if (device.kind === 'audiooutput') {
        this.audio.setDevice(device.deviceId);
        this.add({
          id: `speaker-switched-${device.deviceId}`,
          message: `Connected to ${device.label}`,
          icon: this.iconPack.speaker,
          duration: 5000,
        });
      }
      else if (device.kind === 'videoinput') {
        this.add({
          id: `camera-switched-${device.deviceId}`,
          message: `Connected to ${device.label}`,
          icon: this.iconPack.speaker,
          duration: 5000,
        });
      }
      else {
        this.add({
          id: `mic-switched-${device.deviceId}`,
          message: `Connected to ${device.label}`,
          icon: this.iconPack.mic_on,
          duration: 5000,
        });
      }
    };
    this.networkDisconnectedListener = () => {
      this.remove('network');
      let reconnectDuration;
      reconnectDuration = 20000;
      this.add({
        id: 'network',
        icon: this.iconPack.disconnected,
        message: this.t('network.reconnecting'),
        duration: reconnectDuration,
      });
      this.disconnectTimeout = setTimeout(() => {
        this.add({
          id: 'network-lost',
          icon: this.iconPack.disconnected,
          message: this.t('network.delay'),
          button: {
            text: this.t('end'),
            variant: 'danger',
            onClick: () => { var _a; return (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.leaveRoom(); },
          },
        });
      }, reconnectDuration);
    };
    this.networkConnectedListener = () => {
      this.remove('network');
      let reconnectDuration;
      this.remove('network-lost');
      reconnectDuration = 3000;
      this.add({
        id: `network`,
        icon: this.iconPack.wifi,
        message: this.t('network.restored'),
        duration: reconnectDuration,
      });
      clearTimeout(this.disconnectTimeout);
    };
    this.socketUpdateListener = ({ event, attempt }) => {
      this.remove('socket');
      if (event === 'reconnected') {
        this.remove('socketReconnecting');
        this.add({
          id: `socket`,
          icon: this.iconPack.wifi,
          message: this.t('network.restored'),
          duration: 3000,
        });
      }
      else if (event === 'disconnected') {
        this.add({
          id: 'socket',
          icon: this.iconPack.disconnected,
          message: this.t('network.lost'),
          duration: 3000,
        });
      }
      else if (event === 'reconnecting') {
        this.add({
          id: 'socketReconnecting',
          icon: this.iconPack.disconnected,
          message: this.t('network.lost_extended'),
        });
      }
      else if (event === 'reconnectFailure') {
        if (attempt > 5) {
          this.remove('socketReconnecting');
          this.add({
            id: 'socketReconnecting',
            icon: this.iconPack.disconnected,
            message: this.t('network.delay_extended'),
            button: {
              text: this.t('end'),
              variant: 'danger',
              onClick: () => { var _a; return (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.leaveRoom(); },
            },
          });
        }
      }
      else if (event === 'failed') {
        this.remove('socketReconnecting');
        this.add({
          id: 'socketFailed',
          icon: this.iconPack.disconnected,
          message: this.t('network.disconnected'),
        });
        this.add({
          id: 'leaveMeeting',
          icon: this.iconPack.warning,
          message: this.t('network.leaving'),
        });
        setTimeout(() => {
          var _a;
          (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.leaveRoom('disconnected');
        }, 10000);
      }
    };
    this.spotlightTabUpdateListener = (spotlightTab) => {
      if (!notifications.tab_sync)
        return;
      switch (spotlightTab.type) {
        case 'plugin':
          const spotlightPlugin = meeting.plugins.active
            .toArray()
            .find((plugin) => plugin.id == spotlightTab.id);
          if (spotlightPlugin != undefined) {
            this.add({
              id: 'spotlight',
              message: `Plugin switched to ${spotlightPlugin.name}`,
              duration: notification_duration.participant_joined,
            });
          }
          break;
        case 'screenshare':
          const screenShareParticipant = meeting.participants.joined
            .toArray()
            .filter((participant) => participant.screenShareEnabled)
            .find((participant) => participant.id == spotlightTab.id);
          if (screenShareParticipant != undefined) {
            this.add({
              id: 'spotlight',
              message: `Now watching ${screenShareParticipant.name}'s screen`,
              duration: notification_duration.webinar,
            });
          }
          break;
      }
    };
    this.peerRequestToJoinStateListener = ({ id }) => {
      if (!notifications.webinar)
        return;
      const participant = this.meeting.participants.joined.get(id);
      if (participant !== undefined) {
        this.add({
          id: `webinar-request-${id}`,
          message: `${participant.name} is requesting to be on stage`,
          duration: notification_duration.webinar,
          button: {
            text: 'Accept',
            variant: 'primary',
            onClick: async () => {
              await this.meeting.participants.acceptAllRequestToJoinStageRequests([
                {
                  id,
                  requestToJoinType: 'REQUEST_TO_PRESENT',
                },
              ]);
              this.remove(`webinar-request-${id}`);
            },
          },
        });
        if (notification_sounds.webinar) {
          this.audio.play('joined');
        }
      }
    };
    this.peerAcceptedToJoinStageListener = (request) => {
      if (!notifications.webinar)
        return;
      const participant = this.meeting.participants.joined.get(request.id);
      if (participant !== undefined) {
        this.add({
          id: `webinar-accepted-${request.id}`,
          message: `Approved ${participant.name}'s request to join stage.`,
          duration: notification_duration.webinar,
        });
        if (notification_sounds.webinar) {
          this.audio.play('joined');
        }
      }
    };
    this.peerRejectedToJoinStageListener = (request) => {
      if (!notifications.webinar)
        return;
      const participant = this.meeting.participants.joined.get(request.id);
      if (participant !== undefined) {
        this.add({
          id: `webinar-rejected-${request.id}`,
          message: `Rejected ${participant.name}'s request to join stage.`,
          duration: notification_duration.webinar,
        });
      }
    };
    this.stageRequestAccepted = () => {
      this.add({
        id: 'stage-request-accepted',
        message: 'Request to join accepted',
        duration: 3000,
      });
    };
    this.stageRequestRejected = () => {
      this.add({
        id: 'stage-request-rejected',
        message: 'Request to join rejected',
        duration: 3000,
      });
    };
    this.newStageRequests = ({ count }) => {
      this.add({
        id: 'new-stage-request',
        message: `You have ${count} pending request${count === 1 ? '' : 's'}`,
        duration: 3000,
      });
    };
    this.stageStatusUpdateListener = (status) => {
      if (status === 'ON_STAGE')
        this.addStagePeersListeners(meeting);
      else
        this.removeStagePeersListeners(meeting);
    };
    this.socketReconnectedListener = () => this.socketUpdateListener({ event: 'reconnected' });
    this.socketDisconnectedListener = () => this.socketUpdateListener({ event: 'disconnected' });
    this.socketReconnectingListener = () => this.socketUpdateListener({ event: 'reconnecting' });
    this.socketFailureListener = () => this.socketUpdateListener({ event: 'failed' });
    this.socketReconnectFailureListener = ({ attempt }) => this.socketUpdateListener({
      event: 'reconnectFailure',
      attempt,
    });
    !showLivestream(meeting) && ((_a = meeting.chat) === null || _a === void 0 ? void 0 : _a.addListener('chatUpdate', this.chatUpdateListener));
    if (meeting.self.config.viewType === 'CHAT') {
      return;
    }
    // all non Chat viewtype code from here
    const currentDevices = meeting.self.getCurrentDevices();
    if (currentDevices.speaker != null) {
      this.audio.setDevice(currentDevices.speaker.deviceId);
    }
    if (isLivestream)
      (_b = meeting.stage) === null || _b === void 0 ? void 0 : _b.on('stageStatusUpdate', this.stageStatusUpdateListener);
    else
      this.addStagePeersListeners(meeting);
    meeting.participants.joined.addListener('peerRequestToJoinStage', this.peerRequestToJoinStateListener);
    meeting.participants.joined.addListener('peerAcceptedToJoinStage', this.peerAcceptedToJoinStageListener);
    meeting.participants.joined.addListener('peerRejectedToJoinStage', this.peerRejectedToJoinStageListener);
    if (this.canAcceptWaitingRequests()) {
      meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
    }
    (_c = meeting.polls) === null || _c === void 0 ? void 0 : _c.addListener('pollsUpdate', this.pollUpdateListener);
    meeting.self.addListener('deviceUpdate', this.deviceUpdateListener);
    meeting.meta.addListener('socketReconnected', this.socketReconnectedListener);
    meeting.meta.addListener('socketDisconnected', this.socketDisconnectedListener);
    meeting.meta.addListener('socketReconnecting', this.socketReconnectingListener);
    meeting.meta.addListener('socketFailure', this.socketFailureListener);
    meeting.meta.addListener('socketReconnectFailure', this.socketReconnectFailureListener);
    (_d = meeting.remote) === null || _d === void 0 ? void 0 : _d.addListener('remoteUpdate', this.onRemoteUpdate);
    (_e = meeting.spotlight) === null || _e === void 0 ? void 0 : _e.addListener('activeTabUpdate', this.spotlightTabUpdateListener);
    (_f = meeting.recording) === null || _f === void 0 ? void 0 : _f.addListener('recordingUpdate', this.onRecordingUpdate);
    (_g = meeting.stage) === null || _g === void 0 ? void 0 : _g.addListener('stageRequestApproved', this.stageRequestAccepted);
    (_h = meeting.stage) === null || _h === void 0 ? void 0 : _h.addListener('stageRequestRejected', this.stageRequestRejected);
    if (meeting.self.permissions.acceptPresentRequests)
      (_j = meeting.stage) === null || _j === void 0 ? void 0 : _j.addListener('newStageRequest', this.newStageRequests);
  }
  configChanged(config) {
    if (config != null) {
      if ((config === null || config === void 0 ? void 0 : config.config) != null) {
        this.permissions = parseConfig(config.config);
        this.enabledSounds = getEnabledSounds(this.permissions.notification_sounds);
      }
    }
  }
  statesChanged(states) {
    var _a;
    if (states != null) {
      const notificationSoundsEnabled = !((_a = states === null || states === void 0 ? void 0 : states.prefs) === null || _a === void 0 ? void 0 : _a.muteNotificationSounds);
      // toggle only the notification sounds values which were enabled in the first place
      for (const permission of this.enabledSounds) {
        if (permission in this.permissions.notification_sounds) {
          this.permissions.notification_sounds[permission] = notificationSoundsEnabled;
        }
      }
    }
  }
  apiErrorListener({ detail }) {
    const { trace, message } = detail;
    this.add({
      id: trace,
      message,
      duration: DEFAULT_NOTIFICATION_DURATION,
      icon: this.iconPack.warning,
    });
  }
  add(notification) {
    // show notifications only if tab is in focus and a maximum of 5 at a time
    if (document.visibilityState === 'visible' && this.notifications.length < 5) {
      // adds new notification to start of array so they appear at the bottom
      this.notifications = [...this.notifications, notification];
    }
  }
  remove(id) {
    this.notifications = this.notifications.filter((notification) => notification.id !== id);
  }
  handleDismiss(e) {
    e.stopPropagation();
    const id = e.detail;
    const el = this.host.shadowRoot.querySelector(`[data-id="${id}"]`);
    // exit animation
    el === null || el === void 0 ? void 0 : el.classList.add('exit');
    setTimeout(() => {
      writeTask(() => {
        this.remove(id);
      });
    }, 400);
  }
  canPlayParticipantJoinedSound() {
    return (this.permissions.participant_joined_sound_notification_limit == undefined ||
      this.permissions.participant_joined_sound_notification_limit <= 0 ||
      this.meeting.participants.count <=
        this.permissions.participant_joined_sound_notification_limit);
  }
  canPlayChatSound() {
    return (this.permissions.participant_chat_message_sound_notification_limit == undefined ||
      this.permissions.participant_chat_message_sound_notification_limit <= 0 ||
      this.meeting.participants.count <=
        this.permissions.participant_chat_message_sound_notification_limit);
  }
  canAcceptWaitingRequests() {
    return (this.permissions.notifications.participant_joined_waitlist &&
      this.meeting.self.permissions.acceptWaitingRequests);
  }
  render() {
    return (h(Host, null, this.notifications.map((notification) => (h("dyte-notification", { size: this.size, key: notification.id, "data-id": notification.id, notification: notification, onDyteNotificationDismiss: (e) => this.handleDismiss(e), iconPack: this.iconPack, t: this.t })))));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "config": ["configChanged"],
    "states": ["statesChanged"]
  }; }
};
DyteNotifications.style = dyteNotificationsCss;

const dyteOverlayModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0.6);position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);z-index:50}dyte-icon{height:var(--dyte-space-20, 80px)}h2{margin:var(--dyte-space-2, 8px);font-weight:500}p{margin:var(--dyte-space-0, 0px);font-size:16px}";

const DyteOverlayModal = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.meeting = undefined;
    this.states = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  connectedCallback() {
    if (this.states.activeOverlayModal.timeout) {
      setTimeout(() => {
        this.stateUpdate.emit({ activeOverlayModal: { active: false } });
        state.activeOverlayModal = { active: false };
      }, this.states.activeOverlayModal.timeout);
    }
  }
  componentDidLoad() { }
  disconnectedCallback() { }
  render() {
    return (h(Host, null, h("dyte-icon", { icon: this.states.activeOverlayModal.icon, iconPack: this.iconPack, t: this.t }), h("h2", null, this.states.activeOverlayModal.title), h("p", null, this.states.activeOverlayModal.description)));
  }
};
DyteOverlayModal.style = dyteOverlayModalCss;

var dyteChannelDetails_14_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_channel_details: DyteChannelDetails,
    dyte_channel_header: DyteChannelHeader,
    dyte_channel_selector_ui: DyteChannelSelectorUi,
    dyte_chat_composer_ui: DyteChatComposerUi,
    dyte_chat_messages_ui: DyteChatMessagesUi,
    dyte_chat_messages_ui_paginated: DyteChatMessagesUiPaginated,
    dyte_chat_search_results: DyteChatSearchResults,
    dyte_chat_selector_ui: DyteChatSelectorUi,
    dyte_dialog_manager: DyteDialogManager,
    dyte_emoji_picker: DyteEmojiPicker,
    dyte_join_stage: DyteJoinStage,
    dyte_notification: DyteNotification,
    dyte_notifications: DyteNotifications,
    dyte_overlay_modal: DyteOverlayModal
});

const dyteParticipantCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;height:var(--dyte-space-14, 56px);align-items:center;justify-content:space-between;cursor:pointer;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host dyte-avatar{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);font-size:14px}.left{display:flex;align-items:center}.left>*{margin-right:var(--dyte-space-2, 8px)}.left>*:last-child{margin-right:var(--dyte-space-0, 0px)}.right{display:flex;align-items:center;justify-content:flex-end}.right>*{margin-left:var(--dyte-space-2, 8px)}.right>*:first-child{margin-left:var(--dyte-space-0, 0px)}.name{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}dyte-icon.red{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon.more{cursor:pointer}";

const DyteParticipant = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.pinnedListener = ({ isPinned }) => {
      this.isPinned = isPinned;
    };
    this.stageListener = ({ webinarStageStatus }) => {
      this.isOnStage = webinarStageStatus === 'ON_STAGE';
    };
    this.meeting = undefined;
    this.view = 'sidebar';
    this.participant = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.audioEnabled = false;
    this.videoEnabled = false;
    this.isPinned = false;
    this.isOnStage = false;
    this.canDisableParticipantAudio = false;
    this.canDisableParticipantVideo = false;
    this.canKickParticipant = false;
    this.canPinParticipant = false;
    this.canAllowParticipantOnStage = false;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
    this.participantChanged(this.participant);
  }
  disconnectedCallback() {
    if (this.participant == null || this.participant.removeListener == undefined)
      return;
    this.audioUpdateListener &&
      this.participant.removeListener('audioUpdate', this.audioUpdateListener);
    this.videoUpdateListener &&
      this.participant.removeListener('videoUpdate', this.videoUpdateListener);
    this.participant.removeListener('pinned', this.pinnedListener);
    this.participant.removeListener('unpinned', this.pinnedListener);
    this.participant.removeListener('peerStartedPresenting', this.stageListener);
    this.participant.removeListener('peerStoppedPresenting', this.stageListener);
  }
  meetingChanged(meeting) {
    if (meeting != null) {
      const { self } = meeting;
      this.canDisableParticipantAudio =
        self.permissions.canAllowParticipantAudio || self.permissions.canDisableParticipantAudio;
      this.canDisableParticipantVideo =
        self.permissions.canAllowParticipantVideo || self.permissions.canDisableParticipantVideo;
      this.canKickParticipant = self.permissions.kickParticipant;
      this.canPinParticipant = self.permissions.pinParticipant;
      this.canAllowParticipantOnStage = self.permissions.acceptPresentRequests;
    }
  }
  participantChanged(participant) {
    if (participant != null) {
      this.audioEnabled = participant.audioEnabled;
      this.videoEnabled = participant.videoEnabled;
      this.isPinned = participant.isPinned;
      this.isOnStage = participant.webinarStageStatus === 'ON_STAGE';
      this.audioUpdateListener = ({ audioEnabled }) => {
        this.audioEnabled = audioEnabled;
      };
      this.videoUpdateListener = ({ videoEnabled }) => {
        this.videoEnabled = videoEnabled;
      };
      if (participant.addListener == undefined)
        return;
      participant.addListener('audioUpdate', this.audioUpdateListener);
      participant.addListener('videoUpdate', this.videoUpdateListener);
      participant.addListener('pinned', this.pinnedListener);
      participant.addListener('unpinned', this.pinnedListener);
      participant.addListener('peerStartedPresenting', this.stageListener);
      participant.addListener('peerStoppedPresenting', this.stageListener);
    }
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const showMenu = this.canDisableParticipantAudio ||
      this.canDisableParticipantVideo ||
      this.canKickParticipant ||
      this.canPinParticipant;
    const name = formatName(((_a = this.participant) === null || _a === void 0 ? void 0 : _a.name) || '');
    // NOTE(@madhugb): Show some actions for only on stage / non-webinar participants
    const isActiveParticipant = this.isOnStage || ((_c = (_b = this.meeting) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.viewType) === 'GROUP_CALL';
    const isSelf = ((_d = this.meeting) === null || _d === void 0 ? void 0 : _d.self.id) === this.participant.id;
    return (h(Host, null, h("div", { class: "left" }, h("dyte-avatar", { participant: this.participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: name }, shorten(name, 16), " ", ((_e = this.meeting) === null || _e === void 0 ? void 0 : _e.self.id) === ((_f = this.participant) === null || _f === void 0 ? void 0 : _f.id) && this.t('(you)'))), this.view === 'sidebar' && (h("div", { class: "right" }, isActiveParticipant && (h("dyte-icon", { class: {
        red: !this.audioEnabled,
      }, iconPack: this.iconPack, t: this.t, icon: this.audioEnabled ? this.iconPack.mic_on : this.iconPack.mic_off })), isActiveParticipant && (h("dyte-icon", { class: {
        red: !this.videoEnabled,
      }, iconPack: this.iconPack, t: this.t, icon: this.videoEnabled ? this.iconPack.video_on : this.iconPack.video_off })), showMenu && (h("dyte-menu", { iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "ghost", kind: "icon", slot: "trigger", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { class: "more", icon: this.iconPack.more_vertical })), h("dyte-menu-list", { iconPack: this.iconPack, t: this.t }, this.canPinParticipant && isActiveParticipant && (h("dyte-menu-item", { onClick: () => {
        if (this.isPinned) {
          this.participant.unpin();
        }
        else {
          this.participant.pin();
        }
      }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.isPinned ? this.iconPack.pin_off : this.iconPack.pin, slot: "start", iconPack: this.iconPack, t: this.t }), this.isPinned ? this.t('unpin') : this.t('pin'))), this.canDisableParticipantAudio && isActiveParticipant && this.audioEnabled && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, onClick: () => {
        this.participant.disableAudio();
      } }, h("dyte-icon", { icon: this.iconPack.mic_off, slot: "start" }), this.t('mute'))), this.canDisableParticipantVideo && isActiveParticipant && this.videoEnabled && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, onClick: () => {
        this.participant.disableVideo();
      } }, h("dyte-icon", { icon: this.iconPack.video_off, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('participants.turn_off_video'))), ((_g = this.meeting) === null || _g === void 0 ? void 0 : _g.meta.viewType) === 'WEBINAR' &&
      this.canAllowParticipantOnStage &&
      ((_h = this.participant) === null || _h === void 0 ? void 0 : _h.id) !== ((_j = this.meeting) === null || _j === void 0 ? void 0 : _j.self.id) && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, class: this.isOnStage ? 'red' : '', onClick: async () => {
        const p = this.participant;
        if (this.isOnStage) {
          // NOTE (@madhugb): when a pinned participnat is removed from stage, we need to unpin them manually
          if (p.isPinned)
            p.unpin();
          await p.removeFromStage();
        }
        else {
          await p.acceptJoinStageRequest();
        }
        this.isOnStage = !this.isOnStage;
      } }, h("dyte-icon", { iconPack: this.iconPack, t: this.t, icon: this.isOnStage ? this.iconPack.leave_stage : this.iconPack.join_stage, slot: "start" }), this.isOnStage
      ? this.t('stage.remove_from_stage')
      : this.t('stage.add_to_stage'))), !isSelf && this.canKickParticipant && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, class: "red", onClick: () => {
        var _a, _b;
        (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.participants.kick((_b = this.participant) === null || _b === void 0 ? void 0 : _b.id);
      } }, h("dyte-icon", { icon: this.iconPack.dismiss, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('kick'))))))))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"],
    "participant": ["participantChanged"]
  }; }
};
DyteParticipant.style = dyteParticipantCss;

var dyteParticipant_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participant: DyteParticipant
});

const dyteParticipantTileCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;align-items:center;justify-content:center;aspect-ratio:16 / 9;height:var(--dyte-space-56, 224px);overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));transition-property:var(--dyte-transition-property, all);transition-duration:150ms}@media (prefers-reduced-motion){:host{--dyte-transition-property:none}}::slotted(dyte-name-tag){position:absolute;left:var(--dyte-space-3, 12px);bottom:var(--dyte-space-3, 12px)}:host([size='sm'][variant='solid']) ::slotted(dyte-name-tag){left:var(--dyte-space-2, 8px);bottom:var(--dyte-space-2, 8px);height:var(--dyte-space-4, 16px)}::slotted(dyte-network-indicator){position:absolute;right:var(--dyte-space-3, 12px);bottom:var(--dyte-space-3, 12px)}:host([size='sm']) ::slotted(dyte-network-indicator){right:var(--dyte-space-2, 8px);bottom:var(--dyte-space-2, 8px)}video{display:none;position:absolute;height:100%;width:100%;border-radius:var(--dyte-border-radius-lg, 12px)}video.contain{-o-object-fit:contain;object-fit:contain}video.cover{-o-object-fit:cover;object-fit:cover}video.visible{display:block}video::-webkit-media-controls{display:none !important}.pinned-icon{position:absolute;left:var(--dyte-space-3, 12px);top:var(--dyte-space-3, 12px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);padding:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) .pinned-icon{top:var(--dyte-space-2, 8px);left:var(--dyte-space-2, 8px)}:host([variant='gradient']) ::slotted(dyte-audio-visualizer){position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px)}:host([variant='gradient']) ::slotted(dyte-name-tag){bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);display:flex;width:100%;align-items:center;justify-content:center;text-align:center;background-color:transparent;background-image:linear-gradient(to top, var(--tw-gradient-stops));--tw-gradient-from:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-gradient-to:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to);--tw-gradient-to:transparent}video.mirror{transform:scaleX(-1)}:host([name-tag-position='bottom-right']) ::slotted(dyte-name-tag){left:auto;right:var(--dyte-space-3, 12px)}:host([name-tag-position='bottom-center']) ::slotted(dyte-name-tag){left:auto;right:auto}:host([name-tag-position='top-left']) ::slotted(dyte-name-tag){top:var(--dyte-space-3, 12px);bottom:auto}:host([name-tag-position='top-right']) ::slotted(dyte-name-tag){top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);left:auto;bottom:auto}:host([name-tag-position='top-center']) ::slotted(dyte-name-tag){left:auto;right:auto;bottom:auto;top:var(--dyte-space-3, 12px)}";

const DyteParticipantTile = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onVideoUpdate = (videoState) => {
      this.videoState = videoState;
      if (this.participant == null)
        return;
      if (videoState.videoEnabled) {
        store.enableSource(this.participant.id);
      }
      else {
        store.disableSource(this.participant.id);
      }
    };
    this.onPinned = ({ isPinned }) => {
      this.isPinned = isPinned;
    };
    this.isSelf = () => { var _a; return this.isPreview || this.participant.id === ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self.id); };
    this.videoState = undefined;
    this.isPinned = false;
    this.nameTagPosition = 'bottom-left';
    this.isPreview = false;
    this.participant = undefined;
    this.meeting = undefined;
    this.states = undefined;
    this.config = defaultConfig;
    this.variant = 'solid';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  onVideoRef(el) {
    this.videoEl = el;
    if (this.isPreview || this.participant == null) {
      return;
    }
    store.addSource(this.participant.id, this.videoEl, this.participant.videoEnabled);
    if (this.participant.videoEnabled) {
      store.enableSource(this.participant.id);
    }
  }
  participantVideoUpdate(p) {
    if (p.id !== this.participant.id)
      return;
    this.onVideoUpdate({
      videoEnabled: p.videoEnabled,
      videoTrack: p.videoTrack,
    });
  }
  connectedCallback() {
    // set videoState before initial render and initialize listeners
    this.participantsChanged(this.participant);
  }
  componentDidLoad() {
    // load videoState into video element after first render
    this.videoStateChanged(this.videoState);
  }
  disconnectedCallback() {
    if (this.playTimeout)
      clearTimeout(this.playTimeout);
    if (this.participant == null)
      return;
    const { self } = this.meeting;
    if (this.participant.id === self.id)
      this.participant.removeListener('videoUpdate', this.onVideoUpdate);
    else
      this.meeting.participants.joined.removeListener('videoUpdate', this.participantVideoUpdate);
    this.participant.removeListener('pinned', this.onPinned);
    this.participant.removeListener('unpinned', this.onPinned);
    store.removeSource(this.participant.id);
  }
  participantsChanged(participant) {
    if (participant != null) {
      const { self } = this.meeting;
      this.videoState = {
        videoEnabled: participant.videoEnabled,
        videoTrack: participant.videoTrack,
      };
      this.isPinned = participant.isPinned;
      if (participant.id === self.id)
        participant.addListener('videoUpdate', this.onVideoUpdate);
      else
        this.meeting.participants.joined.addListener('videoUpdate', this.participantVideoUpdate.bind(this));
      participant.addListener('pinned', this.onPinned);
      participant.addListener('unpinned', this.onPinned);
    }
  }
  videoStateChanged(videoState) {
    var _a;
    if (videoState != null && this.videoEl != null) {
      if (videoState.videoEnabled) {
        if ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__.features.hasFeature(FlagsmithFeatureFlags.LOG_PLAYING_FAILURES)) {
          if (this.playTimeout)
            clearTimeout(this.playTimeout);
          this.playTimeout = setTimeout(() => {
            var _a;
            (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__.logger.log('dyte-participant-tile::playing_timeout');
          }, 6000);
        }
        const stream = new MediaStream();
        if (videoState.videoTrack == null)
          return;
        stream.addTrack(videoState.videoTrack);
        this.videoEl.srcObject = stream;
      }
      else {
        if (this.playTimeout)
          clearTimeout(this.playTimeout);
        this.videoEl.srcObject = undefined;
      }
    }
  }
  isMirrored() {
    var _a;
    if (this.participant != null) {
      if (this.isSelf()) {
        const states = this.states || state;
        const mirrorVideo = (_a = states === null || states === void 0 ? void 0 : states.prefs) === null || _a === void 0 ? void 0 : _a.mirrorVideo;
        if (typeof mirrorVideo === 'boolean') {
          return mirrorVideo;
        }
      }
    }
    return false;
  }
  render() {
    var _a, _b, _c, _d;
    return (h(Host, null, h("video", { ref: (el) => this.onVideoRef(el), class: {
        visible: (_a = this.videoState) === null || _a === void 0 ? void 0 : _a.videoEnabled,
        mirror: this.isMirrored(),
        [(_d = (_c = (_b = this.config) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.videoFit) !== null && _d !== void 0 ? _d : 'cover']: true,
      }, onPlaying: () => {
        if (this.playTimeout)
          clearTimeout(this.playTimeout);
      }, onPause: (event) => {
        var _a, _b;
        if (this.isSelf() &&
          ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.__internals__.features.hasFeature(FlagsmithFeatureFlags.PLAY_PARTICIPANT_TILE_VIDEO_ON_PAUSE))) {
          this.meeting.__internals__.logger.warn(`Video player paused for ${this.participant.id} isSelf: ${this.isSelf()}`);
          // @ts-ignore
          (_b = event === null || event === void 0 ? void 0 : event.target) === null || _b === void 0 ? void 0 : _b.play();
        }
      }, autoPlay: true, playsInline: true, muted: true }), this.isPinned && (h("dyte-icon", { class: "pinned-icon", icon: this.iconPack.pin, "aria-label": this.t('pinned'), iconPack: this.iconPack, t: this.t })), h("slot", null)));
  }
  static get watchers() { return {
    "participant": ["participantsChanged"],
    "videoState": ["videoStateChanged"]
  }; }
};
DyteParticipantTile.style = dyteParticipantTileCss;

var dyteParticipantTile_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_participant_tile: DyteParticipantTile
});

const dytePollCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.ctr{margin-bottom:var(--dyte-space-3, 12px);display:flex;width:83.333333%;flex-direction:column;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.poll-title{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.poll{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));display:flex;flex-direction:column;padding:var(--dyte-space-3, 12px)}.poll p{margin:var(--dyte-space-0, 0px)}.poll-question{font-size:12px;font-weight:700;overflow-wrap:break-word}.poll-option{display:flex;flex-direction:column;margin-top:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);word-break:break-word}.poll-option label{display:flex;flex-direction:row}.poll-option-header{display:flex;flex-direction:row;justify-content:space-between;padding:var(--dyte-space-1, 4px)}.poll-option-header:hover{cursor:pointer}.poll-option-header[data-disabled=true]:hover{cursor:default}.poll-option-header input{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-2, 8px)}.votes{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;flex-wrap:wrap}.vote{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);display:flex;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-none, 0);-webkit-clip-path:circle();clip-path:circle()}.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}";

const DytePolls = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onVote = createEvent(this, "dyteVotePoll", 7);
    this.poll = undefined;
    this.self = undefined;
    this.permissions = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  vote(e, index) {
    if (this.poll.voted.includes(this.self)) {
      e.preventDefault();
    }
    else {
      this.onVote.emit({ id: this.poll.id, index });
    }
  }
  render() {
    return (h(Host, null, h("div", { class: "ctr" }, h("p", { class: "poll-title" }, this.t('polls.by'), " ", shorten(formatName(this.poll.createdBy), 20)), h("div", { class: "poll" }, h("p", { class: "poll-question" }, this.poll.question), this.poll.options.map((item, index) => (h("div", { class: {
        active: item.votes.some((x) => x.id === this.self),
        'poll-option': true,
      } }, h("div", { class: "poll-option-header", "data-disabled": !this.permissions.polls.canVote }, h("label", null, h("input", { disabled: !this.permissions.polls.canVote, type: "radio", checked: item.votes.some((x) => x.id === this.self), onClick: (e) => this.vote(e, index) }), h("p", null, item.text, " (", item.count, ")"))), h("div", { class: "votes" }, item.votes.map((vote) => {
      if (this.poll.anonymous && this.self !== this.poll.createdByUserId)
        return;
      return (h("dyte-tooltip", { label: vote.name, iconPack: this.iconPack, t: this.t }, h("div", { class: "vote" }, getInitials(vote.name))));
    })))))))));
  }
};
DytePolls.style = dytePollCss;

const dytePollFormCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.create-poll{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);display:flex;flex:1 1 0%;flex-direction:column;padding:var(--dyte-space-3, 12px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.create-poll p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);text-align:center}.create-poll textarea{display:flex;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);font-family:var(--dyte-font-family, sans-serif);border-width:var(--dyte-border-width-none, 0);border-style:none;font-weight:500;outline:2px solid transparent;outline-offset:2px;margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);resize:vertical;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.create-poll textarea:focus{outline-style:solid;outline-offset:2px;outline-color:rgb(var(--dyte-colors-background-600, 60 60 60))}.option{display:flex;flex-direction:row;align-items:center;margin-bottom:var(--dyte-space-3, 12px);width:100%}.option input{width:100%;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.remove-option{margin-left:var(--dyte-space-2, 8px);width:var(--dyte-space-10, 40px);border-radius:var(--dyte-border-radius-sm, 4px)}.add-option{margin-bottom:var(--dyte-space-3, 12px)}label{margin-bottom:var(--dyte-space-3, 12px)}.error-text{margin-top:var(--dyte-space-3, 12px);text-align:center;font-size:12px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DytePoll = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onCreate = createEvent(this, "dyteCreatePoll", 7);
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.options = ['', ''];
    this.anonymous = false;
    this.hideVotes = true;
    this.error = undefined;
  }
  removeOption(index) {
    var _a;
    this.options = this.options.filter((_, ind) => ind !== index);
    if (((_a = this.error) === null || _a === void 0 ? void 0 : _a.code) === 1)
      this.error = undefined;
  }
  addOption() {
    this.options = [...this.options, ''];
  }
  updateOption(ev, index) {
    var _a;
    this.options[index] = ev.target.value;
    if (((_a = this.error) === null || _a === void 0 ? void 0 : _a.code) === 1)
      this.error = undefined;
  }
  handleSubmit() {
    const pollObject = {
      question: this.question.value,
      options: this.options,
      anonymous: this.anonymous,
      hideVotes: this.anonymous ? true : this.hideVotes,
    };
    if (!pollObject.question) {
      this.error = {
        code: 0,
        message: this.t('polls.errors.question_required'),
      };
      return;
    }
    if (this.options.filter((op) => op.trim() === '').length > 0) {
      this.error = {
        code: 1,
        message: this.t('polls.errors.empty_opt'),
      };
      return;
    }
    this.onCreate.emit(pollObject);
  }
  render() {
    return (h(Host, null, h("div", { class: "create-poll" }, h("p", null, this.t('polls.question')), h("textarea", { onInput: () => {
        if (this.error && this.error.code === 0)
          this.error = undefined;
      }, ref: (e) => (this.question = e), placeholder: this.t('polls.question.placeholder') }), this.options.map((item, index) => (h("div", { class: "option" }, h("input", { placeholder: this.t('polls.option.placeholder'), value: item, onInput: (event) => this.updateOption(event, index) }), index > 1 && (h("dyte-button", { kind: "icon", class: "auto remove-option", variant: "secondary", onClick: () => this.removeOption(index), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.subtract, iconPack: this.iconPack, t: this.t })))))), h("dyte-button", { class: "add-option", variant: "secondary", onClick: () => this.addOption(), iconPack: this.iconPack, t: this.t }, this.t('polls.option')), h("label", null, h("input", { id: "anonymous", type: "checkbox", onChange: (e) => (this.anonymous = e.target.checked) }), this.t('polls.results.anon')), h("label", null, h("input", { id: "hideVotes", type: "checkbox", disabled: this.anonymous, checked: this.anonymous ? true : this.hideVotes, onChange: (e) => (this.hideVotes = e.target.checked) }), this.t('polls.results.hide')), h("dyte-button", { kind: "wide", onClick: () => this.handleSubmit(), iconPack: this.iconPack, t: this.t }, this.t('polls.create')), this.error && h("span", { class: "error-text" }, this.error.message))));
  }
};
DytePoll.style = dytePollFormCss;

var dytePoll_2_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_poll: DytePolls,
    dyte_poll_form: DytePoll
});

const dyteSpotlightIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{font-size:12px}#sync-button{flex-direction:row;border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-1, 4px);display:flex;height:var(--dyte-space-16, 64px);width:100%;align-items:center;justify-content:center;margin-bottom:var(--dyte-space-2, 8px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) #sync-button{flex-direction:column-reverse;display:flex;height:var(--dyte-space-10, 40px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center}:host([size='md']) #sync-button{flex-direction:column-reverse;display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center}:host([size='lg']) #sync-button{flex-direction:row;display:flex;height:var(--dyte-space-8, 32px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center}@media (orientation: portrait){:host([size='lg']) #sync-button{flex-direction:column-reverse;display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center}:host([size='sm']) #sync-button{height:var(--dyte-space-10, 40px);width:var(--dyte-space-16, 64px);flex-direction:row}}#sync-button>dyte-icon{max-height:14px}#sync-button dyte-icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}#sync-button.active dyte-icon{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}div{align-content:center;line-height:2rem}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-8, 32px)}#sync-button.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-bg-opacity))}";

const DyteSpotlightIndicator = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.size = undefined;
    this.canSpotlight = undefined;
    this.isSpotlighted = undefined;
  }
  connectedCallback() {
    this.meetingChanged(this.meeting);
  }
  meetingChanged(meeting) {
    var _a, _b;
    if (meeting != null) {
      this.canSpotlight = meeting.self.permissions.canSpotlight;
      this.isSpotlighted = (_b = (_a = meeting.spotlight) === null || _a === void 0 ? void 0 : _a.spotlighted) !== null && _b !== void 0 ? _b : false;
    }
  }
  updateSpotlightState(spotlighted) {
    var _a;
    try {
      (_a = this.meeting.spotlight) === null || _a === void 0 ? void 0 : _a.setSpotlighted(spotlighted);
      this.isSpotlighted = spotlighted;
    }
    catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
    }
  }
  render() {
    if (!this.canSpotlight)
      return;
    return (h(Host, null, h("dyte-tooltip", { size: 'md', iconPack: this.iconPack, t: this.t, label: this.t('remote_access.indicator') }, h("div", { id: "sync-button", class: {
        tab: true,
        active: this.isSpotlighted,
      }, onClick: () => this.updateSpotlightState(!this.isSpotlighted) }, h("span", { class: "name" }, "Sync"), h("dyte-icon", { id: "icon", iconPack: this.iconPack, t: this.t, icon: this.isSpotlighted ? this.iconPack.checkmark : this.iconPack.warning, tabIndex: -1, "aria-hidden": true })))));
  }
  static get watchers() { return {
    "meeting": ["meetingChanged"]
  }; }
};
DyteSpotlightIndicator.style = dyteSpotlightIndicatorCss;

var dyteSpotlightIndicator_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_spotlight_indicator: DyteSpotlightIndicator
});

const dyteChatMessageCss = ".message-wrapper{display:flex;gap:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-4, 16px);margin-right:var(--dyte-space-4, 16px);margin-top:var(--dyte-space-4, 16px)}[is-continued] .message-wrapper{margin-top:var(--dyte-space-0, 0px)}.message-wrapper.align-right{flex-direction:row-reverse}.avatar{display:none}.file-picker{display:none}.message{position:relative;display:flex}.show-on-hover dyte-menu{visibility:hidden}.show-on-hover:hover dyte-menu{visibility:visible}.align-right .message{justify-content:flex-end;margin-left:auto}.align-right .message .head{margin-right:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-0, 0px);flex-direction:row-reverse;gap:var(--dyte-space-4, 16px)}.align-right .message dyte-text-message .bubble,.align-right .message dyte-image-message .bubble,.align-right .message dyte-file-message .bubble{padding-right:var(--dyte-space-5, 20px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right .message .actions dyte-icon{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right dyte-menu{left:auto;right:var(--dyte-space-0, 0px)}.head{margin-bottom:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-1, 4px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.head .name{font-size:14px;font-weight:600}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}dyte-menu{position:absolute;left:var(--dyte-space-0, 0px);top:var(--dyte-space-6, 24px);border-radius:var(--dyte-border-radius-lg, 12px)}dyte-menu dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);cursor:pointer}[is-continued] dyte-menu{top:var(--dyte-space-2, 8px)}.actions{display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0\\.5, 2px);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}.actions dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.body{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);overflow-wrap:break-word;font-size:14px;line-height:1.375}.body .emoji{font-size:24px}.body.bubble{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-1, 4px);max-width:var(--dyte-space-96, 384px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-left:var(--dyte-space-5, 20px);padding-right:var(--dyte-space-5, 20px);overflow-wrap:break-word;font-size:14px;line-height:1.375;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.body.bubble p{margin:var(--dyte-space-0, 0px);word-break:break-word}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-text-message,dyte-image-message,dyte-file-message{display:block;font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}*[is-continued]{margin-top:var(--dyte-space-0, 0px)}.image{position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}.file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1\\.5, 6px);padding-bottom:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.file .file-data{flex:1 1 0%}.file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.new-chat-marker{display:flex;width:100%;align-items:center;gap:var(--dyte-space-2, 8px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.new-chat-marker::before{content:'';height:1px;flex:1 1 0%;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.show-new-messages-ctr{pointer-events:none;display:flex;justify-content:flex-end;padding:var(--dyte-space-3, 12px);z-index:0;margin-top:calc(var(--dyte-space-14, 56px) * -1)}.show-new-messages{pointer-events:auto;--tw-translate-y:calc(var(--dyte-space-6, 24px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}blockquote{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px);background-color:transparent}.block-quote,blockquote{--tw-border-spacing-x:1px;--tw-border-spacing-y:1px;border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-md, 2px);border-right-width:var(--dyte-border-width-none, 0);border-style:solid;border-left-color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));padding:var(--dyte-space-0\\.5, 2px);padding-left:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px) !important;border-radius:var(--dyte-border-radius-sm, 4px);border-top-left-radius:var(--dyte-border-radius-none, 0);border-bottom-left-radius:var(--dyte-border-radius-none, 0)}.link{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.align-right .block-quote{border-color:rgb(var(--dyte-colors-text-on-brand-600, var(--dyte-colors-text-600, 255 255 255 / 0.52)));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity))}.align-right .link{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right .image .actions dyte-icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}@media (orientation: landscape) and (min-width: 400px){.avatar{display:flex;width:var(--dyte-space-6, 24px)}.avatar dyte-avatar{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);font-size:10px}.message{width:75%}}";

const DyteChatMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.edit = createEvent(this, "edit", 7);
    this.reply = createEvent(this, "reply", 7);
    this.delete = createEvent(this, "delete", 7);
    this.renderMessage = () => {
      switch (this.message.type) {
        case 'text':
          return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-text-message", { message: this.message, now: this.now, isContinued: this.isContinued, "data-timestamp": this.message.time.getTime(), iconPack: this.iconPack, t: this.t, showBubble: true })));
        case 'image':
          return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-image-message", { message: this.message, now: this.now, isContinued: this.isContinued, iconPack: this.iconPack, "data-timestamp": this.message.time.getTime(), t: this.t, showBubble: true })));
        case 'file':
          return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-file-message", { message: this.message, now: this.now, isContinued: this.isContinued, iconPack: this.iconPack, t: this.t, "data-timestamp": this.message.time.getTime(), showBubble: true })));
      }
    };
    this.onReply = () => {
      this.reply.emit(this.message);
    };
    this.onDelete = () => {
      this.delete.emit(this.message);
    };
    this.onEdit = async () => {
      this.edit.emit(this.message);
    };
    this.isTouchDevice = () => {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    };
    this.message = undefined;
    this.isContinued = undefined;
    this.isUnread = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isSelf = false;
    this.canEdit = false;
    this.canDelete = false;
    this.canReply = false;
    this.disableControls = false;
    this.alignRight = false;
    this.senderDisplayPicture = undefined;
    this.hideAvatar = false;
    this.now = new Date();
  }
  renderControls() {
    if (this.disableControls)
      return;
    return (h("dyte-menu", { placement: this.alignRight ? 'bottom-end' : 'bottom-start' }, h("button", { slot: "trigger", class: "actions" }, h("dyte-icon", { icon: this.iconPack.chevron_down })), h("dyte-menu-list", null, this.canReply && (h("dyte-menu-item", { onClick: this.onReply }, h("dyte-icon", { icon: this.iconPack.back, slot: "start" }), this.t('chat.reply'))), this.canEdit && (h("dyte-menu-item", { onClick: this.onEdit }, h("dyte-icon", { icon: this.iconPack.edit, slot: "start" }), this.t('chat.edit_msg'))), this.canDelete && (h("dyte-menu-item", { onClick: this.onDelete }, h("dyte-icon", { icon: this.iconPack.delete, slot: "start" }), this.t('chat.delete_msg'))))));
  }
  renderAvatar() {
    if (this.hideAvatar)
      return;
    if (this.isContinued) {
      return h("div", { class: "avatar" });
    }
    return (h("div", { class: "avatar" }, h("dyte-avatar", { size: "sm", participant: {
        name: this.message.displayName,
        picture: this.senderDisplayPicture,
      } })));
  }
  render() {
    return (h(Host, null, h("div", { class: { 'message-wrapper': true, 'align-right': this.alignRight }, "is-continued": this.isContinued }, this.renderAvatar(), h("div", { class: { message: true, 'show-on-hover': !this.isTouchDevice() }, "is-continued": this.isContinued }, this.renderMessage(), this.renderControls()))));
  }
  get $el() { return getElement(this); }
};
DyteChatMessage.style = dyteChatMessageCss;

const DyteFileMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.message = undefined;
    this.now = new Date();
    this.isContinued = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showBubble = false;
  }
  render() {
    const link = sanitizeLink(this.message.link);
    return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
        body: true,
        bubble: this.showBubble,
      }, part: "body" }, h("div", { class: "file" }, h("div", { class: "file-data" }, h("div", { class: "name" }, this.message.name), h("div", { class: "file-data-split" }, h("div", { class: "ext" }, getExtension(this.message.name)), h("span", { class: "divider" }), h("div", { class: "size" }, getFileSize(this.message.size)))), h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => downloadFile(link, { name: this.message.name, fallbackName: 'file' }), part: "button" }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t }))))));
  }
};

const dyteImageMessageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.image-spinner{cursor:wait}.image-errored{cursor:not-allowed}";

const DyteImageMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
    this.message = undefined;
    this.now = new Date();
    this.isContinued = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showBubble = false;
    this.status = 'loading';
  }
  render() {
    return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
        body: true,
        bubble: this.showBubble,
      }, part: "body" }, h("div", { class: { image: true, loaded: this.status === 'loaded' } }, h("img", { src: sanitizeLink(this.message.link), onLoad: () => {
        this.status = 'loaded';
      }, onError: () => {
        this.status = 'errored';
      }, onClick: () => {
        if (this.status === 'loaded') {
          this.stateUpdate.emit({ image: this.message });
          state.image = this.message;
        }
      } }), this.status === 'loading' && (h("div", { class: "image-spinner", title: this.t('chat.img.loading'), "aria-label": this.t('chat.img.loading') }, h("dyte-spinner", { iconPack: this.iconPack, t: this.t }))), this.status === 'errored' && (h("div", { class: "image-errored", title: this.t('chat.error.img_not_found'), "aria-label": this.t('chat.error.img_not_found') }, h("dyte-icon", { icon: this.iconPack.image_off, iconPack: this.iconPack, t: this.t }))), this.status === 'loaded' && (h("div", { class: "actions" }, h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => {
        this.stateUpdate.emit({ image: this.message });
        state.image = this.message;
      }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.full_screen_maximize })), h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => downloadFile(this.message.link, { fallbackName: 'image' }), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t }))))))));
  }
};
DyteImageMessage.style = dyteImageMessageCss;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

const dytePaginatedListCss = ".scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;flex:1}.container{box-sizing:border-box;display:flex;flex-direction:column-reverse;padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);flex:1 0 0px;overflow-y:scroll;}.file-picker{display:none}.chat *:first-child{margin-top:var(--dyte-space-0, 0px)}.chat .head{display:flex;align-items:center}.chat .head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.chat .head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);overflow-wrap:break-word;font-size:14px;line-height:1.375}.chat .body .emoji{font-size:24px}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-text-message,dyte-image-message,dyte-file-message{margin-top:var(--dyte-space-4, 16px);display:block;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}*[is-continued]{margin-top:var(--dyte-space-3, 12px)}dyte-text-message[is-continued]{margin-top:var(--dyte-space-2, 8px)}.chat .image{position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.chat .image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.chat .image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.chat .image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.chat .image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.chat .image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}.chat .file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1\\.5, 6px);padding-bottom:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.chat .file .file-data{flex:1 1 0%}.chat .file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.chat .file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.chat .file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}.smallest-dom-element{width:1px}#top-scroll{transform:translateY(20vh)}#bottom-scroll{transform:translateY(-20vh)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.show-new-messages-ctr{pointer-events:none;position:absolute;bottom:var(--dyte-space-2, 8px);right:var(--dyte-space-4, 16px);z-index:10;margin-top:calc(var(--dyte-space-14, 56px) * -1);--tw-translate-y:var(--dyte-space-14, 56px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages-ctr.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}.show-new-messages{pointer-events:auto;border-radius:9999px}.show-new-messages:hover{border-radius:9999px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-opacity:1;--tw-ring-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-ring-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}dyte-spinner,.empty-list{margin:auto}";

const DytePaginatedList = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    /**
     * This is a private variable not a state
     * since we want to debounce rerenders
     *
     * A list of pages where each page contains a number of Nodes
     * [
     *  [Node 1, Node 2, Node 3.... Node N],
     *  [Node 1, Node 2, Node 3.... Node N],
     * ]
     */
    this.pagesToRender = [[]];
    this.currentTime = () => {
      return new Date().getTime();
    };
    this.observe = (el) => {
      if (!el)
        return;
      this.intersectionObserver.observe(el);
    };
    this.pageSize = undefined;
    this.pagesAllowed = undefined;
    this.fetchData = undefined;
    this.createNodes = undefined;
    this.selectedItemId = undefined;
    this.autoScroll = true;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.emptyListLabel = null;
    this.isLoading = false;
    this.rerenderBoolean = false;
    this.shouldRenderNewNodes = true;
    this.hasNewNodesToRender = false;
    this.showEmptyListLabel = false;
  }
  /**
   * On a new node created
   */
  async onNewNode(node) {
    if (!this.shouldRenderNewNodes) {
      this.hasNewNodesToRender = true;
      return;
    }
    this.addNodeToRender(node, false);
    this.rerender();
  }
  /**
   * On node deleted
   */
  async onNodeDelete(key) {
    const oldLength = this.pagesToRender.flat().length;
    this.pagesToRender = this.pagesToRender.map((page) => page.filter((item) => item.id !== key));
    if (oldLength !== this.pagesToRender.flat().length) {
      this.rerender();
    }
  }
  /**
   * On node updated
   */
  async onNodeUpdate(key, newItem) {
    let shouldRerender = false;
    this.pagesToRender = this.pagesToRender.map((page) => page.map((item) => {
      if (item.id === key) {
        shouldRerender = true;
        return newItem;
      }
      return item;
    }));
    if (shouldRerender)
      this.rerender();
  }
  onItemChanged(newItemId, oldItemId) {
    if (newItemId !== oldItemId) {
      this.pagesToRender = [[]];
      this.loadFirstPage().then(() => this.rerender());
    }
  }
  connectedCallback() {
    this.rerender = debounce(this.rerender.bind(this), 50, { maxWait: 200 });
    this.loadFirstPage();
    this.intersectionObserver = new IntersectionObserver((entries) => {
      writeTask(() => {
        for (const entry of entries) {
          if (entry.target.id === 'bottom-scroll') {
            if (entry.isIntersecting)
              this.loadBottom();
            else
              this.shouldRenderNewNodes = false;
          }
          if (entry.target.id === 'top-scroll' && entry.isIntersecting) {
            this.loadTop();
          }
        }
      });
    });
  }
  disconnectedCallback() {
    this.intersectionObserver.disconnect();
  }
  componentDidLoad() {
    /**
     * Adding observes here so that on the first render we scroll down
     * and shouldRenderNewNodes remains true
     */
    this.observe(this.$topRef);
    this.observe(this.$bottomRef);
  }
  componentDidRender() {
    if (this.shouldRenderNewNodes && this.autoScroll)
      smoothScrollToBottom(this.$paginatedList);
  }
  loadFirstPage() {
    return this.loadPage(this.currentTime(), this.pageSize, true, (data) => {
      if (data.length === 0) {
        this.showEmptyListLabel = true;
      }
    });
  }
  loadTop() {
    /**
     * If there is only one unfilled page or no page, no need to check
     * for top since it will be empty
     */
    if (this.pagesToRender.length === 0)
      return;
    if (this.pagesToRender.length === 1 && this.pagesToRender[0].length < this.pageSize)
      return;
    /**
     * TODO: Make this more flexible currently this only works with chat
     */
    const oldestVNode = this.pagesToRender[0][0];
    const oldestTimestamp = oldestVNode.timeMs;
    // TODO: scrollIntoView
    const onPageRendered = () => { }; // oldestVNode.$elm$?.scrollIntoView();
    this.loadPage(oldestTimestamp - 1, this.pageSize, true, onPageRendered);
  }
  loadBottom() {
    /**
     * If there is only one unfilled page or no page, no need to check
     * for top since it will be empty
     */
    if (this.pagesToRender.length === 0) {
      this.shouldRenderNewNodes = true;
      return;
    }
    if (this.pagesToRender.length === 1 && this.pagesToRender[0].length < this.pageSize) {
      this.shouldRenderNewNodes = true;
      return;
    }
    const newestVNode = this.pagesToRender.at(-1).at(-1);
    const newestTimestamp = newestVNode.timeMs;
    // TODO: scrollIntoView
    const onPageRendered = () => smoothScrollToBottom(this.$paginatedList);
    this.loadPage(newestTimestamp + 1, this.pageSize, false, onPageRendered);
  }
  addNodeToRender(node, addToStart) {
    if (addToStart) {
      const firstPage = this.pagesToRender[0];
      if (firstPage && (firstPage === null || firstPage === void 0 ? void 0 : firstPage.length) < this.pageSize) {
        /**
         * If first page is not full then just add to that page
         */
        firstPage.unshift(node);
      }
      else {
        /**
         * If first page is full then add a new page to the start
         */
        const newPage = [node];
        this.pagesToRender.unshift(newPage);
        this.removeLastPageIfNeeded(false);
      }
    }
    else {
      const [lastPage] = this.pagesToRender.slice(-1);
      if (lastPage && (lastPage === null || lastPage === void 0 ? void 0 : lastPage.length) < this.pageSize) {
        /**
         * If last page is not full then just add it
         */
        lastPage.push(node);
      }
      else {
        /**
         * If last page is full add a new page with just
         * this node
         */
        const newPage = [node];
        this.pagesToRender.push(newPage);
        this.removeLastPageIfNeeded(true);
      }
    }
  }
  /**
   * @param start
   * @param end
   * @param reversed Defines whether to add the page at the beginning or the end
   * @param onPageLoaded Callback for when all new nodes are rendered
   */
  async loadPage(timestamp, size, reversed, onPageRendered = () => { }) {
    this.isLoading = true;
    const data = (await this.fetchData(timestamp, size, reversed));
    this.isLoading = false;
    if (!(data === null || data === void 0 ? void 0 : data.length)) {
      /**
       * While scrolling down if there were no new items found
       * then start rendering new nodes;
       */
      if (!reversed) {
        this.hasNewNodesToRender = false;
        this.shouldRenderNewNodes = true;
      }
      onPageRendered([]);
      return;
    }
    // const page = this.createNodes(data);
    // const lastNodeToBeRendered = page[page.length - 1];
    // let lastNodeToBeRenderedProxy = new Proxy(lastNodeToBeRendered, {
    //   set(obj, prop, value) {
    //     /**
    //      * Whenever the last node has the 'elm' property added to it
    //      * we can assume it has been rendered
    //      */
    //     if (prop === '$elm$' && value && !obj.$elm$) onPageRendered();
    //     obj[prop] = value;
    //     return true;
    //   },
    // });
    // page[page.length - 1] = lastNodeToBeRenderedProxy;
    data.forEach((node) => this.addNodeToRender(node, reversed));
    this.rerender();
    onPageRendered(data);
  }
  rerender() {
    this.rerenderBoolean = !this.rerenderBoolean;
  }
  removeLastPageIfNeeded(removeFromStart) {
    if (this.pagesToRender.length > this.pagesAllowed) {
      if (removeFromStart)
        this.pagesToRender.shift();
      else
        this.pagesToRender.pop();
    }
  }
  onDownArrowClicked() {
    /**
     * Load the freshest pages
     */
    this.loadBottom();
  }
  render() {
    var _a;
    /**
     * div.container is flex=column-reverse
     * which is why div#bottom-scroll comes before div#top-scroll
     * div.page-wrapper prevents reversal of messages
     */
    return (h(Host, null, h("div", { class: "scrollbar container", part: "container", ref: (el) => (this.$paginatedList = el) }, h("div", { class: { 'show-new-messages-ctr': true, active: !this.shouldRenderNewNodes } }, h("dyte-button", { class: "show-new-messages", kind: "icon", variant: "secondary", part: "show-new-messages", onClick: () => this.onDownArrowClicked(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t }))), h("div", { class: "smallest-dom-element", id: "bottom-scroll", ref: (el) => (this.$bottomRef = el) }), this.isLoading && this.pagesToRender.flat().length === 0 && h("dyte-spinner", { size: "lg" }), this.pagesToRender.flat().length === 0 && this.showEmptyListLabel ? (h("div", { class: "empty-list" }, (_a = this.emptyListLabel) !== null && _a !== void 0 ? _a : this.t('list.empty'))) : (h("div", { class: "page-wrapper" }, this.pagesToRender.map((page) => this.createNodes(page)))), h("div", { class: "smallest-dom-element", id: "top-scroll", ref: (el) => (this.$topRef = el) }))));
  }
  static get watchers() { return {
    "selectedItemId": ["onItemChanged"]
  }; }
};
DytePaginatedList.style = dytePaginatedListCss;

const DyteTextMessage = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.message = undefined;
    this.now = new Date();
    this.isContinued = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.showBubble = false;
  }
  render() {
    return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
        body: true,
        bubble: this.showBubble,
      }, part: "body" }, h("div", { class: { text: true, emoji: hasOnlyEmojis(this.message.message) } }, h(TextMessageView, { message: this.message.message })))));
  }
};

var dyteChatMessage_5_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_chat_message: DyteChatMessage,
    dyte_file_message: DyteFileMessage,
    dyte_image_message: DyteImageMessage,
    dyte_paginated_list: DytePaginatedList,
    dyte_text_message: DyteTextMessage
});

function getDeniedSteps({ osName, browserName, media }) {
  function getDevice() {
    if (media === 'audio')
      return 'Microphone';
    if (media === 'video')
      return 'Camera';
    return 'Screenshare';
  }
  if (browserName === 'Chrome') {
    return [
      'Open Chrome browser settings by clicking the three dots at the top right.',
      'Select Settings, Under Privacy and Security, click Site Settings, navigate to Permissions.',
      `Choose ${getDevice()}, provide the appropriate permission and reload this application.`,
    ];
  }
  if (browserName === 'Safari') {
    return [
      'Open Safari browser settings by clicking on Safari > Preferences at the top left.',
      `Under Websites, select ${getDevice()} from the devices on the left and pick this webiste.`,
      'Allow permissions from the pop-up menu and reload this application.',
    ];
  }
  if (browserName.includes('Opera')) {
    let results = [];
    if (osName === 'macOS' || osName === 'iOS') {
      results.push('To open settings, click Opera in the toolbar (top-left) > Preferences.');
    }
    else {
      results.push('To open settings, click the Opera icon (top-left) > Settings.');
    }
    results = [
      ...results,
      'Under Privacy and Security, click Site Settings.',
      `Select ${getDevice()}, enable permissions and reload this application.`,
    ];
    return results;
  }
  if (browserName === 'Firefox') {
    let results = [];
    if (osName === 'macOS' || osName === 'iOS') {
      results.push('To open settings, at the top right, click Preferneces');
    }
    else {
      results.push('To open settings, at the top right, click Options');
    }
    results = [
      ...results,
      'Under Privacy and Security, scroll down to the  Permissions  section',
      `Select Settings for ${getDevice()}`,
      'Enter the website URL in the search field, enable permissions and reload this application.',
    ];
    return results;
  }
  if (browserName.includes('Edge')) {
    return [
      'To open settings, at the top right click Settings & More > Settings.',
      `Under Site Premissions, click ${getDevice()}.`,
      'Use the drop-down menu and select the default device, allow permission and reload this application.',
    ];
  }
}
function getSysDeniedSteps({ osName, media }) {
  function getDevice() {
    if (media === 'audio')
      return 'Microphone';
    if (media === 'video')
      return 'Camera';
    return 'Screenshare';
  }
  if (osName === 'macOS') {
    return [
      ' To give ${getDevice()} access to your browser, choose Apple menu  > System Settings, then click Privacy & Security.',
      `From the sidebar select ${getDevice()}`,
      `If you don’t see  ${getDevice()}, upgrade to macOS Mojave or later.`,
      'Allow access to your browser,',
      'Reload this application.',
    ];
  }
  if (osName === 'iOS') {
    return [
      `To give ${getDevice()} access to your browser, go to phone Settings > Privacy.`,
      `Tap on ${getDevice()}. Allow access for your browser.`,
      'Reload this application.',
    ];
  }
  if (osName === 'Windows') {
    return [
      `To give ${getDevice()} access to your browser, go to the Start menu on Windows.`,
      `Select Settings > Privacy > ${getDevice()}`,
      `Allow permissions and reload this application.`,
    ];
  }
  if (osName.includes('Android')) {
    return [
      `To give ${getDevice()} access to your browser, go to phone Settings > Apps.`,
      'Select your browser from the list',
      `Tap Permissions and allow ${getDevice()} permissions.`,
      'Reload this application.',
    ];
  }
  return [];
}
function getDeniedImage({ browserName, isMobile, osName }) {
  if (browserName === 'Chrome') {
    if (!isMobile && osName === 'macOS')
      return 'Desktop_Chrome.mp4'; //macOS
    if (!isMobile)
      return ''; //windows
    if (osName === 'iOS')
      return 'Chrome_ios.mp4'; //iOS
    else
      return 'Android_Chrome.mp4'; //android
  }
  if (browserName === 'Firefox') {
    if (!isMobile && osName === 'macOs')
      return 'Desktop_Firefox.mp4'; //macOS
    if (!isMobile)
      return ''; //windows
    if (osName === 'iOS')
      return ''; // iOS
    else
      return 'Android_Firefox.mp4'; //android
  }
  if (browserName === 'Safari') {
    if (!isMobile)
      return 'Desktop_Safari.mp4'; // macOS
    return 'iOS Safari.mp4'; //iOS
  }
  if (browserName.includes('Edge')) {
    if (!isMobile && osName === 'macOs')
      return 'Desktop_Edge.mp4'; //macOS
    if (!isMobile)
      return ''; //windows
    if (osName === 'iOS')
      return ''; // iOS
    else
      return ''; //android
  }
  if (browserName === 'Opera') {
    if (!isMobile && osName === 'macOs')
      return ''; //macOS
    if (!isMobile)
      return ''; //windows
    if (osName === 'iOS')
      return ''; // iOS
    else
      return ''; //android
  }
  if (browserName === 'Opera') {
    if (!isMobile)
      return ''; // need
    if (osName === 'iOS')
      return ''; // need
    else
      return ''; // need
  }
}
function getSysDeniedImage({ osName }) {
  if (osName === 'macOS')
    return '';
  if (osName === 'iOS')
    return '';
  if (osName === 'Windows')
    return '';
  if (osName.includes('Android'))
    return '';
}
const audioPermissions = {
  ACCEPTED: {
    info: 'Permission granted',
    icon: 'checkmark',
    text: 'Your audio devices, such as microphones and speakers, should work as expected.',
    steps: () => [],
    image: () => '',
  },
  SYSTEM_DENIED: {
    info: 'Permission denied by system',
    icon: 'dismiss',
    text: 'Your browser does not have the required permissions to access your microphone',
    steps: getSysDeniedSteps,
    image: getSysDeniedImage,
  },
  DENIED: {
    info: 'Permission denied by browser',
    icon: 'dismiss',
    text: 'We do not have the required permissions to access your microphone',
    steps: getDeniedSteps,
    image: getDeniedImage,
  },
  COULD_NOT_START: {
    info: 'Could not start device',
    icon: 'dismiss',
    text: 'Access to the microphone may be restricted by a hardware error in the operating system or browser',
    steps: () => [
      'Restart your browser.',
      'Update your browser.',
      'If using an external device, try switching to another device.',
      'Switch to a different browser.',
    ],
    image: () => '',
  },
  NOT_REQUESTED: {
    info: 'You have not yet used your microphone yet',
    icon: 'warning',
    text: 'We cannot access the data to troubleshoot unless you try to use the microphone at least once. Please click on the "Allow Permissions" button to fix this. Others will not be able to hear you.',
    steps: () => [],
    image: () => '',
  },
};
const videoPermissions = {
  ACCEPTED: {
    info: 'Permission granted',
    icon: 'checkmark',
    text: 'Your camera devices should work as expected',
    steps: () => [],
    image: () => '',
  },
  SYSTEM_DENIED: {
    info: 'Permission denied by system',
    icon: 'dismiss',
    text: 'Your browser does not have the required permissions to access your camera',
    steps: getSysDeniedSteps,
    image: getSysDeniedImage,
  },
  DENIED: {
    info: 'Permission denied by browser',
    icon: 'dismiss',
    text: 'We do not not have the required permissions to access your camera',
    steps: getDeniedSteps,
    image: getDeniedImage,
  },
  COULD_NOT_START: {
    info: 'Could not start device',
    icon: 'dismiss',
    text: 'Access to the camera may be restricted by a hardware error in the operating system or browser',
    steps: () => [
      'Restart your browser.',
      'Update your browser.',
      'If using an external device, try switching to another device.',
      'Switch to a different browser.',
    ],
    image: () => '',
  },
  NOT_REQUESTED: {
    info: 'You have not yet used your camera yet',
    icon: 'warning',
    text: 'We cannot access the data to troubleshoot unless you try to use the camera at least once. Please click on the "Allow Permissions" button to fix this. Others will not be able to see you.',
    steps: () => [],
    image: () => '',
  },
};
const screensharePermissions = {
  ACCEPTED: {
    info: 'Permission granted',
    icon: 'checkmark',
    text: 'Your screen share should work as expected',
    steps: () => [],
    image: () => '',
  },
  SYSTEM_DENIED: {
    info: 'Permission denied by system',
    icon: 'dismiss',
    text: 'Your browser does not have the required permissions to share screen',
    steps: getSysDeniedSteps,
    image: getSysDeniedImage,
  },
  DENIED: {
    info: 'Permission denied by browser',
    icon: 'dismiss',
    text: 'We do not have the required permissions to share screen',
    steps: getDeniedSteps,
    image: getDeniedImage,
  },
  COULD_NOT_START: {
    info: 'Could not start screenshare',
    icon: 'dismiss',
    text: 'Access for screen share may be restricted by a hardware error in the operating system or browser',
    steps: () => [
      'Restart your browser.',
      'Update your browser to the latest version.',
      'Try sharing a tab or window instead of the entire screen.',
      'Switch a different browser.',
    ],
    image: () => '',
  },
  NOT_REQUESTED: {
    info: 'You have not yet used shared screen yet',
    icon: 'warning',
    text: 'We cannot access the data to troubleshoot unless you screenshare at least once. You can try screensharing fix this.',
    steps: () => [],
    image: () => '',
  },
};
const audioIssues = [
  {
    index: 0,
    value: 'Please select an issue',
    steps: [],
    troubleshoot: false,
  },
  {
    index: 1,
    value: "Participants can't hear me",
    steps: [
      'Please make sure that your microphone is unmuted. You can do this by clicking on the mic icon from the control bar.',
      'If using an external device, please make sure that you are sitting close to the microphone.',
    ],
    troubleshoot: false,
  },
  {
    index: 2,
    value: "I can't hear participants",
    steps: [
      'Please ensure that the window or tab is not muted.',
      'Please ensure that the volume level of your audio device is not set to 0.',
      'Please ensure you are connected to the correct speaker device.',
    ],
    troubleshoot: false,
  },
  {
    index: 3,
    value: 'My audio is laggy',
    steps: [
      'Please ensure that you have a stable internet connection.',
      'Please try switching to a different audio device.',
      'If your network connection is weak, consider disabling your video to improve the audio bandwidth.',
    ],
    troubleshoot: false,
  },
  {
    index: 4,
    value: 'My audio is unclear',
    steps: [
      'Please make sure you are using a good-quality microphone.',
      'Please make sure you are in close proximity to the microphone.',
    ],
    troubleshoot: false,
  },
  {
    index: 5,
    value: "Participant's audio is laggy",
    steps: [
      'Please ensure that you have a stable internet connection.',
      'Please request the participant to use an alternative audio device.',
      'If your network connection is weak, consider disabling your video to improve the audio bandwidth.',
    ],
    troubleshoot: false,
  },
  {
    index: 6,
    value: 'The audio from a participant is not clear',
    steps: [
      "Please ensure that your system's speaker volume is checked and adjusted if necessary.",
      'Please request the participant to move close to the microphone.',
    ],
    troubleshoot: false,
  },
];
const videoIssues = [
  {
    index: 0,
    value: 'Please select an issue',
    steps: [],
    troubleshoot: false,
  },
  {
    index: 1,
    value: "Participants can't see my video",
    steps: [
      'Please ensure you have turned on your video from the control bar.',
      'If using an external device, please ensure your device is connected and working properly.',
    ],
    troubleshoot: false,
  },
  {
    index: 2,
    value: 'Not able to view participnats video',
    steps: [
      'Please ensure you have a stable internet connection.',
      'If you have a poor network connection, please try moving closer to the Wi-Fi router.',
    ],
    troubleshoot: false,
  },
  {
    index: 3,
    value: 'My video is laggy',
    steps: [
      'Please ensure that you have a stable internet connection.',
      'Please try switching to a different video device.',
    ],
    troubleshoot: false,
  },
  {
    index: 4,
    value: 'My video is unclear',
    steps: [
      'Please ensure you are not using a faulty device.',
      'Please make sure you are in a well-lit area.',
      'Please ensure you have a stable internet connection.',
    ],
    troubleshoot: false,
  },
  {
    index: 5,
    value: "Participant's video is laggy",
    steps: [
      'Please ensure you have a stable internet connection.',
      'Please request the participant to use an alternative video device.',
      'If your network connection is weak, consider disabling your video to improve the audio bandwidth.',
    ],
    troubleshoot: false,
  },
  {
    index: 6,
    value: "Participant's video is unclear",
    steps: [
      'Please ensure you have a stable internet connection.',
      'Please ensure the participant is not using a faulty device.',
      'Please make sure the participant is in a well-lit area.',
    ],
    troubleshoot: false,
  },
];
const screenshareIssues = [
  {
    index: 0,
    value: 'Please select an issue',
    steps: [],
    troubleshoot: false,
  },
  {
    index: 1,
    value: 'There is a delay in my screen sharing',
    steps: ['Please ensure you have a stable internet connection.'],
    troubleshoot: false,
  },
  {
    index: 2,
    value: "There is a delay in participant's screen share",
    steps: ['Please ensure you have a stable internet connection.'],
    troubleshoot: false,
  },
  {
    index: 3,
    value: 'Not able to start or stop screen share',
    steps: [
      'This error is most likely related to the browser or system you are using. Please ensure that your browser is updated to the latest version.',
      'Please try switching to another browser',
      'Please try sharing a tab or a window incase you are unable to share your entire screen.',
    ],
    troubleshoot: false,
  },
  {
    index: 4,
    value: "Not able to view a participant's screen share",
    steps: ['Please ensure you have a stable internet connection.'],
    troubleshoot: false,
  },
];
const permissionPrompts = {
  audio: audioPermissions,
  video: videoPermissions,
  screenshare: screensharePermissions,
};
const issueList = {
  audio: audioIssues,
  video: videoIssues,
  screenshare: screenshareIssues,
};

const dyteDebuggerIssuesUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{display:flex;width:100%;flex-direction:column;align-items:flex-start;justify-content:flex-start}.section{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start}.title{display:flex;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;flex-direction:row;align-items:center;justify-content:center;font-size:16px;font-weight:700;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.title dyte-icon{margin-right:var(--dyte-space-2, 8px)}.sub-title{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));letter-spacing:0.5px}.text{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);font-size:14px;font-weight:100 !important;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.recommendation{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:flex-start;justify-content:flex-start;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.recommendation div{margin-right:var(--dyte-space-2, 8px)}.device{margin-top:var(--dyte-space-4, 16px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);font-size:12px}select{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0) !important;border-style:none !important;outline:2px solid transparent !important;outline-offset:2px !important}.dyte-select{width:100%;max-width:100%;font-size:14px}.disabled{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.report-link{margin-bottom:var(--dyte-space-2, 8px);margin-top:var(--dyte-space-6, 24px);cursor:pointer;font-size:12px;--tw-text-opacity:1 !important;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity)) !important;-webkit-text-decoration-line:underline;text-decoration-line:underline}.report-issue{margin-top:var(--dyte-space-2, 8px)}";

const DyteDebuggerAudio$1 = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.mediaType = undefined;
    this.issueIndex = 0;
    this.reported = true;
  }
  selectIssue(val) {
    this.issueIndex = parseInt(val);
    this.reported = false;
    setTimeout(() => {
      var _a;
      (_a = this.reportEl) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
    }, 100);
  }
  // TODO: (ishita1805) Send surrounding data for issues in phase 3.
  reportIssue() {
    const { value } = issueList[this.mediaType][this.issueIndex];
    this.meeting.__internals__.logger.info('dyteTroubleshooting::issue', {
      issue: value,
    });
    this.reported = true;
    setTimeout(() => {
      this.reported = false;
    }, 3000);
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g;
    const issues = (_a = issueList[this.mediaType]) !== null && _a !== void 0 ? _a : [];
    return (h(Host, null, h("div", { class: "text" }, this.t('Please select a prompt that best describes your issue')), h("select", { class: `dyte-select ${this.issueIndex === 0 ? 'disabled' : ''}`, onChange: (e) => this.selectIssue(e.target.value) }, issues.map((issue) => (h("option", { value: issue.index }, h("span", null, issue.value))))), ((_c = (_b = issues[this.issueIndex]) === null || _b === void 0 ? void 0 : _b.steps) === null || _c === void 0 ? void 0 : _c.length) > 0 && (h("div", { class: "sub-title" }, this.t('How to fix this:'))), (_e = (_d = issues[this.issueIndex]) === null || _d === void 0 ? void 0 : _d.steps) === null || _e === void 0 ? void 0 :
      _e.map((step) => (h("div", { class: "recommendation" }, h("div", null, "\u2022"), this.t(step)))), ((_g = (_f = issues[this.issueIndex]) === null || _f === void 0 ? void 0 : _f.steps) === null || _g === void 0 ? void 0 : _g.length) > 0 &&
      (this.reported ? (h("p", { class: "report-link" }, this.t('Your issue has been reported.'))) : (h("div", { class: "report-issue" }, h("p", { class: "recommendation", ref: (el) => (this.reportEl = el) }, this.t('Still facing the issue?')), h("dyte-button", { size: "sm", variant: "secondary", onClick: () => this.reportIssue() }, this.t('Report Now')))))));
  }
};
DyteDebuggerAudio$1.style = dyteDebuggerIssuesUiCss;

const dyteDebuggerPermissionsUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;width:100%}h3{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);font-size:14px}.info{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:center;justify-content:center;font-size:14px}.info dyte-icon{margin-right:var(--dyte-space-2, 8px)}.text{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);font-size:14px;font-weight:100 !important;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.title{display:flex;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;flex-direction:row;align-items:center;justify-content:center;font-size:16px;font-weight:700;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.title dyte-icon{margin-right:var(--dyte-space-2, 8px)}.device-indicator{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:column}.sub-title{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;font-weight:600;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));letter-spacing:0.5px}.recommendation{margin-bottom:var(--dyte-space-1, 4px);display:flex;flex-direction:row;align-items:flex-start;justify-content:flex-start;font-size:12px;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.recommendation div{margin-right:var(--dyte-space-2, 8px)}.device{margin-bottom:var(--dyte-space-2, 8px);display:flex;flex-direction:row;font-size:14px}.device .label{width:var(--dyte-space-32, 128px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.device .seperator{margin-right:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.ACCEPTED{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.NOT_REQUESTED{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.NOT_REQUESTED dyte-icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}.DENIED,.SYSTEM_DENIED,.COULD_NOT_START{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}video{margin-top:var(--dyte-space-2, 8px);height:var(--dyte-space-36, 144px);width:auto;border-radius:var(--dyte-border-radius-md, 8px)}dyte-button{margin-top:var(--dyte-space-2, 8px)}";

const DyteDebuggerAudio = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.meeting = undefined;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.issueKey = 0;
    this.permission = undefined;
    this.devices = {};
    this.mediaType = undefined;
  }
  connectedCallback() {
    this.permissionUpdate(this.meeting, this.mediaType);
  }
  disconnectedCallback() {
    const { self } = this.meeting;
    self === null || self === void 0 ? void 0 : self.removeListener('mediaPermissionUpdate', this.updatePermission);
  }
  permissionUpdate(meeting, mediaType) {
    var _a, _b;
    if (!meeting || !mediaType)
      return;
    const { self, troubleshoot } = meeting;
    this.permission = (_b = (_a = troubleshoot[mediaType]) === null || _a === void 0 ? void 0 : _a.mediaPermission) !== null && _b !== void 0 ? _b : 'NOT_REQUESTED';
    this.getDevices();
    self === null || self === void 0 ? void 0 : self.addListener('mediaPermissionUpdate', this.updatePermission.bind(this));
    self === null || self === void 0 ? void 0 : self.addListener('deviceUpdate', this.deviceUpdateListener.bind(this));
  }
  updatePermission({ kind, message }) {
    if (kind !== this.mediaType)
      return;
    this.permission = message;
  }
  // TODO: later change this to events and consume the functions in audio/video troubleshooter components
  async allowPermission() {
    var _a, _b;
    if (this.mediaType === 'audio') {
      const troubleshooter = (_a = this.meeting.troubleshoot) === null || _a === void 0 ? void 0 : _a.audio;
      await (troubleshooter === null || troubleshooter === void 0 ? void 0 : troubleshooter.startTrackAnalysis(true));
      troubleshooter.stopTrackAnalysis();
    }
    if (this.mediaType === 'video') {
      const troubleshooter = (_b = this.meeting.troubleshoot) === null || _b === void 0 ? void 0 : _b.video;
      await troubleshooter.startPreview();
      troubleshooter.stopPreview();
    }
  }
  deviceUpdateListener({ device, preview }) {
    if (preview)
      return;
    if (device.kind === 'audioinput')
      this.devices = Object.assign(Object.assign({}, this.devices), { Microphone: device });
    if (device.kind === 'audiooutput')
      this.devices = Object.assign(Object.assign({}, this.devices), { Speaker: device });
    if (device.kind === 'videoinput')
      this.devices = Object.assign(Object.assign({}, this.devices), { Camera: device });
  }
  getDevices() {
    var _a, _b;
    const currentDevices = (_b = (_a = this.meeting) === null || _a === void 0 ? void 0 : _a.self) === null || _b === void 0 ? void 0 : _b.getCurrentDevices();
    const Microphone = currentDevices === null || currentDevices === void 0 ? void 0 : currentDevices.audio;
    const Speaker = currentDevices === null || currentDevices === void 0 ? void 0 : currentDevices.speaker;
    const Camera = currentDevices === null || currentDevices === void 0 ? void 0 : currentDevices.video;
    if (Microphone)
      this.devices = Object.assign(Object.assign({}, this.devices), { Microphone });
    if (Speaker)
      this.devices = Object.assign(Object.assign({}, this.devices), { Speaker });
    if (Camera)
      this.devices = Object.assign(Object.assign({}, this.devices), { Camera });
  }
  render() {
    var _a;
    const permission = (_a = permissionPrompts[this.mediaType]) === null || _a === void 0 ? void 0 : _a[this.permission];
    // const devices = this.getDevices();
    const { browserName, osName, isMobile } = this.meeting.self.device;
    const steps = permission.steps({ browserName, osName, media: this.mediaType });
    const image = permission.image({ browserName, isMobile, osName });
    const devices = this.mediaType === 'audio'
      ? ['Microphone', 'Speaker']
      : this.mediaType === 'video'
        ? ['Camera']
        : [];
    return (h(Host, null, h("h3", null, "Device Permissions"), h("div", { class: `info ${this.permission}` }, h("dyte-icon", { size: "sm", icon: this.iconPack[permission.icon] }), permission.info), h("div", { class: "text" }, permission.text), this.permission === 'ACCEPTED' && devices.length > 0 && (h("div", { class: "device-indicator" }, devices.map((device) => {
      var _a;
      return (h("div", { class: "device" }, h("div", { class: "label" }, "Active ", device), h("div", { class: "seperator" }, ":"), h("div", { class: "device-name" }, (_a = this.devices[device]) === null || _a === void 0 ? void 0 : _a.label)));
    }), h("div", { class: "text" }, this.t('You can change the active devices from settings.')))), steps.length > 0 && h("div", { class: "sub-title" }, this.t('How to fix this:')), steps === null || steps === void 0 ? void 0 :
      steps.map((step) => (h("div", { class: "recommendation" }, h("div", null, "\u2022"), this.t(step)))), image !== '' && (h("video", { src: `https://cdn.dyte.in/assets/permissions/${image}`, autoPlay: true, muted: true, loop: true })), this.mediaType !== 'screenshare' && this.permission === 'NOT_REQUESTED' && (h("dyte-button", { onClick: () => this.allowPermission() }, "Allow Device Permission"))));
  }
  static get watchers() { return {
    "meeting": ["permissionUpdate"],
    "mediaType": ["permissionUpdate"]
  }; }
};
DyteDebuggerAudio.style = dyteDebuggerPermissionsUiCss;

const dyteInformationTooltipCss = ":host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);cursor:pointer}.tooltip-container{position:relative;display:flex;flex-direction:row;align-items:center}.tooltip-container dyte-icon{cursor:pointer;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.tooltip-container dyte-icon:hover+.tooltip{display:flex !important}.tooltip{position:absolute;margin-left:var(--dyte-space-2, 8px);display:none !important;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);font-weight:400;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));z-index:50;display:flex;min-width:var(--dyte-space-60, 240px);flex-direction:column;--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);left:14px}";

const DyteInformationTooltip = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.iconPack = defaultIconPack;
  }
  render() {
    return (h(Host, null, h("div", { class: "tooltip-container" }, h("dyte-icon", { icon: this.iconPack.info, size: "sm" }), h("div", { class: "tooltip" }, h("slot", { name: "tootlip-text" })))));
  }
};
DyteInformationTooltip.style = dyteInformationTooltipCss;

var dyteDebuggerIssuesUi_3_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_debugger_issues_ui: DyteDebuggerAudio$1,
    dyte_debugger_permissions_ui: DyteDebuggerAudio,
    dyte_information_tooltip: DyteInformationTooltip
});

const dyteDialogCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);box-sizing:border-box;padding:var(--dyte-space-4, 16px);flex-direction:column;align-items:center;justify-content:center;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / 0.5);color:rgb(var(--dyte-colors-text-1000, 255 255 255));visibility:hidden;display:none;z-index:60;-webkit-backdrop-filter:blur(12px) saturate(180%);backdrop-filter:blur(12px) saturate(180%)}#dialog{position:relative;max-height:100%;max-width:100%}#dismiss-btn{position:absolute;top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);z-index:50}::slotted(*){max-height:100%;max-width:100%}:host([open]){visibility:visible;display:flex}:host([open='false']){visibility:hidden;display:none}";

const DyteDialog = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.onClose = createEvent(this, "dyteDialogClose", 7);
    this.close = () => {
      this.open = false;
      this.onClose.emit();
    };
    this.keydownListener = (e) => {
      if (e.key === 'Escape' && this.open) {
        this.close();
      }
    };
    this.hideCloseButton = false;
    this.meeting = undefined;
    this.config = defaultConfig;
    this.states = undefined;
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.open = true;
  }
  connectedCallback() {
    document.addEventListener('keydown', this.keydownListener);
  }
  disconnectedCallback() {
    document.removeEventListener('keydown', this.keydownListener);
  }
  render() {
    if (!this.open) {
      return null;
    }
    return (h(Host, null, h("div", { id: "dialog", part: "container" }, h("slot", null), !this.hideCloseButton && (h("dyte-button", { part: "close-button", id: "dismiss-btn", kind: "icon", variant: "ghost", onClick: () => this.close(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))));
  }
};
DyteDialog.style = dyteDialogCss;

var dyteDialog_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_dialog: DyteDialog
});

const dyteLogoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;flex-direction:column;align-items:center;justify-content:center;color:rgb(var(--dyte-colors-text-1000, 255 255 255));height:100%;width:auto}svg,img{height:100%;width:auto}.brand-color{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

const DyteLogo = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.logoUrl = undefined;
    this.config = defaultConfig;
    this.meeting = undefined;
    this.t = useLanguage();
  }
  connectedCallback() {
    this.configChanged(this.config);
    this.meetingChanged(this.meeting);
  }
  configChanged(config) {
    var _a;
    if (config != null) {
      const configLogo = (_a = config === null || config === void 0 ? void 0 : config.designTokens) === null || _a === void 0 ? void 0 : _a.logo;
      // NOTE(callmetarush): Only update logo if not passed via prop
      if (configLogo != null && this.logoUrl == null) {
        this.logoUrl = configLogo;
      }
    }
  }
  meetingChanged(meeting) {
    var _a, _b, _c, _d;
    if (meeting != null) {
      const meetingLogo = (_d = (_c = (_b = (_a = meeting.self) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.header) === null || _c === void 0 ? void 0 : _c.elements) === null || _d === void 0 ? void 0 : _d.logo;
      if (meetingLogo != null && this.logoUrl == null) {
        this.logoUrl = meetingLogo;
      }
    }
  }
  render() {
    if (!this.logoUrl || this.logoUrl === '') {
      return null;
    }
    const logo = this.logoUrl;
    const text = this.t('logo');
    return (h(Host, null, h("img", { src: logo, alt: text })));
  }
  static get watchers() { return {
    "config": ["configChanged"],
    "meeting": ["meetingChanged"]
  }; }
};
DyteLogo.style = dyteLogoCss;

var dyteLogo_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_logo: DyteLogo
});

function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

const min$1 = Math.min;
const max$1 = Math.max;

function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,
  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds
    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. This stops `shift()` from taking action, but can
    // be worked around by calling it again after the `arrow()` if desired.
    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }
});

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = 'bottom';
        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;
              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
              if (placement) {
                resetPlacement = placement;
              }
              break;
            }
          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform,
    elements
  } = middlewareArguments;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    async fn(middlewareArguments) {
      const {
        x,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
}

let uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
    return uaString;
  }
  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;

  // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(
  // TS 4.1 compat
  value => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
  // Feature detection for this fails in various ways
  // • Always-visible scrollbar or not
  // • Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const offsetWidth = element.offsetWidth;
  const offsetHeight = element.offsetHeight;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

const FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node
  node.assignedSlot ||
  // DOM Element detected
  node.parentNode || (
  // ShadowRoot detected
  isShadowRoot(node) ? node.host : null) ||
  // Fallback
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  return getCssDimensions(element);
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
    // This doesn't appear to need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }
  }

  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}

// Returns the inner client rect, subtracting scrollbars if present
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y,
    width,
    height
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  if (clippingAncestor === 'viewport') {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingAncestor)) {
    return getInnerBoundingClientRect(clippingAncestor, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...(await getDimensionsFn(floating))
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

const dyteMenuCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:inline-block;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}#menu-list{position:absolute;z-index:20;display:none}";

const DyteMenu$1 = class DyteMenu {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.clickedThis = false;
    this.handleOutsideClick = () => {
      // handles clicking on other menu triggers
      if (!this.clickedThis) {
        // if other trigger is clicked, hide this menu-list
        this.menuListEl.style.display = 'none';
      }
      // reset the value
      this.clickedThis = false;
    };
    this.size = undefined;
    this.placement = 'bottom-end';
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  componentDidLoad() {
    document.addEventListener('click', this.handleOutsideClick);
    this.update();
  }
  disconnectedCallback() {
    document.removeEventListener('click', this.handleOutsideClick);
  }
  update() {
    computePosition(this.triggerEl, this.menuListEl, {
      placement: this.placement,
      middleware: [offset(10), flip(), shift({ padding: 5 })],
    }).then(({ x, y }) => {
      Object.assign(this.menuListEl.style, {
        left: `${x}px`,
        top: `${y}px`,
      });
    });
  }
  render() {
    return (h(Host, null, h("span", { id: "trigger", ref: (el) => (this.triggerEl = el), onClick: () => {
        this.clickedThis = true;
        if (this.menuListEl.style.display !== 'block') {
          this.menuListEl.style.display = 'block';
          this.update();
        }
        else {
          this.menuListEl.style.display = 'none';
        }
      } }, h("slot", { name: "trigger" })), h("span", { part: "menu-list", id: "menu-list", ref: (el) => (this.menuListEl = el) }, h("slot", null))));
  }
};
DyteMenu$1.style = dyteMenuCss;

const dyteMenuItemCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px}::slotted([slot='start']){margin-right:var(--dyte-space-2, 8px)}::slotted([slot='end']){margin-left:var(--dyte-space-2, 8px)}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host(.red){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

const DyteMenuItem = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("slot", { name: "start" }), h("slot", null), h("slot", { name: "end" })));
  }
};
DyteMenuItem.style = dyteMenuItemCss;

const dyteMenuListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:-webkit-max-content;width:-moz-max-content;width:max-content;flex-direction:column;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;border-radius:var(--dyte-border-radius-sm, 4px);--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}";

const DyteMenuList = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("slot", null)));
  }
};
DyteMenuList.style = dyteMenuListCss;

var dyteMenu_3_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_menu: DyteMenu$1,
    dyte_menu_item: DyteMenuItem,
    dyte_menu_list: DyteMenuList
});

const dyteAvatarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:var(--dyte-space-32, 128px);width:var(--dyte-space-32, 128px);align-items:center;justify-content:center;font-size:28px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));overflow:hidden;border-radius:9999px}dyte-icon{height:50%;width:50%}.image-ctr{display:flex;height:100%;width:100%;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}img{height:var(--dyte-space-0, 0px);width:var(--dyte-space-0, 0px);-o-object-fit:cover;object-fit:cover}img.loaded{height:100%;width:100%}.initials{display:flex;height:100%;width:100%;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));text-transform:uppercase}.image{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.image img{display:none;height:100%;width:100%;-o-object-fit:cover;object-fit:cover}.image img.loaded{display:block}:host([variant='hexagon']){border-radius:var(--dyte-border-radius-none, 0);-webkit-clip-path:polygon(50% 0, 95% 25%, 95% 75%, 50% 100%, 5% 75%, 5% 25%);clip-path:polygon(50% 0, 95% 25%, 95% 75%, 50% 100%, 5% 75%, 5% 25%)}:host([variant='square']){border-radius:var(--dyte-border-radius-none, 0);-webkit-clip-path:polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);clip-path:polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)}:host([size='sm']){height:var(--dyte-space-14, 56px);width:var(--dyte-space-14, 56px);font-size:12px}:host([size='md']){height:var(--dyte-space-28, 112px);width:var(--dyte-space-28, 112px)}:host([size='lg']){height:var(--dyte-space-32, 128px);width:var(--dyte-space-32, 128px)}";

const DyteAvatar = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.getAvatar = () => {
      var _a;
      const name = formatName(((_a = this.participant) === null || _a === void 0 ? void 0 : _a.name) || '');
      let picture;
      if (this.participant != null && 'picture' in this.participant) {
        picture = this.participant.picture;
      }
      if (picture && picture.length > 0 && this.imageState !== 'errored') {
        return (h("div", { class: "image-ctr" }, this.imageState === 'loading' && h("dyte-spinner", { iconPack: this.iconPack, t: this.t }), h("img", { src: picture, class: { loaded: this.imageState === 'loaded' }, loading: "lazy", title: name, onLoad: () => (this.imageState = 'loaded'), onError: () => (this.imageState = 'errored'), part: "image" })));
      }
      const initials = getInitials(name);
      return (h("div", { class: "initials", title: name, part: "initials" }, initials));
    };
    this.participant = undefined;
    this.variant = 'circular';
    this.size = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.imageState = 'loading';
  }
  render() {
    return h(Host, null, this.getAvatar());
  }
};
DyteAvatar.style = dyteAvatarCss;

var dyteAvatar_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_avatar: DyteAvatar
});

const dyteControlbarButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--background-color:var(\n    --dyte-controlbar-button-background-color,\n    rgb(var(--dyte-colors-background-1000, 8 8 8))\n  );--icon-size:var(--dyte-controlbar-button-icon-size, var(--dyte-space-7, 28px));--button-spacing:var(--dyte-controlbar-button-spacing, var(--dyte-space-1, 4px));position:relative;box-sizing:border-box;display:inline-flex;outline:2px solid transparent !important;outline-offset:2px !important;margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-0\\.5, 2px);height:100%;width:auto;min-width:var(--dyte-space-20, 80px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;color:rgb(var(--dyte-colors-text-1000, 255 255 255));border:var(--dyte-border-width-md, 2px) solid transparent;background-color:var(--background-color)}button{padding:var(--dyte-space-1, 4px)}:host(.red-icon) #icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([disabled]){color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}button{box-sizing:border-box;display:inline-flex;height:100%;width:100%;flex:1 1 0%;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;color:inherit;outline:2px solid transparent;outline-offset:2px}.label{text-align:center;font-size:12px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}#warning-indicator{position:absolute;top:var(--dyte-space-1, 4px);right:var(--dyte-space-2, 8px);height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}:host([size='sm']) #warning-indicator{right:var(--dyte-space-0, 0px);top:var(--dyte-space-0, 0px);height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px)}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}#icon{margin-bottom:var(--button-spacing);width:var(--icon-size);height:var(--icon-size)}:host([size='sm']),:host([variant='horizontal']){--button-spacing:0px}:host(.leave:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity));border:var(--dyte-border-width-md, 2px) solid rgb(var(--dyte-colors-danger, 255 45 45))}:host(.active){--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-400, 53 110 253) / var(--tw-text-opacity));border:var(--dyte-border-width-md, 2px) solid rgb(var(--dyte-colors-brand-400, 53 110 253))}:host(.active-livestream){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([size='sm']){margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);min-width:var(--dyte-space-14, 56px)}:host([size='sm']) .label{display:none}:host([variant='horizontal']){margin:var(--dyte-space-0, 0px);height:var(--dyte-space-12, 48px);width:100%;padding-left:var(--dyte-space-5, 20px);padding-right:var(--dyte-space-5, 20px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px)}:host([variant='horizontal']) button{flex-direction:row;justify-content:flex-start}:host([variant='horizontal']) #icon{margin-right:var(--dyte-space-3, 12px);width:var(--dyte-space-6, 24px)}:host([variant='horizontal']) .label{display:block;font-size:14px;line-height:1.25rem}:host([variant='horizontal']) #warning-indicator{right:auto;left:var(--dyte-space-4, 16px)}:host([brand-icon]) dyte-icon#icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host .label{display:none}:slotted(dyte-icon){height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}}";

const DyteControlbarButton = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.variant = 'button';
    this.showWarning = false;
    this.size = undefined;
    this.label = undefined;
    this.icon = undefined;
    this.isLoading = undefined;
    this.disabled = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.brandIcon = false;
  }
  render() {
    return (h(Host, null, h("button", { "aria-label": this.label, part: "button" }, this.isLoading ? (h("dyte-spinner", { id: "icon", part: "spinner", iconPack: this.iconPack, t: this.t })) : (h("dyte-icon", { id: "icon", icon: this.icon, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t })), h("span", { class: "label", part: "label" }, this.label), this.showWarning && (h("dyte-icon", { id: "warning-indicator", icon: this.iconPack.warning, part: "warning-indicator", iconPack: this.iconPack, t: this.t })))));
  }
};
DyteControlbarButton.style = dyteControlbarButtonCss;

var dyteControlbarButton_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_controlbar_button: DyteControlbarButton
});

const dyteTooltipCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--background-color:var(--dyte-tooltip-background-color, rgb(var(--dyte-colors-background-600, 60 60 60)));--color:var(--dyte-tooltip-color, rgb(var(--dyte-colors-text-1000, 255 255 255)));display:inline-flex}#trigger{display:block;width:100%;flex:1 1 0%}.tooltip{max-width:var(--dyte-space-64, 256px);position:fixed;z-index:20;display:none;width:-webkit-max-content;width:-moz-max-content;width:max-content;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);font-size:12px}.tooltip,#arrow{position:absolute;background-color:var(--background-color);color:var(--color)}#arrow{position:absolute;height:var(--dyte-space-2, 8px);width:var(--dyte-space-2, 8px);transform:rotate(45deg)}:host([variant='primary']){--background-color:rgb(var(--dyte-colors-brand-500, 33 96 253));--color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}:host([kind='block']){display:block}";

const DyteMenu = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.dyteOpenChange = createEvent(this, "dyteOpenChange", 7);
    this.showMenu = () => {
      if (this.disabled)
        return;
      this.isInFocus = true;
      setTimeout(() => {
        if (this.isInFocus) {
          this.tooltipEl.style.display = 'block';
          this.update();
          this.dyteOpenChange.emit(true);
          if (this.size === 'sm') {
            setTimeout(() => {
              if (this.isInFocus) {
                this.hideMenu();
              }
            }, 1000);
          }
        }
      }, this.delay);
    };
    this.hideMenu = () => {
      if (this.open || this.disabled)
        return;
      this.isInFocus = false;
      this.tooltipEl.style.display = 'none';
      this.dyteOpenChange.emit(false);
    };
    this.label = '';
    this.variant = 'secondary';
    this.disabled = false;
    this.open = false;
    this.kind = 'inline';
    this.size = undefined;
    this.placement = 'top';
    this.delay = 0;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.isInFocus = false;
  }
  componentDidLoad() {
    this.triggerEl.addEventListener('focusin', this.showMenu);
    this.triggerEl.addEventListener('mouseenter', this.showMenu);
    this.triggerEl.addEventListener('focusout', this.hideMenu);
    this.triggerEl.addEventListener('mouseleave', this.hideMenu);
    writeTask(() => {
      this.openChanged(this.open);
    });
  }
  openChanged(open) {
    if (open) {
      this.showMenu();
    }
    else {
      this.hideMenu();
    }
  }
  update() {
    computePosition(this.triggerEl, this.tooltipEl, {
      placement: this.placement,
      middleware: [offset(8), flip(), shift({ padding: 5 }), arrow({ element: this.arrowEl })],
    }).then(({ x, y, placement, middlewareData }) => {
      Object.assign(this.tooltipEl.style, {
        left: `${x}px`,
        top: `${y}px`,
      });
      const { x: arrowX, y: arrowY } = middlewareData.arrow;
      const staticSide = {
        top: 'bottom',
        right: 'left',
        bottom: 'top',
        left: 'right',
      }[placement.split('-')[0]];
      Object.assign(this.arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : '',
        top: arrowY != null ? `${arrowY}px` : '',
        right: '',
        bottom: '',
        [staticSide]: '-4px',
      });
    });
  }
  render() {
    return (h(Host, null, h("span", { part: "trigger", id: "trigger", ref: (el) => (this.triggerEl = el) }, h("slot", null)), h("div", { part: "tooltip", class: "tooltip", id: "tooltip", role: "tooltip", ref: (el) => (this.tooltipEl = el) }, h("div", { id: "arrow", ref: (el) => (this.arrowEl = el), part: "arrow" }), this.label, h("slot", { name: "tooltip" }))));
  }
  static get watchers() { return {
    "open": ["openChanged"]
  }; }
};
DyteMenu.style = dyteTooltipCss;

var dyteTooltip_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_tooltip: DyteMenu
});

const dyteSpinnerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:block;height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px);--dyte-spinner-color:currentColor}.spinner{height:100%;width:100%}@-webkit-keyframes spin{to{transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}.spinner{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite;border-radius:9999px;background-color:transparent;-webkit-animation-duration:1.3s;animation-duration:1.3s}:host([size='md']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

const DyteSpinner = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.iconPack = defaultIconPack;
    this.size = 'md';
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("dyte-icon", { class: "spinner", icon: this.iconPack.spinner, iconPack: this.iconPack, t: this.t })));
  }
};
DyteSpinner.style = dyteSpinnerCss;

var dyteSpinner_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_spinner: DyteSpinner
});

const dyteButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--icon-size:var(--dyte-button-icon-size, var(--dyte-space-5, 20px));--transition-property:var(--dyte-transition-property, all);--transition-duration:100ms;display:inline-flex;height:var(--dyte-space-8, 32px);cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-sm, 4px);transition-property:var(--transition-property);transition-duration:var(--transition-duration)}button{box-sizing:border-box;background-color:transparent;color:inherit;border:var(--dyte-border-width-sm, 1px) solid transparent;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);display:inline-flex;flex-grow:1;justify-content:center;vertical-align:baseline;gap:var(--dyte-space-1, 4px);transition-property:var(--transition-property);transition-duration:var(--transition-duration);outline:none;height:inherit;border-radius:inherit;fill:inherit;cursor:inherit;font-weight:inherit;font-family:inherit;font-size:inherit;line-height:inherit}.start,.content,.end{align-self:center}::slotted(dyte-icon),::slotted(dyte-spinner){height:var(--icon-size);width:var(--icon-size)}:host([variant='primary']){color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}button:focus-visible{border-color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host(:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity))}:host([disabled]){cursor:not-allowed;opacity:0.6}:host([variant='secondary']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='secondary']:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([variant='secondary']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}:host([variant='danger']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}:host([variant='danger']:hover){background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.7)}:host([variant='danger']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}:host([variant='ghost']){background-color:transparent;color:inherit}:host([variant='ghost'].active){--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}:host([variant='ghost']:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='ghost']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([kind='icon']){--icon-size:var(--dyte-space-5, 20px);width:var(--dyte-space-8, 32px)}:host([kind='icon']) button{padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px)}:host([kind='wide']){width:100%}:host([size='lg']){--icon-size:var(--dyte-space-5, 20px);height:var(--dyte-space-10, 40px);font-size:16px}:host([size='lg'][kind='icon']){--icon-size:var(--dyte-space-6, 24px);height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px)}:host([size='sm']){--icon-size:var(--dyte-space-4, 16px);height:var(--dyte-space-6, 24px);font-size:12px}:host([size='sm'][kind='icon']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}";

const DyteButton = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = undefined;
    this.variant = 'primary';
    this.kind = 'button';
    this.reverse = false;
    this.disabled = false;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
  }
  render() {
    return (h(Host, null, h("button", { part: "button" }, h("span", { class: "start" }, h("slot", { name: "start" })), h("span", { class: "content", part: "content" }, h("slot", null)), h("span", { class: "end" }, h("slot", { name: "end" })))));
  }
};
DyteButton.style = dyteButtonCss;

var dyteButton_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_button: DyteButton
});

const dyteIconCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:var(--dyte-space-10, 40px);outline:2px solid transparent;outline-offset:2px}:host .icon-wrapper{display:flex;height:100%;width:100%;flex-direction:column;align-items:center}:host svg{height:100%;width:100%;outline:2px solid transparent;outline-offset:2px}:host([size='md']){box-sizing:border-box;display:block;height:var(--dyte-space-6, 24px) !important;width:var(--dyte-space-6, 24px) !important;--dyte-spinner-color:currentColor}:host([size='sm']){box-sizing:border-box;display:block;height:var(--dyte-space-4, 16px) !important;width:var(--dyte-space-4, 16px) !important;--dyte-spinner-color:currentColor}";

const parseIcon = (icon) => {
  try {
    return JSON.parse(icon);
  }
  catch (e) {
    return icon;
  }
};
const DyteIcon = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.icon = undefined;
    this.iconPack = defaultIconPack;
    this.t = useLanguage();
    this.size = 'lg';
  }
  render() {
    return (h(Host, null, h("div", { class: "icon-wrapper", innerHTML: parseIcon(this.icon), part: "wrapper" })));
  }
};
DyteIcon.style = dyteIconCss;

var dyteIcon_entry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dyte_icon: DyteIcon
});

export { defineCustomElements };